diff -rupN a/config/system-headers b/config/system-headers
--- a/config/system-headers	2017-01-23 11:13:48.000000000 -0500
+++ b/config/system-headers	2017-03-07 23:40:34.289635643 -0500
@@ -489,6 +489,7 @@ gdk/gdkkeysyms.h
 gdk/gdkprivate.h
 gdk/gdkx.h
 gdk/gdkdirectfb.h
+gdk/gdkwayland.h
 gdk-pixbuf/gdk-pixbuf.h
 Gestalt.h
 getopt.h
diff -rupN a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
--- a/dom/ipc/ContentChild.cpp	2017-01-25 23:20:09.000000000 -0500
+++ b/dom/ipc/ContentChild.cpp	2017-03-07 23:43:33.322645232 -0500
@@ -524,6 +524,44 @@ NS_INTERFACE_MAP_BEGIN(ContentChild)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContentChild)
 NS_INTERFACE_MAP_END
 
+#ifdef MOZ_WIDGET_GTK
+// We need to keep in sync whith the same detection routine at nsAppRunner.cpp
+static char* detectDisplay(void)
+{
+  bool tryX11 = false;
+  bool tryWayland = false;
+  bool tryBroadway = false;
+
+  // Honor user backend selection
+  char *backend = PR_GetEnv("GDK_BACKEND");
+  if (!backend || strstr(backend, "*")) {
+    // Try all backends
+    tryX11 = true;
+    tryWayland = true;
+    tryBroadway = true;
+  } else if (backend) {
+    if (strstr(backend, "x11"))
+      tryX11 = true;
+    if (strstr(backend, "wayland"))
+      tryWayland = true;
+    if (strstr(backend, "broadway"))
+      tryBroadway = true;
+  }
+
+  char *display_name;
+  if (tryX11 && (display_name = PR_GetEnv("DISPLAY"))) {
+    return display_name;
+  } else if (tryWayland && (display_name = PR_GetEnv("WAYLAND_DISPLAY"))) {
+    return display_name;
+  } else if (tryBroadway && (display_name = PR_GetEnv("BROADWAY_DISPLAY"))) {
+    return display_name;
+  }
+
+  MOZ_ASSERT(display_name);
+  return nullptr;
+}
+#endif
+
 bool
 ContentChild::Init(MessageLoop* aIOLoop,
                    base::ProcessId aParentPid,
@@ -535,7 +573,7 @@ ContentChild::Init(MessageLoop* aIOLoop,
   // to use, and when starting under XWayland, it may choose to start with
   // the wayland backend instead of the x11 backend.
   // The DISPLAY environment variable is normally set by the parent process.
-  char* display_name = PR_GetEnv("DISPLAY");
+  char* display_name = detectDisplay();
   if (display_name) {
     int argc = 3;
     char option_name[] = "--display";
diff -rupN a/dom/ipc/ContentChild.cpp.orig b/dom/ipc/ContentChild.cpp.orig
--- a/dom/ipc/ContentChild.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/dom/ipc/ContentChild.cpp.orig	2017-03-07 23:40:34.290635643 -0500
@@ -0,0 +1,3385 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifdef MOZ_WIDGET_GTK
+#include <gtk/gtk.h>
+#endif
+
+#include "ContentChild.h"
+
+#include "BlobChild.h"
+#include "CrashReporterChild.h"
+#include "GeckoProfiler.h"
+#include "TabChild.h"
+#include "HandlerServiceChild.h"
+
+#include "mozilla/Attributes.h"
+#include "mozilla/LookAndFeel.h"
+#include "mozilla/Preferences.h"
+#include "mozilla/ProcessHangMonitorIPC.h"
+#include "mozilla/Unused.h"
+#include "mozilla/devtools/HeapSnapshotTempFileHelperChild.h"
+#include "mozilla/docshell/OfflineCacheUpdateChild.h"
+#include "mozilla/dom/ContentBridgeChild.h"
+#include "mozilla/dom/ContentBridgeParent.h"
+#include "mozilla/dom/VideoDecoderManagerChild.h"
+#include "mozilla/dom/ContentParent.h"
+#include "mozilla/dom/DataTransfer.h"
+#include "mozilla/dom/DOMStorageIPC.h"
+#include "mozilla/dom/ExternalHelperAppChild.h"
+#include "mozilla/dom/FlyWebPublishedServerIPC.h"
+#include "mozilla/dom/GetFilesHelper.h"
+#include "mozilla/dom/PCrashReporterChild.h"
+#include "mozilla/dom/ProcessGlobal.h"
+#include "mozilla/dom/PushNotifier.h"
+#include "mozilla/dom/workers/ServiceWorkerManager.h"
+#include "mozilla/dom/nsIContentChild.h"
+#include "mozilla/gfx/gfxVars.h"
+#include "mozilla/psm/PSMContentListener.h"
+#include "mozilla/hal_sandbox/PHalChild.h"
+#include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/FileDescriptorSetChild.h"
+#include "mozilla/ipc/FileDescriptorUtils.h"
+#include "mozilla/ipc/GeckoChildProcessHost.h"
+#include "mozilla/ipc/ProcessChild.h"
+#include "mozilla/ipc/PSendStreamChild.h"
+#include "mozilla/ipc/TestShellChild.h"
+#include "mozilla/jsipc/CrossProcessObjectWrappers.h"
+#include "mozilla/layers/APZChild.h"
+#include "mozilla/layers/CompositorBridgeChild.h"
+#include "mozilla/layers/ContentProcessController.h"
+#include "mozilla/layers/ImageBridgeChild.h"
+#include "mozilla/layout/RenderFrameChild.h"
+#include "mozilla/net/NeckoChild.h"
+#include "mozilla/net/CaptivePortalService.h"
+#include "mozilla/plugins/PluginInstanceParent.h"
+#include "mozilla/plugins/PluginModuleParent.h"
+#include "mozilla/widget/WidgetMessageUtils.h"
+#include "nsBaseDragService.h"
+#include "mozilla/media/MediaChild.h"
+#include "mozilla/BasePrincipal.h"
+#include "mozilla/WebBrowserPersistDocumentChild.h"
+#include "imgLoader.h"
+#include "GMPServiceChild.h"
+
+#if defined(MOZ_CONTENT_SANDBOX)
+#if defined(XP_WIN)
+#define TARGET_SANDBOX_EXPORTS
+#include "mozilla/sandboxTarget.h"
+#elif defined(XP_LINUX)
+#include "mozilla/Sandbox.h"
+#include "mozilla/SandboxInfo.h"
+
+// Remove this include with Bug 1104619
+#include "CubebUtils.h"
+#elif defined(XP_MACOSX)
+#include "mozilla/Sandbox.h"
+#endif
+#endif
+
+#include "mozilla/Unused.h"
+
+#include "mozInlineSpellChecker.h"
+#include "nsDocShell.h"
+#include "nsIConsoleListener.h"
+#include "nsICycleCollectorListener.h"
+#include "nsIIdlePeriod.h"
+#include "nsIDragService.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "nsIInterfaceRequestorUtils.h"
+#include "nsIMemoryReporter.h"
+#include "nsIMemoryInfoDumper.h"
+#include "nsIMutable.h"
+#include "nsIObserverService.h"
+#include "nsIScriptSecurityManager.h"
+#include "nsScreenManagerProxy.h"
+#include "nsMemoryInfoDumper.h"
+#include "nsServiceManagerUtils.h"
+#include "nsStyleSheetService.h"
+#include "nsVariant.h"
+#include "nsXULAppAPI.h"
+#include "nsIScriptError.h"
+#include "nsIConsoleService.h"
+#include "nsJSEnvironment.h"
+#include "SandboxHal.h"
+#include "nsDebugImpl.h"
+#include "nsHashPropertyBag.h"
+#include "nsLayoutStylesheetCache.h"
+#include "nsThreadManager.h"
+#include "nsAnonymousTemporaryFile.h"
+#include "nsISpellChecker.h"
+#include "nsClipboardProxy.h"
+#include "nsDirectoryService.h"
+#include "nsDirectoryServiceUtils.h"
+#include "nsDirectoryServiceDefs.h"
+#include "nsContentPermissionHelper.h"
+#ifdef NS_PRINTING
+#include "nsPrintingProxy.h"
+#endif
+
+#include "IHistory.h"
+#include "nsNetUtil.h"
+
+#include "base/message_loop.h"
+#include "base/process_util.h"
+#include "base/task.h"
+
+#include "nsChromeRegistryContent.h"
+#include "nsFrameMessageManager.h"
+
+#include "nsIGeolocationProvider.h"
+#include "mozilla/dom/PMemoryReportRequestChild.h"
+#include "mozilla/dom/PCycleCollectWithLogsChild.h"
+
+#include "nsIScriptSecurityManager.h"
+#include "nsHostObjectProtocolHandler.h"
+
+#ifdef MOZ_WEBRTC
+#include "signaling/src/peerconnection/WebrtcGlobalChild.h"
+#endif
+
+#ifdef MOZ_PERMISSIONS
+#include "nsPermission.h"
+#include "nsPermissionManager.h"
+#endif
+
+#include "PermissionMessageUtils.h"
+
+#if defined(MOZ_WIDGET_ANDROID)
+#include "APKOpen.h"
+#endif
+
+#if defined(MOZ_WIDGET_GONK)
+#include "nsVolume.h"
+#include "nsVolumeService.h"
+#include "SpeakerManagerService.h"
+#endif
+
+#ifdef XP_WIN
+#include <process.h>
+#define getpid _getpid
+#include "mozilla/widget/AudioSession.h"
+#endif
+
+#ifdef MOZ_X11
+#include "mozilla/X11Util.h"
+#endif
+
+#ifdef ACCESSIBILITY
+#include "nsAccessibilityService.h"
+#endif
+
+#include "mozilla/dom/File.h"
+#include "mozilla/dom/devicestorage/DeviceStorageRequestChild.h"
+#include "mozilla/dom/PPresentationChild.h"
+#include "mozilla/dom/PresentationIPCService.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+
+#ifdef MOZ_WEBSPEECH
+#include "mozilla/dom/PSpeechSynthesisChild.h"
+#endif
+
+#include "ProcessUtils.h"
+#include "URIUtils.h"
+#include "nsContentUtils.h"
+#include "nsIPrincipal.h"
+#include "nsDeviceStorage.h"
+#include "DomainPolicy.h"
+#include "mozilla/dom/ipc/StructuredCloneData.h"
+#include "mozilla/dom/time/DateCacheCleaner.h"
+#include "mozilla/net/NeckoMessageUtils.h"
+#include "mozilla/widget/PuppetBidiKeyboard.h"
+#include "mozilla/RemoteSpellCheckEngineChild.h"
+#include "GMPServiceChild.h"
+#include "gfxPlatform.h"
+#include "nscore.h" // for NS_FREE_PERMANENT_DATA
+#include "VRManagerChild.h"
+
+using namespace mozilla;
+using namespace mozilla::docshell;
+using namespace mozilla::dom::devicestorage;
+using namespace mozilla::dom::ipc;
+using namespace mozilla::dom::workers;
+using namespace mozilla::media;
+using namespace mozilla::embedding;
+using namespace mozilla::gmp;
+using namespace mozilla::hal_sandbox;
+using namespace mozilla::ipc;
+using namespace mozilla::layers;
+using namespace mozilla::layout;
+using namespace mozilla::net;
+using namespace mozilla::jsipc;
+using namespace mozilla::psm;
+using namespace mozilla::widget;
+#if defined(MOZ_WIDGET_GONK)
+using namespace mozilla::system;
+#endif
+using namespace mozilla::widget;
+
+namespace mozilla {
+namespace dom {
+
+class MemoryReportRequestChild : public PMemoryReportRequestChild,
+                                 public nsIRunnable
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  MemoryReportRequestChild(bool aAnonymize,
+                           const MaybeFileDesc& aDMDFile);
+  NS_IMETHOD Run() override;
+
+private:
+  virtual ~MemoryReportRequestChild();
+
+  bool     mAnonymize;
+  FileDescriptor mDMDFile;
+};
+
+NS_IMPL_ISUPPORTS(MemoryReportRequestChild, nsIRunnable)
+
+MemoryReportRequestChild::MemoryReportRequestChild(
+  bool aAnonymize, const MaybeFileDesc& aDMDFile)
+: mAnonymize(aAnonymize)
+{
+  MOZ_COUNT_CTOR(MemoryReportRequestChild);
+  if (aDMDFile.type() == MaybeFileDesc::TFileDescriptor) {
+    mDMDFile = aDMDFile.get_FileDescriptor();
+  }
+}
+
+MemoryReportRequestChild::~MemoryReportRequestChild()
+{
+  MOZ_COUNT_DTOR(MemoryReportRequestChild);
+}
+
+// IPC sender for remote GC/CC logging.
+class CycleCollectWithLogsChild final
+  : public PCycleCollectWithLogsChild
+  , public nsICycleCollectorLogSink
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  CycleCollectWithLogsChild(const FileDescriptor& aGCLog,
+                            const FileDescriptor& aCCLog)
+  {
+    mGCLog = FileDescriptorToFILE(aGCLog, "w");
+    mCCLog = FileDescriptorToFILE(aCCLog, "w");
+  }
+
+  NS_IMETHOD Open(FILE** aGCLog, FILE** aCCLog) override
+  {
+    if (NS_WARN_IF(!mGCLog) || NS_WARN_IF(!mCCLog)) {
+      return NS_ERROR_FAILURE;
+    }
+    *aGCLog = mGCLog;
+    *aCCLog = mCCLog;
+    return NS_OK;
+  }
+
+  NS_IMETHOD CloseGCLog() override
+  {
+    MOZ_ASSERT(mGCLog);
+    fclose(mGCLog);
+    mGCLog = nullptr;
+    SendCloseGCLog();
+    return NS_OK;
+  }
+
+  NS_IMETHOD CloseCCLog() override
+  {
+    MOZ_ASSERT(mCCLog);
+    fclose(mCCLog);
+    mCCLog = nullptr;
+    SendCloseCCLog();
+    return NS_OK;
+  }
+
+  NS_IMETHOD GetFilenameIdentifier(nsAString& aIdentifier) override
+  {
+    return UnimplementedProperty();
+  }
+
+  NS_IMETHOD SetFilenameIdentifier(const nsAString& aIdentifier) override
+  {
+    return UnimplementedProperty();
+  }
+
+  NS_IMETHOD GetProcessIdentifier(int32_t *aIdentifier) override
+  {
+    return UnimplementedProperty();
+  }
+
+  NS_IMETHOD SetProcessIdentifier(int32_t aIdentifier) override
+  {
+    return UnimplementedProperty();
+  }
+
+  NS_IMETHOD GetGcLog(nsIFile** aPath) override
+  {
+    return UnimplementedProperty();
+  }
+
+  NS_IMETHOD GetCcLog(nsIFile** aPath) override
+  {
+    return UnimplementedProperty();
+  }
+
+private:
+  ~CycleCollectWithLogsChild()
+  {
+    if (mGCLog) {
+      fclose(mGCLog);
+      mGCLog = nullptr;
+    }
+    if (mCCLog) {
+      fclose(mCCLog);
+      mCCLog = nullptr;
+    }
+    // The XPCOM refcount drives the IPC lifecycle; see also
+    // DeallocPCycleCollectWithLogsChild.
+    Unused << Send__delete__(this);
+  }
+
+  nsresult UnimplementedProperty()
+  {
+    MOZ_ASSERT(false, "This object is a remote GC/CC logger;"
+                      " this property isn't meaningful.");
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  FILE* mGCLog;
+  FILE* mCCLog;
+};
+
+NS_IMPL_ISUPPORTS(CycleCollectWithLogsChild, nsICycleCollectorLogSink);
+
+class AlertObserver
+{
+public:
+
+  AlertObserver(nsIObserver *aObserver, const nsString& aData)
+    : mObserver(aObserver)
+    , mData(aData)
+  {
+  }
+
+  ~AlertObserver() {}
+
+  bool ShouldRemoveFrom(nsIObserver* aObserver,
+                        const nsString& aData) const
+  {
+    return (mObserver == aObserver && mData == aData);
+  }
+
+  bool Observes(const nsString& aData) const
+  {
+    return mData.Equals(aData);
+  }
+
+  bool Notify(const nsCString& aType) const
+  {
+    mObserver->Observe(nullptr, aType.get(), mData.get());
+    return true;
+  }
+
+private:
+  nsCOMPtr<nsIObserver> mObserver;
+  nsString mData;
+};
+
+class ConsoleListener final : public nsIConsoleListener
+{
+public:
+  explicit ConsoleListener(ContentChild* aChild)
+  : mChild(aChild) {}
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSICONSOLELISTENER
+
+private:
+  ~ConsoleListener() {}
+
+  ContentChild* mChild;
+  friend class ContentChild;
+};
+
+NS_IMPL_ISUPPORTS(ConsoleListener, nsIConsoleListener)
+
+// Before we send the error to the parent process (which
+// involves copying the memory), truncate any long lines.  CSS
+// errors in particular share the memory for long lines with
+// repeated errors, but the IPC communication we're about to do
+// will break that sharing, so we better truncate now.
+static void
+TruncateString(nsAString& aString)
+{
+  if (aString.Length() > 1000) {
+    aString.Truncate(1000);
+  }
+}
+
+NS_IMETHODIMP
+ConsoleListener::Observe(nsIConsoleMessage* aMessage)
+{
+  if (!mChild) {
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIScriptError> scriptError = do_QueryInterface(aMessage);
+  if (scriptError) {
+    nsAutoString msg, sourceName, sourceLine;
+    nsXPIDLCString category;
+    uint32_t lineNum, colNum, flags;
+
+    nsresult rv = scriptError->GetErrorMessage(msg);
+    NS_ENSURE_SUCCESS(rv, rv);
+    TruncateString(msg);
+    rv = scriptError->GetSourceName(sourceName);
+    NS_ENSURE_SUCCESS(rv, rv);
+    TruncateString(sourceName);
+    rv = scriptError->GetSourceLine(sourceLine);
+    NS_ENSURE_SUCCESS(rv, rv);
+    TruncateString(sourceLine);
+
+    rv = scriptError->GetCategory(getter_Copies(category));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = scriptError->GetLineNumber(&lineNum);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = scriptError->GetColumnNumber(&colNum);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = scriptError->GetFlags(&flags);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    mChild->SendScriptError(msg, sourceName, sourceLine,
+                            lineNum, colNum, flags, category);
+    return NS_OK;
+  }
+
+  nsXPIDLString msg;
+  nsresult rv = aMessage->GetMessageMoz(getter_Copies(msg));
+  NS_ENSURE_SUCCESS(rv, rv);
+  mChild->SendConsoleMessage(msg);
+  return NS_OK;
+}
+
+class BackgroundChildPrimer final :
+  public nsIIPCBackgroundChildCreateCallback
+{
+public:
+  BackgroundChildPrimer()
+  { }
+
+  NS_DECL_ISUPPORTS
+
+private:
+  ~BackgroundChildPrimer()
+  { }
+
+  virtual void
+  ActorCreated(PBackgroundChild* aActor) override
+  {
+    MOZ_ASSERT(aActor, "Failed to create a PBackgroundChild actor!");
+  }
+
+  virtual void
+  ActorFailed() override
+  {
+    MOZ_CRASH("Failed to create a PBackgroundChild actor!");
+  }
+};
+
+NS_IMPL_ISUPPORTS(BackgroundChildPrimer, nsIIPCBackgroundChildCreateCallback)
+
+ContentChild* ContentChild::sSingleton;
+
+ContentChild::ContentChild()
+ : mID(uint64_t(-1))
+#if defined(XP_WIN) && defined(ACCESSIBILITY)
+ , mMsaaID(0)
+#endif
+ , mCanOverrideProcessName(true)
+ , mIsAlive(true)
+ , mShuttingDown(false)
+{
+  // This process is a content process, so it's clearly running in
+  // multiprocess mode!
+  nsDebugImpl::SetMultiprocessMode("Child");
+}
+
+ContentChild::~ContentChild()
+{
+#ifndef NS_FREE_PERMANENT_DATA
+  NS_RUNTIMEABORT("Content Child shouldn't be destroyed.");
+#endif
+}
+
+NS_INTERFACE_MAP_BEGIN(ContentChild)
+  NS_INTERFACE_MAP_ENTRY(nsIContentChild)
+  NS_INTERFACE_MAP_ENTRY(nsIWindowProvider)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContentChild)
+NS_INTERFACE_MAP_END
+
+#ifdef MOZ_WIDGET_GTK
+// We need to keep in sync whith the same detection routine at nsAppRunner.cpp
+static char* detectDisplay(void)
+{
+  bool tryX11 = false;
+  bool tryWayland = false;
+  bool tryBroadway = false;
+
+  // Honor user backend selection
+  char *backend = PR_GetEnv("GDK_BACKEND");
+  if (!backend || strstr(backend, "*")) {
+    // Try all backends
+    tryX11 = true;
+    tryWayland = true;
+    tryBroadway = true;
+  } else if (backend) {
+    if (strstr(backend, "x11"))
+      tryX11 = true;
+    if (strstr(backend, "wayland"))
+      tryWayland = true;
+    if (strstr(backend, "broadway"))
+      tryBroadway = true;
+  }
+
+  char *display_name;
+  if (tryX11 && (display_name = PR_GetEnv("DISPLAY"))) {
+    return display_name;
+  } else if (tryWayland && (display_name = PR_GetEnv("WAYLAND_DISPLAY"))) {
+    return display_name;
+  } else if (tryBroadway && (display_name = PR_GetEnv("BROADWAY_DISPLAY"))) {
+    return display_name;
+  }
+
+  PR_fprintf(PR_STDERR, "Error: GDK_BACKEND does not match available displays\n");
+  return nullptr;
+}
+#endif
+
+bool
+ContentChild::Init(MessageLoop* aIOLoop,
+                   base::ProcessId aParentPid,
+                   IPC::Channel* aChannel)
+{
+#ifdef MOZ_WIDGET_GTK
+  // We need to pass a display down to gtk_init because it's not going to
+  // use the one from the environment on its own when deciding which backend
+  // to use, and when starting under XWayland, it may choose to start with
+  // the wayland backend instead of the x11 backend.
+  // The DISPLAY environment variable is normally set by the parent process.
+  char* display_name = detectDisplay();
+  if (display_name) {
+    int argc = 3;
+    char option_name[] = "--display";
+    char* argv[] = {
+      // argv0 is unused because g_set_prgname() was called in
+      // XRE_InitChildProcess().
+      nullptr,
+      option_name,
+      display_name,
+      nullptr
+    };
+    char** argvp = argv;
+    gtk_init(&argc, &argvp);
+  } else {
+    gtk_init(nullptr, nullptr);
+  }
+#endif
+
+#ifdef MOZ_X11
+  // Do this after initializing GDK, or GDK will install its own handler.
+  XRE_InstallX11ErrorHandler();
+#endif
+
+  NS_ASSERTION(!sSingleton, "only one ContentChild per child");
+
+  // Once we start sending IPC messages, we need the thread manager to be
+  // initialized so we can deal with the responses. Do that here before we
+  // try to construct the crash reporter.
+  nsresult rv = nsThreadManager::get().Init();
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return false;
+  }
+
+  if (!Open(aChannel, aParentPid, aIOLoop)) {
+    return false;
+  }
+  sSingleton = this;
+
+  // If communications with the parent have broken down, take the process
+  // down so it's not hanging around.
+  GetIPCChannel()->SetAbortOnError(true);
+#if defined(XP_WIN) && defined(ACCESSIBILITY)
+  GetIPCChannel()->SetChannelFlags(MessageChannel::REQUIRE_A11Y_REENTRY);
+#endif
+
+#ifdef MOZ_X11
+  // Send the parent our X socket to act as a proxy reference for our X
+  // resources.
+  int xSocketFd = ConnectionNumber(DefaultXDisplay());
+  SendBackUpXResources(FileDescriptor(xSocketFd));
+#endif
+
+#ifdef MOZ_CRASHREPORTER
+  SendPCrashReporterConstructor(CrashReporter::CurrentThreadId(),
+                                XRE_GetProcessType());
+#endif
+
+  SendGetProcessAttributes(&mID, &mIsForApp, &mIsForBrowser);
+  InitProcessAttributes();
+
+#ifdef NS_PRINTING
+  // Force the creation of the nsPrintingProxy so that it's IPC counterpart,
+  // PrintingParent, is always available for printing initiated from the parent.
+  RefPtr<nsPrintingProxy> printingProxy = nsPrintingProxy::GetInstance();
+#endif
+
+  return true;
+}
+
+void
+ContentChild::InitProcessAttributes()
+{
+#ifdef MOZ_WIDGET_GONK
+  if (mIsForApp && !mIsForBrowser) {
+    SetProcessName(NS_LITERAL_STRING("(Preallocated app)"), false);
+  } else {
+    SetProcessName(NS_LITERAL_STRING("Browser"), false);
+  }
+#else
+  SetProcessName(NS_LITERAL_STRING("Web Content"), true);
+#endif
+}
+
+void
+ContentChild::SetProcessName(const nsAString& aName, bool aDontOverride)
+{
+  if (!mCanOverrideProcessName) {
+    return;
+  }
+
+  char* name;
+  if ((name = PR_GetEnv("MOZ_DEBUG_APP_PROCESS")) &&
+    aName.EqualsASCII(name)) {
+#ifdef OS_POSIX
+    printf_stderr("\n\nCHILDCHILDCHILDCHILD\n  [%s] debug me @%d\n\n", name,
+                  getpid());
+    sleep(30);
+#elif defined(OS_WIN)
+    // Windows has a decent JIT debugging story, so NS_DebugBreak does the
+    // right thing.
+    NS_DebugBreak(NS_DEBUG_BREAK,
+                 "Invoking NS_DebugBreak() to debug child process",
+                 nullptr, __FILE__, __LINE__);
+#endif
+  }
+
+  mProcessName = aName;
+  mozilla::ipc::SetThisProcessName(NS_LossyConvertUTF16toASCII(aName).get());
+
+  if (aDontOverride) {
+    mCanOverrideProcessName = false;
+  }
+}
+
+NS_IMETHODIMP
+ContentChild::ProvideWindow(mozIDOMWindowProxy* aParent,
+                            uint32_t aChromeFlags,
+                            bool aCalledFromJS,
+                            bool aPositionSpecified,
+                            bool aSizeSpecified,
+                            nsIURI* aURI,
+                            const nsAString& aName,
+                            const nsACString& aFeatures,
+                            bool aForceNoOpener,
+                            bool* aWindowIsNew,
+                            mozIDOMWindowProxy** aReturn)
+{
+  return ProvideWindowCommon(nullptr, aParent, false, aChromeFlags,
+                             aCalledFromJS, aPositionSpecified,
+                             aSizeSpecified, aURI, aName, aFeatures,
+                             aForceNoOpener, aWindowIsNew, aReturn);
+}
+
+nsresult
+ContentChild::ProvideWindowCommon(TabChild* aTabOpener,
+                                  mozIDOMWindowProxy* aParent,
+                                  bool aIframeMoz,
+                                  uint32_t aChromeFlags,
+                                  bool aCalledFromJS,
+                                  bool aPositionSpecified,
+                                  bool aSizeSpecified,
+                                  nsIURI* aURI,
+                                  const nsAString& aName,
+                                  const nsACString& aFeatures,
+                                  bool aForceNoOpener,
+                                  bool* aWindowIsNew,
+                                  mozIDOMWindowProxy** aReturn)
+{
+  *aReturn = nullptr;
+
+  nsAutoPtr<IPCTabContext> ipcContext;
+  TabId openerTabId = TabId(0);
+
+  if (aTabOpener) {
+    PopupIPCTabContext context;
+    openerTabId = aTabOpener->GetTabId();
+    context.opener() = openerTabId;
+    context.isMozBrowserElement() = aTabOpener->IsMozBrowserElement();
+    ipcContext = new IPCTabContext(context);
+  } else {
+    // It's possible to not have a TabChild opener in the case
+    // of ServiceWorker::OpenWindow.
+    UnsafeIPCTabContext unsafeTabContext;
+    ipcContext = new IPCTabContext(unsafeTabContext);
+  }
+
+  MOZ_ASSERT(ipcContext);
+  TabId tabId;
+  SendAllocateTabId(openerTabId,
+                    *ipcContext,
+                    GetID(),
+                    &tabId);
+
+  TabContext newTabContext = aTabOpener ? *aTabOpener : TabContext();
+  RefPtr<TabChild> newChild = new TabChild(this, tabId,
+                                           newTabContext, aChromeFlags);
+  if (NS_FAILED(newChild->Init())) {
+    return NS_ERROR_ABORT;
+  }
+
+  if (aTabOpener) {
+    MOZ_ASSERT(ipcContext->type() == IPCTabContext::TPopupIPCTabContext);
+    ipcContext->get_PopupIPCTabContext().opener() = aTabOpener;
+  }
+
+  Unused << SendPBrowserConstructor(
+    // We release this ref in DeallocPBrowserChild
+    RefPtr<TabChild>(newChild).forget().take(),
+    tabId, *ipcContext, aChromeFlags,
+    GetID(), IsForApp(), IsForBrowser());
+
+  nsString name(aName);
+  nsAutoCString features(aFeatures);
+  nsTArray<FrameScriptInfo> frameScripts;
+  nsCString urlToLoad;
+
+  PRenderFrameChild* renderFrame = newChild->SendPRenderFrameConstructor();
+  TextureFactoryIdentifier textureFactoryIdentifier;
+  uint64_t layersId = 0;
+
+  if (aIframeMoz) {
+    MOZ_ASSERT(aTabOpener);
+    nsAutoCString url;
+    if (aURI) {
+      aURI->GetSpec(url);
+    } else {
+      // We can't actually send a nullptr up as the URI, since IPDL doesn't let us
+      // send nullptr's for primitives. We indicate that the nsString for the URI
+      // should be converted to a nullptr by voiding the string.
+      url.SetIsVoid(true);
+    }
+
+    newChild->SendBrowserFrameOpenWindow(aTabOpener, renderFrame, NS_ConvertUTF8toUTF16(url),
+                                         name, NS_ConvertUTF8toUTF16(features),
+                                         aWindowIsNew, &textureFactoryIdentifier,
+                                         &layersId);
+  } else {
+    nsAutoCString baseURIString;
+    if (aTabOpener) {
+      auto* opener = nsPIDOMWindowOuter::From(aParent);
+      nsCOMPtr<nsIDocument> doc = opener->GetDoc();
+      nsCOMPtr<nsIURI> baseURI = doc->GetDocBaseURI();
+      if (!baseURI) {
+        NS_ERROR("nsIDocument didn't return a base URI");
+        return NS_ERROR_FAILURE;
+      }
+
+      baseURI->GetSpec(baseURIString);
+    }
+
+    auto* opener = nsPIDOMWindowOuter::From(aParent);
+    nsIDocShell* openerShell;
+    RefPtr<nsDocShell> openerDocShell;
+    float fullZoom = 1.0f;
+    if (opener && (openerShell = opener->GetDocShell())) {
+      openerDocShell = static_cast<nsDocShell*>(openerShell);
+      nsCOMPtr<nsIContentViewer> cv;
+      openerDocShell->GetContentViewer(getter_AddRefs(cv));
+      if (cv) {
+        cv->GetFullZoom(&fullZoom);
+      }
+    }
+
+    nsresult rv;
+    if (!SendCreateWindow(aTabOpener, newChild, renderFrame,
+                          aChromeFlags, aCalledFromJS, aPositionSpecified,
+                          aSizeSpecified,
+                          features,
+                          baseURIString,
+                          openerDocShell
+                            ? openerDocShell->GetOriginAttributes()
+                            : DocShellOriginAttributes(),
+                          fullZoom,
+                          &rv,
+                          aWindowIsNew,
+                          &frameScripts,
+                          &urlToLoad,
+                          &textureFactoryIdentifier,
+                          &layersId)) {
+      PRenderFrameChild::Send__delete__(renderFrame);
+      return NS_ERROR_NOT_AVAILABLE;
+    }
+
+    if (NS_FAILED(rv)) {
+      PRenderFrameChild::Send__delete__(renderFrame);
+      return rv;
+    }
+  }
+  if (!*aWindowIsNew) {
+    PRenderFrameChild::Send__delete__(renderFrame);
+    return NS_ERROR_ABORT;
+  }
+
+  if (layersId == 0) { // if renderFrame is invalid.
+    PRenderFrameChild::Send__delete__(renderFrame);
+    renderFrame = nullptr;
+  }
+
+  ShowInfo showInfo(EmptyString(), false, false, true, false, 0, 0, 0);
+  auto* opener = nsPIDOMWindowOuter::From(aParent);
+  nsIDocShell* openerShell;
+  if (opener && (openerShell = opener->GetDocShell())) {
+    nsCOMPtr<nsILoadContext> context = do_QueryInterface(openerShell);
+    showInfo = ShowInfo(EmptyString(), false,
+                        context->UsePrivateBrowsing(), true, false,
+                        aTabOpener->mDPI, aTabOpener->mRounding,
+                        aTabOpener->mDefaultScale);
+  }
+
+  // Set the opener window for this window before we start loading the document
+  // inside of it. We have to do this before loading the remote scripts, because
+  // they can poke at the document and cause the nsDocument to be created before
+  // the openerwindow
+  nsCOMPtr<mozIDOMWindowProxy> windowProxy = do_GetInterface(newChild->WebNavigation());
+  if (!aForceNoOpener && windowProxy && aParent) {
+    nsPIDOMWindowOuter* outer = nsPIDOMWindowOuter::From(windowProxy);
+    nsPIDOMWindowOuter* parent = nsPIDOMWindowOuter::From(aParent);
+    outer->SetOpenerWindow(parent, *aWindowIsNew);
+  }
+
+  // Unfortunately we don't get a window unless we've shown the frame.  That's
+  // pretty bogus; see bug 763602.
+  newChild->DoFakeShow(textureFactoryIdentifier, layersId, renderFrame,
+                       showInfo);
+
+  for (size_t i = 0; i < frameScripts.Length(); i++) {
+    FrameScriptInfo& info = frameScripts[i];
+    if (!newChild->RecvLoadRemoteScript(info.url(), info.runInGlobalScope())) {
+      MOZ_CRASH();
+    }
+  }
+
+  if (!urlToLoad.IsEmpty()) {
+    newChild->RecvLoadURL(urlToLoad, showInfo);
+  }
+
+  nsCOMPtr<mozIDOMWindowProxy> win = do_GetInterface(newChild->WebNavigation());
+  win.forget(aReturn);
+  return NS_OK;
+}
+
+void
+ContentChild::GetProcessName(nsAString& aName) const
+{
+  aName.Assign(mProcessName);
+}
+
+bool
+ContentChild::IsAlive() const
+{
+  return mIsAlive;
+}
+
+bool
+ContentChild::IsShuttingDown() const
+{
+  return mShuttingDown;
+}
+
+void
+ContentChild::GetProcessName(nsACString& aName) const
+{
+  aName.Assign(NS_ConvertUTF16toUTF8(mProcessName));
+}
+
+/* static */ void
+ContentChild::AppendProcessId(nsACString& aName)
+{
+  if (!aName.IsEmpty()) {
+    aName.Append(' ');
+  }
+  unsigned pid = getpid();
+  aName.Append(nsPrintfCString("(pid %u)", pid));
+}
+
+void
+ContentChild::InitGraphicsDeviceData()
+{
+  // Initialize the graphics platform. This may contact the parent process
+  // to read device preferences.
+  gfxPlatform::GetPlatform();
+}
+
+void
+ContentChild::InitXPCOM()
+{
+  // Do this as early as possible to get the parent process to initialize the
+  // background thread since we'll likely need database information very soon.
+  BackgroundChild::Startup();
+
+  nsCOMPtr<nsIIPCBackgroundChildCreateCallback> callback =
+    new BackgroundChildPrimer();
+  if (!BackgroundChild::GetOrCreateForCurrentThread(callback)) {
+    MOZ_CRASH("Failed to create PBackgroundChild!");
+  }
+
+  BlobChild::Startup(BlobChild::FriendKey());
+
+  nsCOMPtr<nsIConsoleService> svc(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
+  if (!svc) {
+    NS_WARNING("Couldn't acquire console service");
+    return;
+  }
+
+  mConsoleListener = new ConsoleListener(this);
+  if (NS_FAILED(svc->RegisterListener(mConsoleListener)))
+    NS_WARNING("Couldn't register console listener for child process");
+
+  bool isOffline, isLangRTL, haveBidiKeyboards;
+  bool isConnected;
+  ClipboardCapabilities clipboardCaps;
+  DomainPolicyClone domainPolicy;
+  StructuredCloneData initialData;
+  OptionalURIParams userContentSheetURL;
+
+  int32_t captivePortalState;
+  SendGetXPCOMProcessAttributes(&isOffline, &isConnected, &captivePortalState,
+                                &isLangRTL, &haveBidiKeyboards,
+                                &mAvailableDictionaries,
+                                &clipboardCaps, &domainPolicy, &initialData,
+                                &userContentSheetURL);
+  RecvSetOffline(isOffline);
+  RecvSetConnectivity(isConnected);
+  RecvSetCaptivePortalState(captivePortalState);
+  RecvBidiKeyboardNotify(isLangRTL, haveBidiKeyboards);
+
+  // Create the CPOW manager as soon as possible.
+  SendPJavaScriptConstructor();
+
+  if (domainPolicy.active()) {
+    nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+    MOZ_ASSERT(ssm);
+    ssm->ActivateDomainPolicyInternal(getter_AddRefs(mPolicy));
+    if (!mPolicy) {
+      MOZ_CRASH("Failed to activate domain policy.");
+    }
+    mPolicy->ApplyClone(&domainPolicy);
+  }
+
+  nsCOMPtr<nsIClipboard> clipboard(do_GetService("@mozilla.org/widget/clipboard;1"));
+  if (nsCOMPtr<nsIClipboardProxy> clipboardProxy = do_QueryInterface(clipboard)) {
+    clipboardProxy->SetCapabilities(clipboardCaps);
+  }
+
+  {
+    AutoJSAPI jsapi;
+    if (NS_WARN_IF(!jsapi.Init(xpc::PrivilegedJunkScope()))) {
+      MOZ_CRASH();
+    }
+    ErrorResult rv;
+    JS::RootedValue data(jsapi.cx());
+    initialData.Read(jsapi.cx(), &data, rv);
+    if (NS_WARN_IF(rv.Failed())) {
+      MOZ_CRASH();
+    }
+    ProcessGlobal* global = ProcessGlobal::Get();
+    global->SetInitialProcessData(data);
+  }
+
+  // The stylesheet cache is not ready yet. Store this URL for future use.
+  nsCOMPtr<nsIURI> ucsURL = DeserializeURI(userContentSheetURL);
+  nsLayoutStylesheetCache::SetUserContentCSSURL(ucsURL);
+
+  // This will register cross-process observer.
+  mozilla::dom::time::InitializeDateCacheCleaner();
+}
+
+PMemoryReportRequestChild*
+ContentChild::AllocPMemoryReportRequestChild(const uint32_t& aGeneration,
+                                             const bool &aAnonymize,
+                                             const bool &aMinimizeMemoryUsage,
+                                             const MaybeFileDesc& aDMDFile)
+{
+  MemoryReportRequestChild *actor =
+    new MemoryReportRequestChild(aAnonymize, aDMDFile);
+  actor->AddRef();
+  return actor;
+}
+
+class HandleReportCallback final : public nsIHandleReportCallback
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  explicit HandleReportCallback(MemoryReportRequestChild* aActor,
+                                const nsACString& aProcess)
+  : mActor(aActor)
+  , mProcess(aProcess)
+  { }
+
+  NS_IMETHOD Callback(const nsACString& aProcess, const nsACString &aPath,
+                      int32_t aKind, int32_t aUnits, int64_t aAmount,
+                      const nsACString& aDescription,
+                      nsISupports* aUnused) override
+  {
+    MemoryReport memreport(mProcess, nsCString(aPath), aKind, aUnits,
+                           aAmount, nsCString(aDescription));
+    mActor->SendReport(memreport);
+    return NS_OK;
+  }
+private:
+  ~HandleReportCallback() {}
+
+  RefPtr<MemoryReportRequestChild> mActor;
+  const nsCString mProcess;
+};
+
+NS_IMPL_ISUPPORTS(
+  HandleReportCallback
+, nsIHandleReportCallback
+)
+
+class FinishReportingCallback final : public nsIFinishReportingCallback
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  explicit FinishReportingCallback(MemoryReportRequestChild* aActor)
+  : mActor(aActor)
+  {
+  }
+
+  NS_IMETHOD Callback(nsISupports* aUnused) override
+  {
+    bool sent = PMemoryReportRequestChild::Send__delete__(mActor);
+    return sent ? NS_OK : NS_ERROR_FAILURE;
+  }
+
+private:
+  ~FinishReportingCallback() {}
+
+  RefPtr<MemoryReportRequestChild> mActor;
+};
+
+NS_IMPL_ISUPPORTS(
+  FinishReportingCallback
+, nsIFinishReportingCallback
+)
+
+bool
+ContentChild::RecvPMemoryReportRequestConstructor(
+  PMemoryReportRequestChild* aChild,
+  const uint32_t& aGeneration,
+  const bool& aAnonymize,
+  const bool& aMinimizeMemoryUsage,
+  const MaybeFileDesc& aDMDFile)
+{
+  MemoryReportRequestChild *actor =
+    static_cast<MemoryReportRequestChild*>(aChild);
+  DebugOnly<nsresult> rv;
+
+  if (aMinimizeMemoryUsage) {
+    nsCOMPtr<nsIMemoryReporterManager> mgr =
+      do_GetService("@mozilla.org/memory-reporter-manager;1");
+    rv = mgr->MinimizeMemoryUsage(actor);
+    // mgr will eventually call actor->Run()
+  } else {
+    rv = actor->Run();
+  }
+
+  // Bug 1295622: don't kill the process just because this failed.
+  NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "actor operation failed");
+  return true;
+}
+
+NS_IMETHODIMP MemoryReportRequestChild::Run()
+{
+  ContentChild *child = static_cast<ContentChild*>(Manager());
+  nsCOMPtr<nsIMemoryReporterManager> mgr =
+    do_GetService("@mozilla.org/memory-reporter-manager;1");
+
+  nsCString process;
+  child->GetProcessName(process);
+  child->AppendProcessId(process);
+
+  // Run the reporters.  The callback will turn each measurement into a
+  // MemoryReport.
+  RefPtr<HandleReportCallback> handleReport =
+    new HandleReportCallback(this, process);
+  RefPtr<FinishReportingCallback> finishReporting =
+    new FinishReportingCallback(this);
+
+  nsresult rv =
+    mgr->GetReportsForThisProcessExtended(handleReport, nullptr, mAnonymize,
+                                          FileDescriptorToFILE(mDMDFile, "wb"),
+                                          finishReporting, nullptr);
+  NS_WARNING_ASSERTION(NS_SUCCEEDED(rv),
+                       "GetReportsForThisProcessExtended failed");
+  return rv;
+}
+
+bool
+ContentChild::DeallocPMemoryReportRequestChild(PMemoryReportRequestChild* actor)
+{
+  static_cast<MemoryReportRequestChild*>(actor)->Release();
+  return true;
+}
+
+PCycleCollectWithLogsChild*
+ContentChild::AllocPCycleCollectWithLogsChild(const bool& aDumpAllTraces,
+                                              const FileDescriptor& aGCLog,
+                                              const FileDescriptor& aCCLog)
+{
+  CycleCollectWithLogsChild* actor = new CycleCollectWithLogsChild(aGCLog, aCCLog);
+  // Return actor with refcount 0, which is safe because it has a non-XPCOM type.
+  return actor;
+}
+
+bool
+ContentChild::RecvPCycleCollectWithLogsConstructor(PCycleCollectWithLogsChild* aActor,
+                                                   const bool& aDumpAllTraces,
+                                                   const FileDescriptor& aGCLog,
+                                                   const FileDescriptor& aCCLog)
+{
+  // Take a reference here, where the XPCOM type is regained.
+  RefPtr<CycleCollectWithLogsChild> sink = static_cast<CycleCollectWithLogsChild*>(aActor);
+  nsCOMPtr<nsIMemoryInfoDumper> dumper = do_GetService("@mozilla.org/memory-info-dumper;1");
+
+  dumper->DumpGCAndCCLogsToSink(aDumpAllTraces, sink);
+
+  // The actor's destructor is called when the last reference goes away...
+  return true;
+}
+
+bool
+ContentChild::DeallocPCycleCollectWithLogsChild(PCycleCollectWithLogsChild* /* aActor */)
+{
+  // ...so when we get here, there's nothing for us to do.
+  //
+  // Also, we're already in ~CycleCollectWithLogsChild (q.v.) at
+  // this point, so we shouldn't touch the actor in any case.
+  return true;
+}
+
+mozilla::plugins::PPluginModuleParent*
+ContentChild::AllocPPluginModuleParent(mozilla::ipc::Transport* aTransport,
+                                       base::ProcessId aOtherProcess)
+{
+  return plugins::PluginModuleContentParent::Initialize(aTransport, aOtherProcess);
+}
+
+PContentBridgeChild*
+ContentChild::AllocPContentBridgeChild(mozilla::ipc::Transport* aTransport,
+                                       base::ProcessId aOtherProcess)
+{
+  return ContentBridgeChild::Create(aTransport, aOtherProcess);
+}
+
+PContentBridgeParent*
+ContentChild::AllocPContentBridgeParent(mozilla::ipc::Transport* aTransport,
+                                        base::ProcessId aOtherProcess)
+{
+  MOZ_ASSERT(!mLastBridge);
+  mLastBridge = static_cast<ContentBridgeParent*>(
+    ContentBridgeParent::Create(aTransport, aOtherProcess));
+  return mLastBridge;
+}
+
+PGMPServiceChild*
+ContentChild::AllocPGMPServiceChild(mozilla::ipc::Transport* aTransport,
+                                    base::ProcessId aOtherProcess)
+{
+  return GMPServiceChild::Create(aTransport, aOtherProcess);
+}
+
+bool
+ContentChild::RecvGMPsChanged(nsTArray<GMPCapabilityData>&& capabilities)
+{
+  GeckoMediaPluginServiceChild::UpdateGMPCapabilities(Move(capabilities));
+  return true;
+}
+
+bool
+ContentChild::RecvInitRendering(Endpoint<PCompositorBridgeChild>&& aCompositor,
+                                Endpoint<PImageBridgeChild>&& aImageBridge,
+                                Endpoint<PVRManagerChild>&& aVRBridge,
+                                Endpoint<PVideoDecoderManagerChild>&& aVideoManager)
+{
+  if (!CompositorBridgeChild::InitForContent(Move(aCompositor))) {
+    return false;
+  }
+  if (!ImageBridgeChild::InitForContent(Move(aImageBridge))) {
+    return false;
+  }
+  if (!gfx::VRManagerChild::InitForContent(Move(aVRBridge))) {
+    return false;
+  }
+  VideoDecoderManagerChild::InitForContent(Move(aVideoManager));
+  return true;
+}
+
+bool
+ContentChild::RecvReinitRendering(Endpoint<PCompositorBridgeChild>&& aCompositor,
+                                  Endpoint<PImageBridgeChild>&& aImageBridge,
+                                  Endpoint<PVRManagerChild>&& aVRBridge,
+                                  Endpoint<PVideoDecoderManagerChild>&& aVideoManager)
+{
+  nsTArray<RefPtr<TabChild>> tabs = TabChild::GetAll();
+
+  // Zap all the old layer managers we have lying around.
+  for (const auto& tabChild : tabs) {
+    if (tabChild->LayersId()) {
+      tabChild->InvalidateLayers();
+    }
+  }
+
+  // Re-establish singleton bridges to the compositor.
+  if (!CompositorBridgeChild::ReinitForContent(Move(aCompositor))) {
+    return false;
+  }
+  if (!ImageBridgeChild::ReinitForContent(Move(aImageBridge))) {
+    return false;
+  }
+  if (!gfx::VRManagerChild::ReinitForContent(Move(aVRBridge))) {
+    return false;
+  }
+
+  // Establish new PLayerTransactions.
+  for (const auto& tabChild : tabs) {
+    if (tabChild->LayersId()) {
+      tabChild->ReinitRendering();
+    }
+  }
+
+  VideoDecoderManagerChild::InitForContent(Move(aVideoManager));
+  return true;
+}
+
+PBackgroundChild*
+ContentChild::AllocPBackgroundChild(Transport* aTransport,
+                                    ProcessId aOtherProcess)
+{
+  return BackgroundChild::Alloc(aTransport, aOtherProcess);
+}
+
+PProcessHangMonitorChild*
+ContentChild::AllocPProcessHangMonitorChild(Transport* aTransport,
+                                            ProcessId aOtherProcess)
+{
+  return CreateHangMonitorChild(aTransport, aOtherProcess);
+}
+
+#if defined(XP_MACOSX) && defined(MOZ_CONTENT_SANDBOX)
+
+#include <stdlib.h>
+
+static bool
+GetAppPaths(nsCString &aAppPath, nsCString &aAppBinaryPath, nsCString &aAppDir)
+{
+  nsAutoCString appPath;
+  nsAutoCString appBinaryPath(
+    (CommandLine::ForCurrentProcess()->argv()[0]).c_str());
+
+  nsAutoCString::const_iterator start, end;
+  appBinaryPath.BeginReading(start);
+  appBinaryPath.EndReading(end);
+  if (RFindInReadable(NS_LITERAL_CSTRING(".app/Contents/MacOS/"), start, end)) {
+    end = start;
+    ++end; ++end; ++end; ++end;
+    appBinaryPath.BeginReading(start);
+    appPath.Assign(Substring(start, end));
+  } else {
+    return false;
+  }
+
+  nsCOMPtr<nsIFile> app, appBinary;
+  nsresult rv = NS_NewLocalFile(NS_ConvertUTF8toUTF16(appPath),
+                                true, getter_AddRefs(app));
+  if (NS_FAILED(rv)) {
+    return false;
+  }
+  rv = NS_NewLocalFile(NS_ConvertUTF8toUTF16(appBinaryPath),
+                       true, getter_AddRefs(appBinary));
+  if (NS_FAILED(rv)) {
+    return false;
+  }
+
+  nsCOMPtr<nsIFile> appDir;
+  nsCOMPtr<nsIProperties> dirSvc =
+    do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID);
+  if (!dirSvc) {
+    return false;
+  }
+  rv = dirSvc->Get(NS_XPCOM_CURRENT_PROCESS_DIR,
+                   NS_GET_IID(nsIFile), getter_AddRefs(appDir));
+  if (NS_FAILED(rv)) {
+    return false;
+  }
+  bool exists;
+  rv = appDir->Exists(&exists);
+  if (NS_FAILED(rv) || !exists) {
+    return false;
+  }
+
+  bool isLink;
+  app->IsSymlink(&isLink);
+  if (isLink) {
+    app->GetNativeTarget(aAppPath);
+  } else {
+    app->GetNativePath(aAppPath);
+  }
+  appBinary->IsSymlink(&isLink);
+  if (isLink) {
+    appBinary->GetNativeTarget(aAppBinaryPath);
+  } else {
+    appBinary->GetNativePath(aAppBinaryPath);
+  }
+  appDir->IsSymlink(&isLink);
+  if (isLink) {
+    appDir->GetNativeTarget(aAppDir);
+  } else {
+    appDir->GetNativePath(aAppDir);
+  }
+
+  return true;
+}
+
+static bool
+StartMacOSContentSandbox()
+{
+  int sandboxLevel = Preferences::GetInt("security.sandbox.content.level");
+  if (sandboxLevel < 1) {
+    return false;
+  }
+
+  nsAutoCString appPath, appBinaryPath, appDir;
+  if (!GetAppPaths(appPath, appBinaryPath, appDir)) {
+    MOZ_CRASH("Error resolving child process path");
+  }
+
+  // During sandboxed content process startup, before reaching
+  // this point, NS_OS_TEMP_DIR is modified to refer to a sandbox-
+  // writable temporary directory
+  nsCOMPtr<nsIFile> tempDir;
+  nsresult rv = nsDirectoryService::gService->Get(NS_OS_TEMP_DIR,
+      NS_GET_IID(nsIFile), getter_AddRefs(tempDir));
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to get NS_OS_TEMP_DIR");
+  }
+
+  nsAutoCString tempDirPath;
+  rv = tempDir->GetNativePath(tempDirPath);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to get NS_OS_TEMP_DIR path");
+  }
+
+  nsCOMPtr<nsIFile> profileDir;
+  ContentChild::GetSingleton()->GetProfileDir(getter_AddRefs(profileDir));
+  nsCString profileDirPath;
+  if (profileDir) {
+    rv = profileDir->GetNativePath(profileDirPath);
+    if (NS_FAILED(rv) || profileDirPath.IsEmpty()) {
+      MOZ_CRASH("Failed to get profile path");
+    }
+  }
+
+  MacSandboxInfo info;
+  info.type = MacSandboxType_Content;
+  info.level = info.level = sandboxLevel;
+  info.appPath.assign(appPath.get());
+  info.appBinaryPath.assign(appBinaryPath.get());
+  info.appDir.assign(appDir.get());
+  info.appTempDir.assign(tempDirPath.get());
+
+  if (profileDir) {
+    info.hasSandboxedProfile = true;
+    info.profileDir.assign(profileDirPath.get());
+  } else {
+    info.hasSandboxedProfile = false;
+  }
+
+  std::string err;
+  if (!mozilla::StartMacSandbox(info, err)) {
+    NS_WARNING(err.c_str());
+    MOZ_CRASH("sandbox_init() failed");
+  }
+
+  return true;
+}
+#endif
+
+bool
+ContentChild::RecvSetProcessSandbox(const MaybeFileDesc& aBroker)
+{
+  // We may want to move the sandbox initialization somewhere else
+  // at some point; see bug 880808.
+#if defined(MOZ_CONTENT_SANDBOX)
+  bool sandboxEnabled = true;
+#if defined(XP_LINUX)
+#if defined(MOZ_WIDGET_GONK) && ANDROID_VERSION >= 19
+  // For B2G >= KitKat, sandboxing is mandatory; this has already
+  // been enforced by ContentParent::StartUp().
+  MOZ_ASSERT(SandboxInfo::Get().CanSandboxContent());
+#else
+  // Otherwise, sandboxing is best-effort.
+  if (!SandboxInfo::Get().CanSandboxContent()) {
+       sandboxEnabled = false;
+   } else {
+       // This triggers the initialization of cubeb, which needs to happen
+       // before seccomp is enabled (Bug 1259508). It also increases the startup
+       // time of the content process, because cubeb is usually initialized
+       // when it is actually needed. This call here is no longer required
+       // once Bug 1104619 (remoting audio) is resolved.
+       Unused << CubebUtils::GetCubebContext();
+  }
+
+#endif /* MOZ_WIDGET_GONK && ANDROID_VERSION >= 19 */
+  if (sandboxEnabled) {
+    int brokerFd = -1;
+    if (aBroker.type() == MaybeFileDesc::TFileDescriptor) {
+      auto fd = aBroker.get_FileDescriptor().ClonePlatformHandle();
+      brokerFd = fd.release();
+      // brokerFd < 0 means to allow direct filesystem access, so
+      // make absolutely sure that doesn't happen if the parent
+      // didn't intend it.
+      MOZ_RELEASE_ASSERT(brokerFd >= 0);
+    }
+    sandboxEnabled = SetContentProcessSandbox(brokerFd);
+  }
+#elif defined(XP_WIN)
+  mozilla::SandboxTarget::Instance()->StartSandbox();
+#elif defined(XP_MACOSX)
+  sandboxEnabled = StartMacOSContentSandbox();
+#endif
+
+#if defined(MOZ_CRASHREPORTER)
+  CrashReporter::AnnotateCrashReport(
+    NS_LITERAL_CSTRING("ContentSandboxEnabled"),
+    sandboxEnabled? NS_LITERAL_CSTRING("1") : NS_LITERAL_CSTRING("0"));
+#if defined(XP_LINUX) && !defined(OS_ANDROID)
+  nsAutoCString flagsString;
+  flagsString.AppendInt(SandboxInfo::Get().AsInteger());
+
+  CrashReporter::AnnotateCrashReport(
+    NS_LITERAL_CSTRING("ContentSandboxCapabilities"), flagsString);
+#endif /* XP_LINUX && !OS_ANDROID */
+#endif /* MOZ_CRASHREPORTER */
+#endif /* MOZ_CONTENT_SANDBOX */
+
+  return true;
+}
+
+bool
+ContentChild::RecvNotifyLayerAllocated(const dom::TabId& aTabId, const uint64_t& aLayersId)
+{
+  if (!CompositorBridgeChild::Get()->IPCOpen()) {
+    return true;
+  }
+
+  APZChild* apz = ContentProcessController::Create(aTabId);
+  return CompositorBridgeChild::Get()->SendPAPZConstructor(apz, aLayersId);
+}
+
+bool
+ContentChild::RecvSpeakerManagerNotify()
+{
+#ifdef MOZ_WIDGET_GONK
+  // Only notify the process which has the SpeakerManager instance.
+  RefPtr<SpeakerManagerService> service =
+    SpeakerManagerService::GetSpeakerManagerService();
+  if (service) {
+    service->Notify();
+  }
+  return true;
+#endif
+  return false;
+}
+
+bool
+ContentChild::RecvBidiKeyboardNotify(const bool& aIsLangRTL,
+                                     const bool& aHaveBidiKeyboards)
+{
+  // bidi is always of type PuppetBidiKeyboard* (because in the child, the only
+  // possible implementation of nsIBidiKeyboard is PuppetBidiKeyboard).
+  PuppetBidiKeyboard* bidi = static_cast<PuppetBidiKeyboard*>(nsContentUtils::GetBidiKeyboard());
+  if (bidi) {
+    bidi->SetBidiKeyboardInfo(aIsLangRTL, aHaveBidiKeyboards);
+  }
+  return true;
+}
+
+static CancelableRunnable* sFirstIdleTask;
+
+static void FirstIdle(void)
+{
+  MOZ_ASSERT(sFirstIdleTask);
+  sFirstIdleTask = nullptr;
+  ContentChild::GetSingleton()->SendFirstIdle();
+}
+
+mozilla::jsipc::PJavaScriptChild *
+ContentChild::AllocPJavaScriptChild()
+{
+  MOZ_ASSERT(ManagedPJavaScriptChild().IsEmpty());
+
+  return nsIContentChild::AllocPJavaScriptChild();
+}
+
+bool
+ContentChild::DeallocPJavaScriptChild(PJavaScriptChild *aChild)
+{
+  return nsIContentChild::DeallocPJavaScriptChild(aChild);
+}
+
+PBrowserChild*
+ContentChild::AllocPBrowserChild(const TabId& aTabId,
+                                 const IPCTabContext& aContext,
+                                 const uint32_t& aChromeFlags,
+                                 const ContentParentId& aCpID,
+                                 const bool& aIsForApp,
+                                 const bool& aIsForBrowser)
+{
+  return nsIContentChild::AllocPBrowserChild(aTabId,
+                                             aContext,
+                                             aChromeFlags,
+                                             aCpID,
+                                             aIsForApp,
+                                             aIsForBrowser);
+}
+
+bool
+ContentChild::SendPBrowserConstructor(PBrowserChild* aActor,
+                                      const TabId& aTabId,
+                                      const IPCTabContext& aContext,
+                                      const uint32_t& aChromeFlags,
+                                      const ContentParentId& aCpID,
+                                      const bool& aIsForApp,
+                                      const bool& aIsForBrowser)
+{
+  if (IsShuttingDown()) {
+    return false;
+  }
+
+  return PContentChild::SendPBrowserConstructor(aActor,
+                                                aTabId,
+                                                aContext,
+                                                aChromeFlags,
+                                                aCpID,
+                                                aIsForApp,
+                                                aIsForBrowser);
+}
+
+bool
+ContentChild::RecvPBrowserConstructor(PBrowserChild* aActor,
+                                      const TabId& aTabId,
+                                      const IPCTabContext& aContext,
+                                      const uint32_t& aChromeFlags,
+                                      const ContentParentId& aCpID,
+                                      const bool& aIsForApp,
+                                      const bool& aIsForBrowser)
+{
+  MOZ_ASSERT(!IsShuttingDown());
+
+  // This runs after AllocPBrowserChild() returns and the IPC machinery for this
+  // PBrowserChild has been set up.
+
+  nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+  if (os) {
+    nsITabChild* tc =
+      static_cast<nsITabChild*>(static_cast<TabChild*>(aActor));
+    os->NotifyObservers(tc, "tab-child-created", nullptr);
+  }
+
+  static bool hasRunOnce = false;
+  if (!hasRunOnce) {
+      hasRunOnce = true;
+
+    MOZ_ASSERT(!sFirstIdleTask);
+    RefPtr<CancelableRunnable> firstIdleTask = NewCancelableRunnableFunction(FirstIdle);
+    sFirstIdleTask = firstIdleTask;
+    MessageLoop::current()->PostIdleTask(firstIdleTask.forget());
+
+    // Redo InitProcessAttributes() when the app or browser is really
+    // launching so the attributes will be correct.
+    mID = aCpID;
+    mIsForApp = aIsForApp;
+    mIsForBrowser = aIsForBrowser;
+    InitProcessAttributes();
+  }
+
+  return true;
+}
+
+void
+ContentChild::GetAvailableDictionaries(InfallibleTArray<nsString>& aDictionaries)
+{
+  aDictionaries = mAvailableDictionaries;
+}
+
+PFileDescriptorSetChild*
+ContentChild::SendPFileDescriptorSetConstructor(const FileDescriptor& aFD)
+{
+  if (IsShuttingDown()) {
+    return nullptr;
+  }
+
+  return PContentChild::SendPFileDescriptorSetConstructor(aFD);
+}
+
+PFileDescriptorSetChild*
+ContentChild::AllocPFileDescriptorSetChild(const FileDescriptor& aFD)
+{
+  return nsIContentChild::AllocPFileDescriptorSetChild(aFD);
+}
+
+bool
+ContentChild::DeallocPFileDescriptorSetChild(PFileDescriptorSetChild* aActor)
+{
+  return nsIContentChild::DeallocPFileDescriptorSetChild(aActor);
+}
+
+bool
+ContentChild::DeallocPBrowserChild(PBrowserChild* aIframe)
+{
+  return nsIContentChild::DeallocPBrowserChild(aIframe);
+}
+
+PBlobChild*
+ContentChild::AllocPBlobChild(const BlobConstructorParams& aParams)
+{
+  return nsIContentChild::AllocPBlobChild(aParams);
+}
+
+mozilla::PRemoteSpellcheckEngineChild *
+ContentChild::AllocPRemoteSpellcheckEngineChild()
+{
+  MOZ_CRASH("Default Constructor for PRemoteSpellcheckEngineChild should never be called");
+  return nullptr;
+}
+
+bool
+ContentChild::DeallocPRemoteSpellcheckEngineChild(PRemoteSpellcheckEngineChild *child)
+{
+  delete child;
+  return true;
+}
+
+bool
+ContentChild::DeallocPBlobChild(PBlobChild* aActor)
+{
+  return nsIContentChild::DeallocPBlobChild(aActor);
+}
+
+PBlobChild*
+ContentChild::SendPBlobConstructor(PBlobChild* aActor,
+                                   const BlobConstructorParams& aParams)
+{
+  if (IsShuttingDown()) {
+    return nullptr;
+  }
+
+  return PContentChild::SendPBlobConstructor(aActor, aParams);
+}
+
+PPresentationChild*
+ContentChild::AllocPPresentationChild()
+{
+  MOZ_CRASH("We should never be manually allocating PPresentationChild actors");
+  return nullptr;
+}
+
+bool
+ContentChild::DeallocPPresentationChild(PPresentationChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PFlyWebPublishedServerChild*
+ContentChild::AllocPFlyWebPublishedServerChild(const nsString& name,
+                                               const FlyWebPublishOptions& params)
+{
+  MOZ_CRASH("We should never be manually allocating PFlyWebPublishedServerChild actors");
+  return nullptr;
+}
+
+bool
+ContentChild::DeallocPFlyWebPublishedServerChild(PFlyWebPublishedServerChild* aActor)
+{
+  RefPtr<FlyWebPublishedServerChild> actor =
+    dont_AddRef(static_cast<FlyWebPublishedServerChild*>(aActor));
+  return true;
+}
+
+bool
+ContentChild::RecvNotifyPresentationReceiverLaunched(PBrowserChild* aIframe,
+                                                     const nsString& aSessionId)
+{
+  nsCOMPtr<nsIDocShell> docShell =
+    do_GetInterface(static_cast<TabChild*>(aIframe)->WebNavigation());
+  NS_WARNING_ASSERTION(docShell, "WebNavigation failed");
+
+  nsCOMPtr<nsIPresentationService> service =
+    do_GetService(PRESENTATION_SERVICE_CONTRACTID);
+  NS_WARNING_ASSERTION(service, "presentation service is missing");
+
+  Unused << NS_WARN_IF(NS_FAILED(static_cast<PresentationIPCService*>(service.get())->MonitorResponderLoading(aSessionId, docShell)));
+
+  return true;
+}
+
+bool
+ContentChild::RecvNotifyPresentationReceiverCleanUp(const nsString& aSessionId)
+{
+  nsCOMPtr<nsIPresentationService> service =
+    do_GetService(PRESENTATION_SERVICE_CONTRACTID);
+  NS_WARNING_ASSERTION(service, "presentation service is missing");
+
+  Unused << NS_WARN_IF(NS_FAILED(service->UntrackSessionInfo(aSessionId, nsIPresentationService::ROLE_RECEIVER)));
+
+  return true;
+}
+
+bool
+ContentChild::RecvNotifyEmptyHTTPCache()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+  obs->NotifyObservers(nullptr, "cacheservice:empty-cache", nullptr);
+  return true;
+}
+
+PCrashReporterChild*
+ContentChild::AllocPCrashReporterChild(const mozilla::dom::NativeThreadId& id,
+                                       const uint32_t& processType)
+{
+#ifdef MOZ_CRASHREPORTER
+    return new CrashReporterChild();
+#else
+    return nullptr;
+#endif
+}
+
+bool
+ContentChild::DeallocPCrashReporterChild(PCrashReporterChild* crashreporter)
+{
+  delete crashreporter;
+  return true;
+}
+
+PHalChild*
+ContentChild::AllocPHalChild()
+{
+  return CreateHalChild();
+}
+
+bool
+ContentChild::DeallocPHalChild(PHalChild* aHal)
+{
+  delete aHal;
+  return true;
+}
+
+devtools::PHeapSnapshotTempFileHelperChild*
+ContentChild::AllocPHeapSnapshotTempFileHelperChild()
+{
+  return devtools::HeapSnapshotTempFileHelperChild::Create();
+}
+
+bool
+ContentChild::DeallocPHeapSnapshotTempFileHelperChild(
+  devtools::PHeapSnapshotTempFileHelperChild* aHeapSnapshotHelper)
+{
+  delete aHeapSnapshotHelper;
+  return true;
+}
+
+PTestShellChild*
+ContentChild::AllocPTestShellChild()
+{
+  return new TestShellChild();
+}
+
+bool
+ContentChild::DeallocPTestShellChild(PTestShellChild* shell)
+{
+  delete shell;
+  return true;
+}
+
+jsipc::CPOWManager*
+ContentChild::GetCPOWManager()
+{
+  if (PJavaScriptChild* c = LoneManagedOrNullAsserts(ManagedPJavaScriptChild())) {
+    return CPOWManagerFor(c);
+  }
+  return CPOWManagerFor(SendPJavaScriptConstructor());
+}
+
+bool
+ContentChild::RecvPTestShellConstructor(PTestShellChild* actor)
+{
+  return true;
+}
+
+PDeviceStorageRequestChild*
+ContentChild::AllocPDeviceStorageRequestChild(const DeviceStorageParams& aParams)
+{
+  return new DeviceStorageRequestChild();
+}
+
+bool
+ContentChild::DeallocPDeviceStorageRequestChild(PDeviceStorageRequestChild* aDeviceStorage)
+{
+  delete aDeviceStorage;
+  return true;
+}
+
+PNeckoChild*
+ContentChild::AllocPNeckoChild()
+{
+  return new NeckoChild();
+}
+
+bool
+ContentChild::DeallocPNeckoChild(PNeckoChild* necko)
+{
+  delete necko;
+  return true;
+}
+
+PPrintingChild*
+ContentChild::AllocPPrintingChild()
+{
+  // The ContentParent should never attempt to allocate the nsPrintingProxy,
+  // which implements PPrintingChild. Instead, the nsPrintingProxy service is
+  // requested and instantiated via XPCOM, and the constructor of
+  // nsPrintingProxy sets up the IPC connection.
+  MOZ_CRASH("Should never get here!");
+  return nullptr;
+}
+
+bool
+ContentChild::DeallocPPrintingChild(PPrintingChild* printing)
+{
+  return true;
+}
+
+PSendStreamChild*
+ContentChild::SendPSendStreamConstructor(PSendStreamChild* aActor)
+{
+  if (IsShuttingDown()) {
+    return nullptr;
+  }
+
+  return PContentChild::SendPSendStreamConstructor(aActor);
+}
+
+PSendStreamChild*
+ContentChild::AllocPSendStreamChild()
+{
+  return nsIContentChild::AllocPSendStreamChild();
+}
+
+bool
+ContentChild::DeallocPSendStreamChild(PSendStreamChild* aActor)
+{
+  return nsIContentChild::DeallocPSendStreamChild(aActor);
+}
+
+PScreenManagerChild*
+ContentChild::AllocPScreenManagerChild(uint32_t* aNumberOfScreens,
+                                       float* aSystemDefaultScale,
+                                       bool* aSuccess)
+{
+  // The ContentParent should never attempt to allocate the
+  // nsScreenManagerProxy. Instead, the nsScreenManagerProxy
+  // service is requested and instantiated via XPCOM, and the
+  // constructor of nsScreenManagerProxy sets up the IPC connection.
+  MOZ_CRASH("Should never get here!");
+  return nullptr;
+}
+
+bool
+ContentChild::DeallocPScreenManagerChild(PScreenManagerChild* aService)
+{
+  // nsScreenManagerProxy is AddRef'd in its constructor.
+  nsScreenManagerProxy *child = static_cast<nsScreenManagerProxy*>(aService);
+  child->Release();
+  return true;
+}
+
+PPSMContentDownloaderChild*
+ContentChild::AllocPPSMContentDownloaderChild(const uint32_t& aCertType)
+{
+  // NB: We don't need aCertType in the child actor.
+  RefPtr<PSMContentDownloaderChild> child = new PSMContentDownloaderChild();
+  return child.forget().take();
+}
+
+bool
+ContentChild::DeallocPPSMContentDownloaderChild(PPSMContentDownloaderChild* aListener)
+{
+  auto* listener = static_cast<PSMContentDownloaderChild*>(aListener);
+  RefPtr<PSMContentDownloaderChild> child = dont_AddRef(listener);
+  return true;
+}
+
+PExternalHelperAppChild*
+ContentChild::AllocPExternalHelperAppChild(const OptionalURIParams& uri,
+                                           const nsCString& aMimeContentType,
+                                           const nsCString& aContentDisposition,
+                                           const uint32_t& aContentDispositionHint,
+                                           const nsString& aContentDispositionFilename,
+                                           const bool& aForceSave,
+                                           const int64_t& aContentLength,
+                                           const bool& aWasFileChannel,
+                                           const OptionalURIParams& aReferrer,
+                                           PBrowserChild* aBrowser)
+{
+  ExternalHelperAppChild *child = new ExternalHelperAppChild();
+  child->AddRef();
+  return child;
+}
+
+bool
+ContentChild::DeallocPExternalHelperAppChild(PExternalHelperAppChild* aService)
+{
+  ExternalHelperAppChild *child = static_cast<ExternalHelperAppChild*>(aService);
+  child->Release();
+  return true;
+}
+
+PHandlerServiceChild*
+ContentChild::AllocPHandlerServiceChild()
+{
+  HandlerServiceChild* actor = new HandlerServiceChild();
+  actor->AddRef();
+  return actor;
+}
+
+bool ContentChild::DeallocPHandlerServiceChild(PHandlerServiceChild* aHandlerServiceChild)
+{
+  static_cast<HandlerServiceChild*>(aHandlerServiceChild)->Release();
+  return true;
+}
+
+media::PMediaChild*
+ContentChild::AllocPMediaChild()
+{
+  return media::AllocPMediaChild();
+}
+
+bool
+ContentChild::DeallocPMediaChild(media::PMediaChild *aActor)
+{
+  return media::DeallocPMediaChild(aActor);
+}
+
+PStorageChild*
+ContentChild::AllocPStorageChild()
+{
+  MOZ_CRASH("We should never be manually allocating PStorageChild actors");
+  return nullptr;
+}
+
+bool
+ContentChild::DeallocPStorageChild(PStorageChild* aActor)
+{
+  DOMStorageDBChild* child = static_cast<DOMStorageDBChild*>(aActor);
+  child->ReleaseIPDLReference();
+  return true;
+}
+
+PSpeechSynthesisChild*
+ContentChild::AllocPSpeechSynthesisChild()
+{
+#ifdef MOZ_WEBSPEECH
+  MOZ_CRASH("No one should be allocating PSpeechSynthesisChild actors");
+#else
+  return nullptr;
+#endif
+}
+
+bool
+ContentChild::DeallocPSpeechSynthesisChild(PSpeechSynthesisChild* aActor)
+{
+#ifdef MOZ_WEBSPEECH
+  delete aActor;
+  return true;
+#else
+  return false;
+#endif
+}
+
+PWebrtcGlobalChild *
+ContentChild::AllocPWebrtcGlobalChild()
+{
+#ifdef MOZ_WEBRTC
+  WebrtcGlobalChild *child = new WebrtcGlobalChild();
+  return child;
+#else
+  return nullptr;
+#endif
+}
+
+bool
+ContentChild::DeallocPWebrtcGlobalChild(PWebrtcGlobalChild *aActor)
+{
+#ifdef MOZ_WEBRTC
+  delete static_cast<WebrtcGlobalChild*>(aActor);
+  return true;
+#else
+  return false;
+#endif
+}
+
+
+bool
+ContentChild::RecvRegisterChrome(InfallibleTArray<ChromePackage>&& packages,
+                                 InfallibleTArray<SubstitutionMapping>&& resources,
+                                 InfallibleTArray<OverrideMapping>&& overrides,
+                                 const nsCString& locale,
+                                 const bool& reset)
+{
+  nsCOMPtr<nsIChromeRegistry> registrySvc = nsChromeRegistry::GetService();
+  nsChromeRegistryContent* chromeRegistry =
+    static_cast<nsChromeRegistryContent*>(registrySvc.get());
+  chromeRegistry->RegisterRemoteChrome(packages, resources, overrides,
+                                       locale, reset);
+  return true;
+}
+
+bool
+ContentChild::RecvRegisterChromeItem(const ChromeRegistryItem& item)
+{
+  nsCOMPtr<nsIChromeRegistry> registrySvc = nsChromeRegistry::GetService();
+  nsChromeRegistryContent* chromeRegistry =
+    static_cast<nsChromeRegistryContent*>(registrySvc.get());
+  switch (item.type()) {
+    case ChromeRegistryItem::TChromePackage:
+      chromeRegistry->RegisterPackage(item.get_ChromePackage());
+      break;
+
+    case ChromeRegistryItem::TOverrideMapping:
+      chromeRegistry->RegisterOverride(item.get_OverrideMapping());
+      break;
+
+    case ChromeRegistryItem::TSubstitutionMapping:
+      chromeRegistry->RegisterSubstitution(item.get_SubstitutionMapping());
+      break;
+
+    default:
+      MOZ_ASSERT(false, "bad chrome item");
+      return false;
+  }
+
+  return true;
+}
+
+bool
+ContentChild::RecvClearImageCache(const bool& privateLoader, const bool& chrome)
+{
+  imgLoader* loader = privateLoader ? imgLoader::PrivateBrowsingLoader() :
+                                      imgLoader::NormalLoader();
+
+  loader->ClearCache(chrome);
+  return true;
+}
+
+bool
+ContentChild::RecvSetOffline(const bool& offline)
+{
+  nsCOMPtr<nsIIOService> io (do_GetIOService());
+  NS_ASSERTION(io, "IO Service can not be null");
+
+  io->SetOffline(offline);
+
+  return true;
+}
+
+bool
+ContentChild::RecvSetConnectivity(const bool& connectivity)
+{
+  nsCOMPtr<nsIIOService> io(do_GetIOService());
+  nsCOMPtr<nsIIOServiceInternal> ioInternal(do_QueryInterface(io));
+  NS_ASSERTION(ioInternal, "IO Service can not be null");
+
+  ioInternal->SetConnectivity(connectivity);
+
+  return true;
+}
+
+bool
+ContentChild::RecvSetCaptivePortalState(const int32_t& aState)
+{
+  nsCOMPtr<nsICaptivePortalService> cps = do_GetService(NS_CAPTIVEPORTAL_CID);
+  if (!cps) {
+    return true;
+  }
+
+  mozilla::net::CaptivePortalService *portal =
+    static_cast<mozilla::net::CaptivePortalService*>(cps.get());
+  portal->SetStateInChild(aState);
+
+  return true;
+}
+
+void
+ContentChild::ActorDestroy(ActorDestroyReason why)
+{
+  if (mForceKillTimer) {
+    mForceKillTimer->Cancel();
+    mForceKillTimer = nullptr;
+  }
+
+  if (AbnormalShutdown == why) {
+    NS_WARNING("shutting down early because of crash!");
+    ProcessChild::QuickExit();
+  }
+
+#ifndef NS_FREE_PERMANENT_DATA
+  // In release builds, there's no point in the content process
+  // going through the full XPCOM shutdown path, because it doesn't
+  // keep persistent state.
+  ProcessChild::QuickExit();
+#else
+  if (sFirstIdleTask) {
+    sFirstIdleTask->Cancel();
+  }
+
+  nsHostObjectProtocolHandler::RemoveDataEntries();
+
+  mAlertObservers.Clear();
+
+  mIdleObservers.Clear();
+
+  nsCOMPtr<nsIConsoleService> svc(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
+  if (svc) {
+    svc->UnregisterListener(mConsoleListener);
+    mConsoleListener->mChild = nullptr;
+  }
+  mIsAlive = false;
+
+  XRE_ShutdownChildProcess();
+#endif // NS_FREE_PERMANENT_DATA
+}
+
+void
+ContentChild::ProcessingError(Result aCode, const char* aReason)
+{
+  switch (aCode) {
+    case MsgDropped:
+      NS_WARNING("MsgDropped in ContentChild");
+      return;
+
+    case MsgNotKnown:
+    case MsgNotAllowed:
+    case MsgPayloadError:
+    case MsgProcessingError:
+    case MsgRouteError:
+    case MsgValueError:
+      break;
+
+    default:
+      NS_RUNTIMEABORT("not reached");
+  }
+
+#if defined(MOZ_CRASHREPORTER) && !defined(MOZ_B2G)
+  if (PCrashReporterChild* c = LoneManagedOrNullAsserts(ManagedPCrashReporterChild())) {
+    CrashReporterChild* crashReporter =
+      static_cast<CrashReporterChild*>(c);
+    nsDependentCString reason(aReason);
+    crashReporter->SendAnnotateCrashReport(
+        NS_LITERAL_CSTRING("ipc_channel_error"),
+        reason);
+  }
+#endif
+  NS_RUNTIMEABORT("Content child abort due to IPC error");
+}
+
+nsresult
+ContentChild::AddRemoteAlertObserver(const nsString& aData,
+                                     nsIObserver* aObserver)
+{
+  NS_ASSERTION(aObserver, "Adding a null observer?");
+  mAlertObservers.AppendElement(new AlertObserver(aObserver, aData));
+  return NS_OK;
+}
+
+bool
+ContentChild::RecvPreferenceUpdate(const PrefSetting& aPref)
+{
+  Preferences::SetPreference(aPref);
+  return true;
+}
+
+bool
+ContentChild::RecvVarUpdate(const GfxVarUpdate& aVar)
+{
+  gfx::gfxVars::ApplyUpdate(aVar);
+  return true;
+}
+
+bool
+ContentChild::RecvDataStoragePut(const nsString& aFilename,
+                                 const DataStorageItem& aItem)
+{
+  RefPtr<DataStorage> storage = DataStorage::GetIfExists(aFilename);
+  if (storage) {
+    storage->Put(aItem.key(), aItem.value(), aItem.type());
+  }
+  return true;
+}
+
+bool
+ContentChild::RecvDataStorageRemove(const nsString& aFilename,
+                                    const nsCString& aKey,
+                                    const DataStorageType& aType)
+{
+  RefPtr<DataStorage> storage = DataStorage::GetIfExists(aFilename);
+  if (storage) {
+    storage->Remove(aKey, aType);
+  }
+  return true;
+}
+
+bool
+ContentChild::RecvDataStorageClear(const nsString& aFilename)
+{
+  RefPtr<DataStorage> storage = DataStorage::GetIfExists(aFilename);
+  if (storage) {
+    storage->Clear();
+  }
+  return true;
+}
+
+bool
+ContentChild::RecvNotifyAlertsObserver(const nsCString& aType, const nsString& aData)
+{
+  for (uint32_t i = 0; i < mAlertObservers.Length();
+     /*we mutate the array during the loop; ++i iff no mutation*/) {
+    AlertObserver* observer = mAlertObservers[i];
+    if (observer->Observes(aData) && observer->Notify(aType)) {
+      // if aType == alertfinished, this alert is done.  we can
+      // remove the observer.
+      if (aType.Equals(nsDependentCString("alertfinished"))) {
+        mAlertObservers.RemoveElementAt(i);
+        continue;
+      }
+    }
+    ++i;
+  }
+  return true;
+}
+
+bool
+ContentChild::RecvNotifyVisited(const URIParams& aURI)
+{
+  nsCOMPtr<nsIURI> newURI = DeserializeURI(aURI);
+  if (!newURI) {
+    return false;
+  }
+  nsCOMPtr<IHistory> history = services::GetHistoryService();
+  if (history) {
+    history->NotifyVisited(newURI);
+  }
+  return true;
+}
+
+bool
+ContentChild::RecvLoadProcessScript(const nsString& aURL)
+{
+  ProcessGlobal* global = ProcessGlobal::Get();
+  global->LoadScript(aURL);
+  return true;
+}
+
+bool
+ContentChild::RecvAsyncMessage(const nsString& aMsg,
+                               InfallibleTArray<CpowEntry>&& aCpows,
+                               const IPC::Principal& aPrincipal,
+                               const ClonedMessageData& aData)
+{
+  RefPtr<nsFrameMessageManager> cpm =
+    nsFrameMessageManager::GetChildProcessManager();
+  if (cpm) {
+    StructuredCloneData data;
+    ipc::UnpackClonedMessageDataForChild(aData, data);
+    CrossProcessCpowHolder cpows(this, aCpows);
+    cpm->ReceiveMessage(static_cast<nsIContentFrameMessageManager*>(cpm.get()),
+                        nullptr, aMsg, false, &data, &cpows, aPrincipal,
+                        nullptr);
+  }
+  return true;
+}
+
+bool
+ContentChild::RecvGeolocationUpdate(const GeoPosition& somewhere)
+{
+  nsCOMPtr<nsIGeolocationUpdate> gs =
+    do_GetService("@mozilla.org/geolocation/service;1");
+  if (!gs) {
+    return true;
+  }
+  nsCOMPtr<nsIDOMGeoPosition> position = somewhere;
+  gs->Update(position);
+  return true;
+}
+
+bool
+ContentChild::RecvGeolocationError(const uint16_t& errorCode)
+{
+  nsCOMPtr<nsIGeolocationUpdate> gs =
+    do_GetService("@mozilla.org/geolocation/service;1");
+  if (!gs) {
+    return true;
+  }
+  gs->NotifyError(errorCode);
+  return true;
+}
+
+bool
+ContentChild::RecvUpdateDictionaryList(InfallibleTArray<nsString>&& aDictionaries)
+{
+  mAvailableDictionaries = aDictionaries;
+  mozInlineSpellChecker::UpdateCanEnableInlineSpellChecking();
+  return true;
+}
+
+bool
+ContentChild::RecvAddPermission(const IPC::Permission& permission)
+{
+#if MOZ_PERMISSIONS
+  nsCOMPtr<nsIPermissionManager> permissionManagerIface =
+    services::GetPermissionManager();
+  nsPermissionManager* permissionManager =
+    static_cast<nsPermissionManager*>(permissionManagerIface.get());
+  MOZ_ASSERT(permissionManager,
+         "We have no permissionManager in the Content process !");
+
+  // note we do not need to force mUserContextId to the default here because
+  // the permission manager does that internally.
+  nsAutoCString originNoSuffix;
+  PrincipalOriginAttributes attrs;
+  bool success = attrs.PopulateFromOrigin(permission.origin, originNoSuffix);
+  NS_ENSURE_TRUE(success, false);
+
+  nsCOMPtr<nsIURI> uri;
+  nsresult rv = NS_NewURI(getter_AddRefs(uri), originNoSuffix);
+  NS_ENSURE_SUCCESS(rv, true);
+
+  nsCOMPtr<nsIPrincipal> principal = mozilla::BasePrincipal::CreateCodebasePrincipal(uri, attrs);
+
+  // child processes don't care about modification time.
+  int64_t modificationTime = 0;
+
+  permissionManager->AddInternal(principal,
+                                 nsCString(permission.type),
+                                 permission.capability,
+                                 0,
+                                 permission.expireType,
+                                 permission.expireTime,
+                                 modificationTime,
+                                 nsPermissionManager::eNotify,
+                                 nsPermissionManager::eNoDBOperation);
+#endif
+
+  return true;
+}
+
+bool
+ContentChild::RecvFlushMemory(const nsString& reason)
+{
+  nsCOMPtr<nsIObserverService> os =
+    mozilla::services::GetObserverService();
+  if (os) {
+    os->NotifyObservers(nullptr, "memory-pressure", reason.get());
+  }
+  return true;
+}
+
+bool
+ContentChild::RecvActivateA11y(const uint32_t& aMsaaID)
+{
+#ifdef ACCESSIBILITY
+#ifdef XP_WIN
+  MOZ_ASSERT(aMsaaID != 0);
+  mMsaaID = aMsaaID;
+#endif // XP_WIN
+
+  // Start accessibility in content process if it's running in chrome
+  // process.
+  GetOrCreateAccService(nsAccessibilityService::eMainProcess);
+#endif // ACCESSIBILITY
+  return true;
+}
+
+bool
+ContentChild::RecvShutdownA11y()
+{
+#ifdef ACCESSIBILITY
+  // Try to shutdown accessibility in content process if it's shutting down in
+  // chrome process.
+  MaybeShutdownAccService(nsAccessibilityService::eMainProcess);
+#endif
+  return true;
+}
+
+bool
+ContentChild::RecvGarbageCollect()
+{
+  // Rebroadcast the "child-gc-request" so that workers will GC.
+  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+  if (obs) {
+    obs->NotifyObservers(nullptr, "child-gc-request", nullptr);
+  }
+  nsJSContext::GarbageCollectNow(JS::gcreason::DOM_IPC);
+  return true;
+}
+
+bool
+ContentChild::RecvCycleCollect()
+{
+  // Rebroadcast the "child-cc-request" so that workers will CC.
+  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+  if (obs) {
+    obs->NotifyObservers(nullptr, "child-cc-request", nullptr);
+  }
+  nsJSContext::CycleCollectNow();
+  return true;
+}
+
+static void
+PreloadSlowThings()
+{
+  // This fetches and creates all the built-in stylesheets.
+  //
+  // XXXheycam In the future we might want to preload the Servo-flavoured
+  // UA sheets too, but for now that will be a waste of time.
+  nsLayoutStylesheetCache::For(StyleBackendType::Gecko)->UserContentSheet();
+
+  TabChild::PreloadSlowThings();
+
+}
+
+bool
+ContentChild::RecvAppInfo(const nsCString& version, const nsCString& buildID,
+                          const nsCString& name, const nsCString& UAName,
+                          const nsCString& ID, const nsCString& vendor)
+{
+  mAppInfo.version.Assign(version);
+  mAppInfo.buildID.Assign(buildID);
+  mAppInfo.name.Assign(name);
+  mAppInfo.UAName.Assign(UAName);
+  mAppInfo.ID.Assign(ID);
+  mAppInfo.vendor.Assign(vendor);
+
+  return true;
+}
+
+bool
+ContentChild::RecvAppInit()
+{
+  if (!Preferences::GetBool("dom.ipc.processPrelaunch.enabled", false)) {
+    return true;
+  }
+
+  // If we're part of the mozbrowser machinery, go ahead and start
+  // preloading things.  We can only do this for mozbrowser because
+  // PreloadSlowThings() may set the docshell of the first TabChild
+  // inactive, and we can only safely restore it to active from
+  // BrowserElementChild.js.
+  if (mIsForApp || mIsForBrowser) {
+    PreloadSlowThings();
+  }
+
+  return true;
+}
+
+bool
+ContentChild::RecvInitServiceWorkers(const ServiceWorkerConfiguration& aConfig)
+{
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  if (!swm) {
+    // browser shutdown began
+    return true;
+  }
+  swm->LoadRegistrations(aConfig.serviceWorkerRegistrations());
+  return true;
+}
+
+bool
+ContentChild::RecvInitBlobURLs(nsTArray<BlobURLRegistrationData>&& aRegistrations)
+{
+  for (uint32_t i = 0; i < aRegistrations.Length(); ++i) {
+    BlobURLRegistrationData& registration = aRegistrations[i];
+    RefPtr<BlobImpl> blobImpl =
+      static_cast<BlobChild*>(registration.blobChild())->GetBlobImpl();
+    MOZ_ASSERT(blobImpl);
+
+    nsHostObjectProtocolHandler::AddDataEntry(registration.url(),
+                                              registration.principal(),
+                                              blobImpl);
+  }
+
+  return true;
+}
+
+bool
+ContentChild::RecvLastPrivateDocShellDestroyed()
+{
+  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+  obs->NotifyObservers(nullptr, "last-pb-context-exited", nullptr);
+  return true;
+}
+
+bool
+ContentChild::RecvVolumes(nsTArray<VolumeInfo>&& aVolumes)
+{
+#ifdef MOZ_WIDGET_GONK
+  RefPtr<nsVolumeService> vs = nsVolumeService::GetSingleton();
+  if (vs) {
+    vs->RecvVolumesFromParent(aVolumes);
+  }
+#endif
+  return true;
+}
+
+bool
+ContentChild::RecvFilePathUpdate(const nsString& aStorageType,
+                                 const nsString& aStorageName,
+                                 const nsString& aPath,
+                                 const nsCString& aReason)
+{
+  if (nsDOMDeviceStorage::InstanceCount() == 0) {
+    // No device storage instances in this process. Don't try and
+    // and create a DeviceStorageFile since it will fail.
+
+    return true;
+  }
+
+  RefPtr<DeviceStorageFile> dsf = new DeviceStorageFile(aStorageType, aStorageName, aPath);
+
+  nsString reason;
+  CopyASCIItoUTF16(aReason, reason);
+  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+  obs->NotifyObservers(dsf, "file-watcher-update", reason.get());
+  return true;
+}
+
+bool
+ContentChild::RecvFileSystemUpdate(const nsString& aFsName,
+                                   const nsString& aVolumeName,
+                                   const int32_t& aState,
+                                   const int32_t& aMountGeneration,
+                                   const bool& aIsMediaPresent,
+                                   const bool& aIsSharing,
+                                   const bool& aIsFormatting,
+                                   const bool& aIsFake,
+                                   const bool& aIsUnmounting,
+                                   const bool& aIsRemovable,
+                                   const bool& aIsHotSwappable)
+{
+#ifdef MOZ_WIDGET_GONK
+  RefPtr<nsVolume> volume = new nsVolume(aFsName, aVolumeName, aState,
+                                         aMountGeneration, aIsMediaPresent,
+                                         aIsSharing, aIsFormatting, aIsFake,
+                                         aIsUnmounting, aIsRemovable, aIsHotSwappable);
+
+  RefPtr<nsVolumeService> vs = nsVolumeService::GetSingleton();
+  if (vs) {
+    vs->UpdateVolume(volume);
+  }
+#else
+  // Remove warnings about unused arguments
+  Unused << aFsName;
+  Unused << aVolumeName;
+  Unused << aState;
+  Unused << aMountGeneration;
+  Unused << aIsMediaPresent;
+  Unused << aIsSharing;
+  Unused << aIsFormatting;
+  Unused << aIsFake;
+  Unused << aIsUnmounting;
+  Unused << aIsRemovable;
+  Unused << aIsHotSwappable;
+#endif
+  return true;
+}
+
+bool
+ContentChild::RecvVolumeRemoved(const nsString& aFsName)
+{
+#ifdef MOZ_WIDGET_GONK
+  RefPtr<nsVolumeService> vs = nsVolumeService::GetSingleton();
+  if (vs) {
+    vs->RemoveVolumeByName(aFsName);
+  }
+#else
+  // Remove warnings about unused arguments
+  Unused << aFsName;
+#endif
+  return true;
+}
+
+bool
+ContentChild::RecvNotifyProcessPriorityChanged(
+  const hal::ProcessPriority& aPriority)
+{
+  nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+  NS_ENSURE_TRUE(os, true);
+
+  RefPtr<nsHashPropertyBag> props = new nsHashPropertyBag();
+  props->SetPropertyAsInt32(NS_LITERAL_STRING("priority"),
+                            static_cast<int32_t>(aPriority));
+
+  os->NotifyObservers(static_cast<nsIPropertyBag2*>(props),
+                      "ipc:process-priority-changed",  nullptr);
+  return true;
+}
+
+bool
+ContentChild::RecvMinimizeMemoryUsage()
+{
+  nsCOMPtr<nsIMemoryReporterManager> mgr =
+    do_GetService("@mozilla.org/memory-reporter-manager;1");
+  NS_ENSURE_TRUE(mgr, true);
+
+  Unused << mgr->MinimizeMemoryUsage(/* callback = */ nullptr);
+  return true;
+}
+
+bool
+ContentChild::RecvNotifyPhoneStateChange(const nsString& aState)
+{
+  nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+  if (os) {
+    os->NotifyObservers(nullptr, "phone-state-changed", aState.get());
+  }
+  return true;
+}
+
+void
+ContentChild::AddIdleObserver(nsIObserver* aObserver, uint32_t aIdleTimeInS)
+{
+  MOZ_ASSERT(aObserver, "null idle observer");
+  // Make sure aObserver isn't released while we wait for the parent
+  aObserver->AddRef();
+  SendAddIdleObserver(reinterpret_cast<uint64_t>(aObserver), aIdleTimeInS);
+  mIdleObservers.PutEntry(aObserver);
+}
+
+void
+ContentChild::RemoveIdleObserver(nsIObserver* aObserver, uint32_t aIdleTimeInS)
+{
+  MOZ_ASSERT(aObserver, "null idle observer");
+  SendRemoveIdleObserver(reinterpret_cast<uint64_t>(aObserver), aIdleTimeInS);
+  aObserver->Release();
+  mIdleObservers.RemoveEntry(aObserver);
+}
+
+bool
+ContentChild::RecvNotifyIdleObserver(const uint64_t& aObserver,
+                                     const nsCString& aTopic,
+                                     const nsString& aTimeStr)
+{
+  nsIObserver* observer = reinterpret_cast<nsIObserver*>(aObserver);
+  if (mIdleObservers.Contains(observer)) {
+    observer->Observe(nullptr, aTopic.get(), aTimeStr.get());
+  } else {
+    NS_WARNING("Received notification for an idle observer that was removed.");
+  }
+  return true;
+}
+
+bool
+ContentChild::RecvLoadAndRegisterSheet(const URIParams& aURI, const uint32_t& aType)
+{
+  nsCOMPtr<nsIURI> uri = DeserializeURI(aURI);
+  if (!uri) {
+    return true;
+  }
+
+  nsStyleSheetService *sheetService = nsStyleSheetService::GetInstance();
+  if (sheetService) {
+    sheetService->LoadAndRegisterSheet(uri, aType);
+  }
+
+  return true;
+}
+
+bool
+ContentChild::RecvUnregisterSheet(const URIParams& aURI, const uint32_t& aType)
+{
+  nsCOMPtr<nsIURI> uri = DeserializeURI(aURI);
+  if (!uri) {
+    return true;
+  }
+
+  nsStyleSheetService *sheetService = nsStyleSheetService::GetInstance();
+  if (sheetService) {
+    sheetService->UnregisterSheet(uri, aType);
+  }
+
+  return true;
+}
+
+POfflineCacheUpdateChild*
+ContentChild::AllocPOfflineCacheUpdateChild(const URIParams& manifestURI,
+                                            const URIParams& documentURI,
+                                            const PrincipalInfo& aLoadingPrincipalInfo,
+                                            const bool& stickDocument)
+{
+  NS_RUNTIMEABORT("unused");
+  return nullptr;
+}
+
+bool
+ContentChild::DeallocPOfflineCacheUpdateChild(POfflineCacheUpdateChild* actor)
+{
+  OfflineCacheUpdateChild* offlineCacheUpdate =
+    static_cast<OfflineCacheUpdateChild*>(actor);
+  NS_RELEASE(offlineCacheUpdate);
+  return true;
+}
+
+bool
+ContentChild::RecvStartProfiler(const ProfilerInitParams& params)
+{
+  nsTArray<const char*> featureArray;
+  for (size_t i = 0; i < params.features().Length(); ++i) {
+    featureArray.AppendElement(params.features()[i].get());
+  }
+
+  nsTArray<const char*> threadNameFilterArray;
+  for (size_t i = 0; i < params.threadFilters().Length(); ++i) {
+    threadNameFilterArray.AppendElement(params.threadFilters()[i].get());
+  }
+
+  profiler_start(params.entries(), params.interval(),
+                 featureArray.Elements(), featureArray.Length(),
+                 threadNameFilterArray.Elements(),
+                 threadNameFilterArray.Length());
+
+ return true;
+}
+
+bool
+ContentChild::RecvStopProfiler()
+{
+  profiler_stop();
+  return true;
+}
+
+bool
+ContentChild::RecvPauseProfiler(const bool& aPause)
+{
+  if (aPause) {
+    profiler_pause();
+  } else {
+    profiler_resume();
+  }
+
+  return true;
+}
+
+bool
+ContentChild::RecvGatherProfile()
+{
+  nsCString profileCString;
+  UniquePtr<char[]> profile = profiler_get_profile();
+  if (profile) {
+    profileCString = nsCString(profile.get(), strlen(profile.get()));
+  } else {
+    profileCString = EmptyCString();
+  }
+
+  Unused << SendProfile(profileCString);
+  return true;
+}
+
+bool
+ContentChild::RecvLoadPluginResult(const uint32_t& aPluginId,
+                                   const bool& aResult)
+{
+  nsresult rv;
+  bool finalResult = aResult && SendConnectPluginBridge(aPluginId, &rv) &&
+                     NS_SUCCEEDED(rv);
+  plugins::PluginModuleContentParent::OnLoadPluginResult(aPluginId,
+                                                         finalResult);
+  return true;
+}
+
+bool
+ContentChild::RecvAssociatePluginId(const uint32_t& aPluginId,
+                                    const base::ProcessId& aProcessId)
+{
+  plugins::PluginModuleContentParent::AssociatePluginId(aPluginId, aProcessId);
+  return true;
+}
+
+bool
+ContentChild::RecvDomainSetChanged(const uint32_t& aSetType,
+                                   const uint32_t& aChangeType,
+                                   const OptionalURIParams& aDomain)
+{
+  if (aChangeType == ACTIVATE_POLICY) {
+    if (mPolicy) {
+      return true;
+    }
+    nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+    MOZ_ASSERT(ssm);
+    ssm->ActivateDomainPolicyInternal(getter_AddRefs(mPolicy));
+    return !!mPolicy;
+  } else if (!mPolicy) {
+    MOZ_ASSERT_UNREACHABLE("If the domain policy is not active yet,"
+                           " the first message should be ACTIVATE_POLICY");
+    return false;
+  }
+
+  NS_ENSURE_TRUE(mPolicy, false);
+
+  if (aChangeType == DEACTIVATE_POLICY) {
+    mPolicy->Deactivate();
+    mPolicy = nullptr;
+    return true;
+  }
+
+  nsCOMPtr<nsIDomainSet> set;
+  switch(aSetType) {
+    case BLACKLIST:
+      mPolicy->GetBlacklist(getter_AddRefs(set));
+      break;
+    case SUPER_BLACKLIST:
+      mPolicy->GetSuperBlacklist(getter_AddRefs(set));
+      break;
+    case WHITELIST:
+      mPolicy->GetWhitelist(getter_AddRefs(set));
+      break;
+    case SUPER_WHITELIST:
+      mPolicy->GetSuperWhitelist(getter_AddRefs(set));
+      break;
+    default:
+      NS_NOTREACHED("Unexpected setType");
+      return false;
+  }
+
+  MOZ_ASSERT(set);
+
+  nsCOMPtr<nsIURI> uri = DeserializeURI(aDomain);
+
+  switch(aChangeType) {
+    case ADD_DOMAIN:
+      NS_ENSURE_TRUE(uri, false);
+      set->Add(uri);
+      break;
+    case REMOVE_DOMAIN:
+      NS_ENSURE_TRUE(uri, false);
+      set->Remove(uri);
+      break;
+    case CLEAR_DOMAINS:
+      set->Clear();
+      break;
+    default:
+      NS_NOTREACHED("Unexpected changeType");
+      return false;
+  }
+
+  return true;
+}
+
+void
+ContentChild::StartForceKillTimer()
+{
+  if (mForceKillTimer) {
+    return;
+  }
+
+  int32_t timeoutSecs = Preferences::GetInt("dom.ipc.tabs.shutdownTimeoutSecs", 5);
+  if (timeoutSecs > 0) {
+    mForceKillTimer = do_CreateInstance("@mozilla.org/timer;1");
+    MOZ_ASSERT(mForceKillTimer);
+    mForceKillTimer->InitWithFuncCallback(ContentChild::ForceKillTimerCallback,
+      this,
+      timeoutSecs * 1000,
+      nsITimer::TYPE_ONE_SHOT);
+  }
+}
+
+/* static */ void
+ContentChild::ForceKillTimerCallback(nsITimer* aTimer, void* aClosure)
+{
+  ProcessChild::QuickExit();
+}
+
+bool
+ContentChild::RecvShutdown()
+{
+  // If we receive the shutdown message from within a nested event loop, we want
+  // to wait for that event loop to finish. Otherwise we could prematurely
+  // terminate an "unload" or "pagehide" event handler (which might be doing a
+  // sync XHR, for example).
+#if defined(MOZ_CRASHREPORTER)
+  CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("IPCShutdownState"),
+                                     NS_LITERAL_CSTRING("RecvShutdown"));
+#endif
+  nsCOMPtr<nsIThread> thread;
+  nsresult rv = NS_GetMainThread(getter_AddRefs(thread));
+  if (NS_SUCCEEDED(rv) && thread) {
+    RefPtr<nsThread> mainThread(thread.forget().downcast<nsThread>());
+    if (mainThread->RecursionDepth() > 1) {
+      // We're in a nested event loop. Let's delay for an arbitrary period of
+      // time (100ms) in the hopes that the event loop will have finished by
+      // then.
+      MessageLoop::current()->PostDelayedTask(
+        NewRunnableMethod(this, &ContentChild::RecvShutdown), 100);
+      return true;
+    }
+  }
+
+  mShuttingDown = true;
+
+  if (mPolicy) {
+    mPolicy->Deactivate();
+    mPolicy = nullptr;
+  }
+
+  nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+  if (os) {
+    os->NotifyObservers(static_cast<nsIContentChild*>(this),
+                          "content-child-shutdown", nullptr);
+  }
+
+#if defined(XP_WIN)
+    mozilla::widget::StopAudioSession();
+#endif
+
+  GetIPCChannel()->SetAbortOnError(false);
+
+#ifdef MOZ_ENABLE_PROFILER_SPS
+  if (profiler_is_active()) {
+    // We're shutting down while we were profiling. Send the
+    // profile up to the parent so that we don't lose this
+    // information.
+    Unused << RecvGatherProfile();
+  }
+#endif
+
+  // Start a timer that will insure we quickly exit after a reasonable
+  // period of time. Prevents shutdown hangs after our connection to the
+  // parent closes.
+  StartForceKillTimer();
+
+#if defined(MOZ_CRASHREPORTER)
+  CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("IPCShutdownState"),
+                                     NS_LITERAL_CSTRING("SendFinishShutdown"));
+#endif
+  // Ignore errors here. If this fails, the parent will kill us after a
+  // timeout.
+  Unused << SendFinishShutdown();
+  return true;
+}
+
+PBrowserOrId
+ContentChild::GetBrowserOrId(TabChild* aTabChild)
+{
+  if (!aTabChild ||
+    this == aTabChild->Manager()) {
+    return PBrowserOrId(aTabChild);
+  }
+  else {
+    return PBrowserOrId(aTabChild->GetTabId());
+  }
+}
+
+bool
+ContentChild::RecvUpdateWindow(const uintptr_t& aChildId)
+{
+#if defined(XP_WIN)
+  NS_ASSERTION(aChildId, "Expected child hwnd value for remote plugin instance.");
+  mozilla::plugins::PluginInstanceParent* parentInstance =
+  mozilla::plugins::PluginInstanceParent::LookupPluginInstanceByID(aChildId);
+  if (parentInstance) {
+  // sync! update call to the plugin instance that forces the
+  // plugin to paint its child window.
+  parentInstance->CallUpdateWindow();
+  }
+  return true;
+#else
+  MOZ_ASSERT(false, "ContentChild::RecvUpdateWindow calls unexpected on this platform.");
+  return false;
+#endif
+}
+
+PContentPermissionRequestChild*
+ContentChild::AllocPContentPermissionRequestChild(const InfallibleTArray<PermissionRequest>& aRequests,
+                                                  const IPC::Principal& aPrincipal,
+                                                  const TabId& aTabId)
+{
+  NS_RUNTIMEABORT("unused");
+  return nullptr;
+}
+
+bool
+ContentChild::DeallocPContentPermissionRequestChild(PContentPermissionRequestChild* actor)
+{
+  nsContentPermissionUtils::NotifyRemoveContentPermissionRequestChild(actor);
+  auto child = static_cast<RemotePermissionRequest*>(actor);
+  child->IPDLRelease();
+  return true;
+}
+
+PWebBrowserPersistDocumentChild*
+ContentChild::AllocPWebBrowserPersistDocumentChild(PBrowserChild* aBrowser,
+                                                   const uint64_t& aOuterWindowID)
+{
+  return new WebBrowserPersistDocumentChild();
+}
+
+bool
+ContentChild::RecvPWebBrowserPersistDocumentConstructor(PWebBrowserPersistDocumentChild *aActor,
+                                                        PBrowserChild* aBrowser,
+                                                        const uint64_t& aOuterWindowID)
+{
+  if (NS_WARN_IF(!aBrowser)) {
+    return false;
+  }
+  nsCOMPtr<nsIDocument> rootDoc =
+    static_cast<TabChild*>(aBrowser)->GetDocument();
+  nsCOMPtr<nsIDocument> foundDoc;
+  if (aOuterWindowID) {
+    foundDoc = nsContentUtils::GetSubdocumentWithOuterWindowId(rootDoc, aOuterWindowID);
+  } else {
+    foundDoc = rootDoc;
+  }
+
+  if (!foundDoc) {
+    aActor->SendInitFailure(NS_ERROR_NO_CONTENT);
+  } else {
+    static_cast<WebBrowserPersistDocumentChild*>(aActor)->Start(foundDoc);
+  }
+  return true;
+}
+
+bool
+ContentChild::DeallocPWebBrowserPersistDocumentChild(PWebBrowserPersistDocumentChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+bool
+ContentChild::RecvSetAudioSessionData(const nsID& aId,
+                                      const nsString& aDisplayName,
+                                      const nsString& aIconPath)
+{
+#if defined(XP_WIN)
+    if (NS_FAILED(mozilla::widget::RecvAudioSessionData(aId, aDisplayName,
+                                                        aIconPath))) {
+      return true;
+    }
+
+    // Ignore failures here; we can't really do anything about them
+    mozilla::widget::StartAudioSession();
+    return true;
+#else
+    NS_RUNTIMEABORT("Not Reached!");
+    return false;
+#endif
+}
+
+// This code goes here rather than nsGlobalWindow.cpp because nsGlobalWindow.cpp
+// can't include ContentChild.h since it includes windows.h.
+
+static uint64_t gNextWindowID = 0;
+
+// We use only 53 bits for the window ID so that it can be converted to and from
+// a JS value without loss of precision. The upper bits of the window ID hold the
+// process ID. The lower bits identify the window.
+static const uint64_t kWindowIDTotalBits = 53;
+static const uint64_t kWindowIDProcessBits = 22;
+static const uint64_t kWindowIDWindowBits = kWindowIDTotalBits - kWindowIDProcessBits;
+
+// Try to return a window ID that is unique across processes and that will never
+// be recycled.
+uint64_t
+NextWindowID()
+{
+  uint64_t processID = 0;
+  if (XRE_IsContentProcess()) {
+    ContentChild* cc = ContentChild::GetSingleton();
+    processID = cc->GetID();
+  }
+
+  MOZ_RELEASE_ASSERT(processID < (uint64_t(1) << kWindowIDProcessBits));
+  uint64_t processBits = processID & ((uint64_t(1) << kWindowIDProcessBits) - 1);
+
+  // Make sure no actual window ends up with mWindowID == 0.
+  uint64_t windowID = ++gNextWindowID;
+
+  MOZ_RELEASE_ASSERT(windowID < (uint64_t(1) << kWindowIDWindowBits));
+  uint64_t windowBits = windowID & ((uint64_t(1) << kWindowIDWindowBits) - 1);
+
+  return (processBits << kWindowIDWindowBits) | windowBits;
+}
+
+bool
+ContentChild::RecvInvokeDragSession(nsTArray<IPCDataTransfer>&& aTransfers,
+                                    const uint32_t& aAction)
+{
+  nsCOMPtr<nsIDragService> dragService =
+    do_GetService("@mozilla.org/widget/dragservice;1");
+  if (dragService) {
+    dragService->StartDragSession();
+    nsCOMPtr<nsIDragSession> session;
+    dragService->GetCurrentSession(getter_AddRefs(session));
+    if (session) {
+      session->SetDragAction(aAction);
+      // Check if we are receiving any file objects. If we are we will want
+      // to hide any of the other objects coming in from content.
+      bool hasFiles = false;
+      for (uint32_t i = 0; i < aTransfers.Length() && !hasFiles; ++i) {
+        auto& items = aTransfers[i].items();
+        for (uint32_t j = 0; j < items.Length() && !hasFiles; ++j) {
+          if (items[j].data().type() == IPCDataTransferData::TPBlobChild) {
+            hasFiles = true;
+          }
+        }
+      }
+
+      // Add the entries from the IPC to the new DataTransfer
+      nsCOMPtr<DataTransfer> dataTransfer =
+        new DataTransfer(nullptr, eDragStart, false, -1);
+      for (uint32_t i = 0; i < aTransfers.Length(); ++i) {
+        auto& items = aTransfers[i].items();
+        for (uint32_t j = 0; j < items.Length(); ++j) {
+          const IPCDataTransferItem& item = items[j];
+          RefPtr<nsVariantCC> variant = new nsVariantCC();
+          if (item.data().type() == IPCDataTransferData::TnsString) {
+            const nsString& data = item.data().get_nsString();
+            variant->SetAsAString(data);
+          } else if (item.data().type() == IPCDataTransferData::TShmem) {
+            Shmem data = item.data().get_Shmem();
+            variant->SetAsACString(nsDependentCString(data.get<char>(), data.Size<char>()));
+            Unused << DeallocShmem(data);
+          } else if (item.data().type() == IPCDataTransferData::TPBlobChild) {
+            BlobChild* blob = static_cast<BlobChild*>(item.data().get_PBlobChild());
+            RefPtr<BlobImpl> blobImpl = blob->GetBlobImpl();
+            variant->SetAsISupports(blobImpl);
+          } else {
+            continue;
+          }
+          // We should hide this data from content if we have a file, and we aren't a file.
+          bool hidden = hasFiles && item.data().type() != IPCDataTransferData::TPBlobChild;
+          dataTransfer->SetDataWithPrincipalFromOtherProcess(
+            NS_ConvertUTF8toUTF16(item.flavor()), variant, i,
+            nsContentUtils::GetSystemPrincipal(), hidden);
+        }
+      }
+      session->SetDataTransfer(dataTransfer);
+    }
+  }
+  return true;
+}
+
+bool
+ContentChild::RecvEndDragSession(const bool& aDoneDrag,
+                                 const bool& aUserCancelled,
+                                 const LayoutDeviceIntPoint& aDragEndPoint)
+{
+  nsCOMPtr<nsIDragService> dragService =
+    do_GetService("@mozilla.org/widget/dragservice;1");
+  if (dragService) {
+    if (aUserCancelled) {
+      nsCOMPtr<nsIDragSession> dragSession = nsContentUtils::GetDragSession();
+      if (dragSession) {
+        dragSession->UserCancelled();
+      }
+    }
+    static_cast<nsBaseDragService*>(dragService.get())->SetDragEndPoint(aDragEndPoint);
+    dragService->EndDragSession(aDoneDrag);
+  }
+  return true;
+}
+
+bool
+ContentChild::RecvPush(const nsCString& aScope,
+                       const IPC::Principal& aPrincipal,
+                       const nsString& aMessageId)
+{
+  PushMessageDispatcher dispatcher(aScope, aPrincipal, aMessageId, Nothing());
+  Unused << NS_WARN_IF(NS_FAILED(dispatcher.NotifyObserversAndWorkers()));
+  return true;
+}
+
+bool
+ContentChild::RecvPushWithData(const nsCString& aScope,
+                               const IPC::Principal& aPrincipal,
+                               const nsString& aMessageId,
+                               InfallibleTArray<uint8_t>&& aData)
+{
+  PushMessageDispatcher dispatcher(aScope, aPrincipal, aMessageId, Some(aData));
+  Unused << NS_WARN_IF(NS_FAILED(dispatcher.NotifyObserversAndWorkers()));
+  return true;
+}
+
+bool
+ContentChild::RecvPushSubscriptionChange(const nsCString& aScope,
+                                         const IPC::Principal& aPrincipal)
+{
+  PushSubscriptionChangeDispatcher dispatcher(aScope, aPrincipal);
+  Unused << NS_WARN_IF(NS_FAILED(dispatcher.NotifyObserversAndWorkers()));
+  return true;
+}
+
+bool
+ContentChild::RecvPushError(const nsCString& aScope, const IPC::Principal& aPrincipal,
+                            const nsString& aMessage, const uint32_t& aFlags)
+{
+  PushErrorDispatcher dispatcher(aScope, aPrincipal, aMessage, aFlags);
+  Unused << NS_WARN_IF(NS_FAILED(dispatcher.NotifyObserversAndWorkers()));
+  return true;
+}
+
+bool
+ContentChild::RecvNotifyPushSubscriptionModifiedObservers(const nsCString& aScope,
+                                                          const IPC::Principal& aPrincipal)
+{
+  PushSubscriptionModifiedDispatcher dispatcher(aScope, aPrincipal);
+  Unused << NS_WARN_IF(NS_FAILED(dispatcher.NotifyObservers()));
+  return true;
+}
+
+bool
+ContentChild::RecvBlobURLRegistration(const nsCString& aURI, PBlobChild* aBlobChild,
+                                      const IPC::Principal& aPrincipal)
+{
+  RefPtr<BlobImpl> blobImpl = static_cast<BlobChild*>(aBlobChild)->GetBlobImpl();
+  MOZ_ASSERT(blobImpl);
+
+  nsHostObjectProtocolHandler::AddDataEntry(aURI, aPrincipal, blobImpl);
+  return true;
+}
+
+bool
+ContentChild::RecvBlobURLUnregistration(const nsCString& aURI)
+{
+  nsHostObjectProtocolHandler::RemoveDataEntry(aURI);
+  return true;
+}
+
+#if defined(XP_WIN) && defined(ACCESSIBILITY)
+bool
+ContentChild::SendGetA11yContentId()
+{
+  return PContentChild::SendGetA11yContentId(&mMsaaID);
+}
+#endif // defined(XP_WIN) && defined(ACCESSIBILITY)
+
+void
+ContentChild::CreateGetFilesRequest(const nsAString& aDirectoryPath,
+                                    bool aRecursiveFlag,
+                                    nsID& aUUID,
+                                    GetFilesHelperChild* aChild)
+{
+  MOZ_ASSERT(aChild);
+  MOZ_ASSERT(!mGetFilesPendingRequests.GetWeak(aUUID));
+
+  Unused << SendGetFilesRequest(aUUID, nsString(aDirectoryPath),
+                                aRecursiveFlag);
+  mGetFilesPendingRequests.Put(aUUID, aChild);
+}
+
+void
+ContentChild::DeleteGetFilesRequest(nsID& aUUID, GetFilesHelperChild* aChild)
+{
+  MOZ_ASSERT(aChild);
+  MOZ_ASSERT(mGetFilesPendingRequests.GetWeak(aUUID));
+
+  Unused << SendDeleteGetFilesRequest(aUUID);
+  mGetFilesPendingRequests.Remove(aUUID);
+}
+
+bool
+ContentChild::RecvGetFilesResponse(const nsID& aUUID,
+                                   const GetFilesResponseResult& aResult)
+{
+  GetFilesHelperChild* child = mGetFilesPendingRequests.GetWeak(aUUID);
+  // This object can already been deleted in case DeleteGetFilesRequest has
+  // been called when the response was sending by the parent.
+  if (!child) {
+    return true;
+  }
+
+  if (aResult.type() == GetFilesResponseResult::TGetFilesResponseFailure) {
+    child->Finished(aResult.get_GetFilesResponseFailure().errorCode());
+  } else {
+    MOZ_ASSERT(aResult.type() == GetFilesResponseResult::TGetFilesResponseSuccess);
+
+    const nsTArray<PBlobChild*>& blobs =
+      aResult.get_GetFilesResponseSuccess().blobsChild();
+
+    bool succeeded = true;
+    for (uint32_t i = 0; succeeded && i < blobs.Length(); ++i) {
+      RefPtr<BlobImpl> impl = static_cast<BlobChild*>(blobs[i])->GetBlobImpl();
+      succeeded = child->AppendBlobImpl(impl);
+    }
+
+    child->Finished(succeeded ? NS_OK : NS_ERROR_OUT_OF_MEMORY);
+  }
+
+  mGetFilesPendingRequests.Remove(aUUID);
+  return true;
+}
+
+/* static */ void
+ContentChild::FatalErrorIfNotUsingGPUProcess(const char* const aProtocolName,
+                                             const char* const aErrorMsg,
+                                             base::ProcessId aOtherPid)
+{
+  // If we're communicating with the same process or the UI process then we
+  // want to crash normally. Otherwise we want to just warn as the other end
+  // must be the GPU process and it crashing shouldn't be fatal for us.
+  if (aOtherPid == base::GetCurrentProcId() ||
+      (GetSingleton() && GetSingleton()->OtherPid() == aOtherPid)) {
+    mozilla::ipc::FatalError(aProtocolName, aErrorMsg, false);
+  } else {
+    nsAutoCString formattedMessage("IPDL error [");
+    formattedMessage.AppendASCII(aProtocolName);
+    formattedMessage.AppendLiteral("]: \"");
+    formattedMessage.AppendASCII(aErrorMsg);
+    formattedMessage.AppendLiteral("\".");
+    NS_WARNING(formattedMessage.get());
+  }
+}
+
+} // namespace dom
+} // namespace mozilla
diff -rupN a/gfx/gl/GLContextProviderGLX.cpp b/gfx/gl/GLContextProviderGLX.cpp
--- a/gfx/gl/GLContextProviderGLX.cpp	2017-01-23 11:13:58.000000000 -0500
+++ b/gfx/gl/GLContextProviderGLX.cpp	2017-03-07 23:40:34.290635643 -0500
@@ -67,6 +67,8 @@ HasExtension(const char* aExtensions, co
 bool
 GLXLibrary::EnsureInitialized()
 {
+    return false;
+
     if (mInitialized) {
         return true;
     }
diff -rupN a/gfx/thebes/gfxFcPlatformFontList.cpp b/gfx/thebes/gfxFcPlatformFontList.cpp
--- a/gfx/thebes/gfxFcPlatformFontList.cpp	2017-01-23 11:13:47.000000000 -0500
+++ b/gfx/thebes/gfxFcPlatformFontList.cpp	2017-03-07 23:40:34.290635643 -0500
@@ -772,12 +772,14 @@ PreparePattern(FcPattern* aPattern, bool
 #endif
 
 #ifdef MOZ_X11
-        FcValue value;
-        int lcdfilter;
-        if (FcPatternGet(aPattern, FC_LCD_FILTER, 0, &value)
-                == FcResultNoMatch &&
-            GetXftInt(DefaultXDisplay(), "lcdfilter", &lcdfilter)) {
-            FcPatternAddInteger(aPattern, FC_LCD_FILTER, lcdfilter);
+        if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+            FcValue value;
+            int lcdfilter;
+            if (FcPatternGet(aPattern, FC_LCD_FILTER, 0, &value)
+                    == FcResultNoMatch &&
+                GetXftInt(DefaultXDisplay(), "lcdfilter", &lcdfilter)) {
+                FcPatternAddInteger(aPattern, FC_LCD_FILTER, lcdfilter);
+            }
         }
 #endif
     }
diff -rupN a/gfx/thebes/gfxFcPlatformFontList.cpp.orig b/gfx/thebes/gfxFcPlatformFontList.cpp.orig
--- a/gfx/thebes/gfxFcPlatformFontList.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/gfx/thebes/gfxFcPlatformFontList.cpp.orig	2017-01-23 11:13:47.000000000 -0500
@@ -0,0 +1,1754 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/Logging.h"
+
+#include "gfxFcPlatformFontList.h"
+#include "gfxFont.h"
+#include "gfxFontConstants.h"
+#include "gfxFontFamilyList.h"
+#include "gfxFT2Utils.h"
+#include "gfxPlatform.h"
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/Preferences.h"
+#include "mozilla/Sprintf.h"
+#include "mozilla/TimeStamp.h"
+#include "nsGkAtoms.h"
+#include "nsILanguageAtomService.h"
+#include "nsUnicodeProperties.h"
+#include "nsUnicodeRange.h"
+#include "nsDirectoryServiceUtils.h"
+#include "nsDirectoryServiceDefs.h"
+#include "nsAppDirectoryServiceDefs.h"
+#include "nsCharSeparatedTokenizer.h"
+
+#include "mozilla/gfx/HelpersCairo.h"
+
+#include <fontconfig/fcfreetype.h>
+
+#ifdef MOZ_WIDGET_GTK
+#include <gdk/gdk.h>
+#include "gfxPlatformGtk.h"
+#endif
+
+#ifdef MOZ_X11
+#include "mozilla/X11Util.h"
+#endif
+
+using namespace mozilla;
+using namespace mozilla::unicode;
+
+#ifndef FC_POSTSCRIPT_NAME
+#define FC_POSTSCRIPT_NAME  "postscriptname"      /* String */
+#endif
+
+#define PRINTING_FC_PROPERTY "gfx.printing"
+
+#define LOG_FONTLIST(args) MOZ_LOG(gfxPlatform::GetLog(eGfxLog_fontlist), \
+                               LogLevel::Debug, args)
+#define LOG_FONTLIST_ENABLED() MOZ_LOG_TEST( \
+                                   gfxPlatform::GetLog(eGfxLog_fontlist), \
+                                   LogLevel::Debug)
+#define LOG_CMAPDATA_ENABLED() MOZ_LOG_TEST( \
+                                   gfxPlatform::GetLog(eGfxLog_cmapdata), \
+                                   LogLevel::Debug)
+
+static const FcChar8*
+ToFcChar8Ptr(const char* aStr)
+{
+    return reinterpret_cast<const FcChar8*>(aStr);
+}
+
+static const char*
+ToCharPtr(const FcChar8 *aStr)
+{
+    return reinterpret_cast<const char*>(aStr);
+}
+
+FT_Library gfxFcPlatformFontList::sCairoFTLibrary = nullptr;
+
+static cairo_user_data_key_t sFcFontlistUserFontDataKey;
+
+// canonical name ==> first en name or first name if no en name
+// This is the required logic for fullname lookups as per CSS3 Fonts spec.
+static uint32_t
+FindCanonicalNameIndex(FcPattern* aFont, const char* aLangField)
+{
+    uint32_t n = 0, en = 0;
+    FcChar8* lang;
+    while (FcPatternGetString(aFont, aLangField, n, &lang) == FcResultMatch) {
+        // look for 'en' or variants, en-US, en-JP etc.
+        uint32_t len = strlen(ToCharPtr(lang));
+        bool enPrefix = (strncmp(ToCharPtr(lang), "en", 2) == 0);
+        if (enPrefix && (len == 2 || (len > 2 && aLangField[2] == '-'))) {
+            en = n;
+            break;
+        }
+        n++;
+    }
+    return en;
+}
+
+static void
+GetFaceNames(FcPattern* aFont, const nsAString& aFamilyName,
+             nsAString& aPostscriptName, nsAString& aFullname)
+{
+    // get the Postscript name
+    FcChar8* psname;
+    if (FcPatternGetString(aFont, FC_POSTSCRIPT_NAME, 0, &psname) == FcResultMatch) {
+        AppendUTF8toUTF16(ToCharPtr(psname), aPostscriptName);
+    }
+
+    // get the canonical fullname (i.e. en name or first name)
+    uint32_t en = FindCanonicalNameIndex(aFont, FC_FULLNAMELANG);
+    FcChar8* fullname;
+    if (FcPatternGetString(aFont, FC_FULLNAME, en, &fullname) == FcResultMatch) {
+        AppendUTF8toUTF16(ToCharPtr(fullname), aFullname);
+    }
+
+    // if have fullname, done
+    if (!aFullname.IsEmpty()) {
+        return;
+    }
+
+    // otherwise, set the fullname to family + style name [en] and use that
+    aFullname.Append(aFamilyName);
+
+    // figure out the en style name
+    en = FindCanonicalNameIndex(aFont, FC_STYLELANG);
+    nsAutoString style;
+    FcChar8* stylename = nullptr;
+    FcPatternGetString(aFont, FC_STYLE, en, &stylename);
+    if (stylename) {
+        AppendUTF8toUTF16(ToCharPtr(stylename), style);
+    }
+
+    if (!style.IsEmpty() && !style.EqualsLiteral("Regular")) {
+        aFullname.Append(' ');
+        aFullname.Append(style);
+    }
+}
+
+static uint16_t
+MapFcWeight(int aFcWeight)
+{
+    if (aFcWeight <= (FC_WEIGHT_THIN + FC_WEIGHT_EXTRALIGHT) / 2) {
+        return 100;
+    } else if (aFcWeight <= (FC_WEIGHT_EXTRALIGHT + FC_WEIGHT_LIGHT) / 2) {
+        return 200;
+    } else if (aFcWeight <= (FC_WEIGHT_LIGHT + FC_WEIGHT_BOOK) / 2) {
+        return 300;
+    } else if (aFcWeight <= (FC_WEIGHT_REGULAR + FC_WEIGHT_MEDIUM) / 2) {
+        // This includes FC_WEIGHT_BOOK
+        return 400;
+    } else if (aFcWeight <= (FC_WEIGHT_MEDIUM + FC_WEIGHT_DEMIBOLD) / 2) {
+        return 500;
+    } else if (aFcWeight <= (FC_WEIGHT_DEMIBOLD + FC_WEIGHT_BOLD) / 2) {
+        return 600;
+    } else if (aFcWeight <= (FC_WEIGHT_BOLD + FC_WEIGHT_EXTRABOLD) / 2) {
+        return 700;
+    } else if (aFcWeight <= (FC_WEIGHT_EXTRABOLD + FC_WEIGHT_BLACK) / 2) {
+        return 800;
+    } else if (aFcWeight <= FC_WEIGHT_BLACK) {
+        return 900;
+    }
+
+    // including FC_WEIGHT_EXTRABLACK
+    return 901;
+}
+
+static int16_t
+MapFcWidth(int aFcWidth)
+{
+    if (aFcWidth <= (FC_WIDTH_ULTRACONDENSED + FC_WIDTH_EXTRACONDENSED) / 2) {
+        return NS_FONT_STRETCH_ULTRA_CONDENSED;
+    }
+    if (aFcWidth <= (FC_WIDTH_EXTRACONDENSED + FC_WIDTH_CONDENSED) / 2) {
+        return NS_FONT_STRETCH_EXTRA_CONDENSED;
+    }
+    if (aFcWidth <= (FC_WIDTH_CONDENSED + FC_WIDTH_SEMICONDENSED) / 2) {
+        return NS_FONT_STRETCH_CONDENSED;
+    }
+    if (aFcWidth <= (FC_WIDTH_SEMICONDENSED + FC_WIDTH_NORMAL) / 2) {
+        return NS_FONT_STRETCH_SEMI_CONDENSED;
+    }
+    if (aFcWidth <= (FC_WIDTH_NORMAL + FC_WIDTH_SEMIEXPANDED) / 2) {
+        return NS_FONT_STRETCH_NORMAL;
+    }
+    if (aFcWidth <= (FC_WIDTH_SEMIEXPANDED + FC_WIDTH_EXPANDED) / 2) {
+        return NS_FONT_STRETCH_SEMI_EXPANDED;
+    }
+    if (aFcWidth <= (FC_WIDTH_EXPANDED + FC_WIDTH_EXTRAEXPANDED) / 2) {
+        return NS_FONT_STRETCH_EXPANDED;
+    }
+    if (aFcWidth <= (FC_WIDTH_EXTRAEXPANDED + FC_WIDTH_ULTRAEXPANDED) / 2) {
+        return NS_FONT_STRETCH_EXTRA_EXPANDED;
+    }
+    return NS_FONT_STRETCH_ULTRA_EXPANDED;
+}
+
+gfxFontconfigFontEntry::gfxFontconfigFontEntry(const nsAString& aFaceName,
+                                               FcPattern* aFontPattern,
+                                               bool aIgnoreFcCharmap)
+        : gfxFontEntry(aFaceName), mFontPattern(aFontPattern),
+          mFTFace(nullptr), mFTFaceInitialized(false),
+          mIgnoreFcCharmap(aIgnoreFcCharmap),
+          mAspect(0.0), mFontData(nullptr)
+{
+    // italic
+    int slant;
+    if (FcPatternGetInteger(aFontPattern, FC_SLANT, 0, &slant) != FcResultMatch) {
+        slant = FC_SLANT_ROMAN;
+    }
+    if (slant == FC_SLANT_OBLIQUE) {
+        mStyle = NS_FONT_STYLE_OBLIQUE;
+    } else if (slant > 0) {
+        mStyle = NS_FONT_STYLE_ITALIC;
+    }
+
+    // weight
+    int weight;
+    if (FcPatternGetInteger(aFontPattern, FC_WEIGHT, 0, &weight) != FcResultMatch) {
+        weight = FC_WEIGHT_REGULAR;
+    }
+    mWeight = MapFcWeight(weight);
+
+    // width
+    int width;
+    if (FcPatternGetInteger(aFontPattern, FC_WIDTH, 0, &width) != FcResultMatch) {
+        width = FC_WIDTH_NORMAL;
+    }
+    mStretch = MapFcWidth(width);
+}
+
+gfxFontconfigFontEntry::gfxFontconfigFontEntry(const nsAString& aFaceName,
+                                               uint16_t aWeight,
+                                               int16_t aStretch,
+                                               uint8_t aStyle,
+                                               const uint8_t *aData,
+                                               FT_Face aFace)
+    : gfxFontEntry(aFaceName),
+      mFTFace(aFace), mFTFaceInitialized(true),
+      mIgnoreFcCharmap(true),
+      mAspect(0.0), mFontData(aData)
+{
+    mWeight = aWeight;
+    mStyle = aStyle;
+    mStretch = aStretch;
+    mIsDataUserFont = true;
+
+    // Use fontconfig to fill out the pattern from the FTFace.
+    // The "file" argument cannot be nullptr (in fontconfig-2.6.0 at
+    // least). The dummy file passed here is removed below.
+    //
+    // When fontconfig scans the system fonts, FcConfigGetBlanks(nullptr)
+    // is passed as the "blanks" argument, which provides that unexpectedly
+    // blank glyphs are elided.  Here, however, we pass nullptr for
+    // "blanks", effectively assuming that, if the font has a blank glyph,
+    // then the author intends any associated character to be rendered
+    // blank.
+    mFontPattern = FcFreeTypeQueryFace(mFTFace, ToFcChar8Ptr(""), 0, nullptr);
+    // given that we have a FT_Face, not really sure this is possible...
+    if (!mFontPattern) {
+        mFontPattern = FcPatternCreate();
+    }
+    FcPatternDel(mFontPattern, FC_FILE);
+    FcPatternDel(mFontPattern, FC_INDEX);
+
+    // Make a new pattern and store the face in it so that cairo uses
+    // that when creating a cairo font face.
+    FcPatternAddFTFace(mFontPattern, FC_FT_FACE, mFTFace);
+
+    mUserFontData = new FTUserFontData(mFTFace, mFontData);
+}
+
+gfxFontconfigFontEntry::gfxFontconfigFontEntry(const nsAString& aFaceName,
+                                               FcPattern* aFontPattern,
+                                               uint16_t aWeight,
+                                               int16_t aStretch,
+                                               uint8_t aStyle)
+        : gfxFontEntry(aFaceName), mFontPattern(aFontPattern),
+          mFTFace(nullptr), mFTFaceInitialized(false),
+          mAspect(0.0), mFontData(nullptr)
+{
+    mWeight = aWeight;
+    mStyle = aStyle;
+    mStretch = aStretch;
+    mIsLocalUserFont = true;
+
+    // The proper setting of mIgnoreFcCharmap is tricky for fonts loaded
+    // via src:local()...
+    // If the local font happens to come from the application fontset,
+    // we want to set it to true so that color/svg fonts will work even
+    // if the default glyphs are blank; but if the local font is a non-
+    // sfnt face (e.g. legacy type 1) then we need to set it to false
+    // because our cmap-reading code will fail and we depend on FT+Fc to
+    // determine the coverage.
+    // We set the flag here, but may flip it the first time TestCharacterMap
+    // is called, at which point we'll look to see whether a 'cmap' is
+    // actually present in the font.
+    mIgnoreFcCharmap = true;
+}
+
+gfxFontconfigFontEntry::~gfxFontconfigFontEntry()
+{
+}
+
+static bool
+PatternHasLang(const FcPattern *aPattern, const FcChar8 *aLang)
+{
+    FcLangSet *langset;
+
+    if (FcPatternGetLangSet(aPattern, FC_LANG, 0, &langset) != FcResultMatch) {
+        return false;
+    }
+
+    if (FcLangSetHasLang(langset, aLang) != FcLangDifferentLang) {
+        return true;
+    }
+    return false;
+}
+
+bool
+gfxFontconfigFontEntry::SupportsLangGroup(nsIAtom *aLangGroup) const
+{
+    if (!aLangGroup || aLangGroup == nsGkAtoms::Unicode) {
+        return true;
+    }
+
+    nsAutoCString fcLang;
+    gfxFcPlatformFontList* pfl = gfxFcPlatformFontList::PlatformFontList();
+    pfl->GetSampleLangForGroup(aLangGroup, fcLang);
+    if (fcLang.IsEmpty()) {
+        return true;
+    }
+
+    // is lang included in the underlying pattern?
+    return PatternHasLang(mFontPattern, ToFcChar8Ptr(fcLang.get()));
+}
+
+nsresult
+gfxFontconfigFontEntry::ReadCMAP(FontInfoData *aFontInfoData)
+{
+    // attempt this once, if errors occur leave a blank cmap
+    if (mCharacterMap) {
+        return NS_OK;
+    }
+
+    RefPtr<gfxCharacterMap> charmap;
+    nsresult rv;
+    bool symbolFont = false; // currently ignored
+
+    if (aFontInfoData && (charmap = GetCMAPFromFontInfo(aFontInfoData,
+                                                        mUVSOffset,
+                                                        symbolFont))) {
+        rv = NS_OK;
+    } else {
+        uint32_t kCMAP = TRUETYPE_TAG('c','m','a','p');
+        charmap = new gfxCharacterMap();
+        AutoTable cmapTable(this, kCMAP);
+
+        if (cmapTable) {
+            bool unicodeFont = false; // currently ignored
+            uint32_t cmapLen;
+            const uint8_t* cmapData =
+                reinterpret_cast<const uint8_t*>(hb_blob_get_data(cmapTable,
+                                                                  &cmapLen));
+            rv = gfxFontUtils::ReadCMAP(cmapData, cmapLen,
+                                        *charmap, mUVSOffset,
+                                        unicodeFont, symbolFont);
+        } else {
+            rv = NS_ERROR_NOT_AVAILABLE;
+        }
+    }
+
+    mHasCmapTable = NS_SUCCEEDED(rv);
+    if (mHasCmapTable) {
+        gfxPlatformFontList *pfl = gfxPlatformFontList::PlatformFontList();
+        mCharacterMap = pfl->FindCharMap(charmap);
+    } else {
+        // if error occurred, initialize to null cmap
+        mCharacterMap = new gfxCharacterMap();
+    }
+
+    LOG_FONTLIST(("(fontlist-cmap) name: %s, size: %d hash: %8.8x%s\n",
+                  NS_ConvertUTF16toUTF8(mName).get(),
+                  charmap->SizeOfIncludingThis(moz_malloc_size_of),
+                  charmap->mHash, mCharacterMap == charmap ? " new" : ""));
+    if (LOG_CMAPDATA_ENABLED()) {
+        char prefix[256];
+        SprintfLiteral(prefix, "(cmapdata) name: %.220s",
+                       NS_ConvertUTF16toUTF8(mName).get());
+        charmap->Dump(prefix, eGfxLog_cmapdata);
+    }
+
+    return rv;
+}
+
+static bool
+HasChar(FcPattern *aFont, FcChar32 aCh)
+{
+    FcCharSet *charset = nullptr;
+    FcPatternGetCharSet(aFont, FC_CHARSET, 0, &charset);
+    return charset && FcCharSetHasChar(charset, aCh);
+}
+
+bool
+gfxFontconfigFontEntry::TestCharacterMap(uint32_t aCh)
+{
+    // For user fonts, or for fonts bundled with the app (which might include
+    // color/svg glyphs where the default glyphs may be blank, and thus confuse
+    // fontconfig/freetype's char map checking), we instead check the cmap
+    // directly for character coverage.
+    if (mIgnoreFcCharmap) {
+        // If it does not actually have a cmap, switch our strategy to use
+        // fontconfig's charmap after all (except for data fonts, which must
+        // always have a cmap to have passed OTS validation).
+        if (!mIsDataUserFont && !HasFontTable(TRUETYPE_TAG('c','m','a','p'))) {
+            mIgnoreFcCharmap = false;
+            // ...and continue with HasChar() below.
+        } else {
+            return gfxFontEntry::TestCharacterMap(aCh);
+        }
+    }
+    // otherwise (for system fonts), use the charmap in the pattern
+    return HasChar(mFontPattern, aCh);
+}
+
+hb_blob_t*
+gfxFontconfigFontEntry::GetFontTable(uint32_t aTableTag)
+{
+    // for data fonts, read directly from the font data
+    if (mFontData) {
+        return gfxFontUtils::GetTableFromFontData(mFontData, aTableTag);
+    }
+
+    return gfxFontEntry::GetFontTable(aTableTag);
+}
+
+void
+gfxFontconfigFontEntry::MaybeReleaseFTFace()
+{
+    // don't release if either HB or Gr face still exists
+    if (mHBFace || mGrFace) {
+        return;
+    }
+    // only close out FT_Face for system fonts, not for data fonts
+    if (!mIsDataUserFont) {
+        if (mFTFace) {
+            FT_Done_Face(mFTFace);
+            mFTFace = nullptr;
+        }
+        mFTFaceInitialized = false;
+    }
+}
+
+void
+gfxFontconfigFontEntry::ForgetHBFace()
+{
+    gfxFontEntry::ForgetHBFace();
+    MaybeReleaseFTFace();
+}
+
+void
+gfxFontconfigFontEntry::ReleaseGrFace(gr_face* aFace)
+{
+    gfxFontEntry::ReleaseGrFace(aFace);
+    MaybeReleaseFTFace();
+}
+
+double
+gfxFontconfigFontEntry::GetAspect()
+{
+    if (mAspect == 0.0) {
+        // default to aspect = 0.5
+        mAspect = 0.5;
+
+        // create a font to calculate x-height / em-height
+        gfxFontStyle s;
+        s.size = 100.0; // pick large size to avoid possible hinting artifacts
+        RefPtr<gfxFont> font = FindOrMakeFont(&s, false);
+        if (font) {
+            const gfxFont::Metrics& metrics =
+                font->GetMetrics(gfxFont::eHorizontal);
+
+            // The factor of 0.1 ensures that xHeight is sane so fonts don't
+            // become huge.  Strictly ">" ensures that xHeight and emHeight are
+            // not both zero.
+            if (metrics.xHeight > 0.1 * metrics.emHeight) {
+                mAspect = metrics.xHeight / metrics.emHeight;
+            }
+        }
+    }
+    return mAspect;
+}
+
+static void
+PrepareFontOptions(FcPattern* aPattern,
+                   cairo_font_options_t* aFontOptions)
+{
+    NS_ASSERTION(aFontOptions, "null font options passed to PrepareFontOptions");
+
+    // xxx - taken from the gfxFontconfigFonts code, needs to be reviewed
+
+    FcBool printing;
+    if (FcPatternGetBool(aPattern, PRINTING_FC_PROPERTY, 0, &printing) !=
+            FcResultMatch) {
+        printing = FcFalse;
+    }
+
+    // Font options are set explicitly here to improve cairo's caching
+    // behavior and to record the relevant parts of the pattern for
+    // SetupCairoFont (so that the pattern can be released).
+    //
+    // Most font_options have already been set as defaults on the FcPattern
+    // with cairo_ft_font_options_substitute(), then user and system
+    // fontconfig configurations were applied.  The resulting font_options
+    // have been recorded on the face during
+    // cairo_ft_font_face_create_for_pattern().
+    //
+    // None of the settings here cause this scaled_font to behave any
+    // differently from how it would behave if it were created from the same
+    // face with default font_options.
+    //
+    // We set options explicitly so that the same scaled_font will be found in
+    // the cairo_scaled_font_map when cairo loads glyphs from a context with
+    // the same font_face, font_matrix, ctm, and surface font_options.
+    //
+    // Unfortunately, _cairo_scaled_font_keys_equal doesn't know about the
+    // font_options on the cairo_ft_font_face, and doesn't consider default
+    // option values to not match any explicit values.
+    //
+    // Even after cairo_set_scaled_font is used to set font_options for the
+    // cairo context, when cairo looks for a scaled_font for the context, it
+    // will look for a font with some option values from the target surface if
+    // any values are left default on the context font_options.  If this
+    // scaled_font is created with default font_options, cairo will not find
+    // it.
+    //
+    // The one option not recorded in the pattern is hint_metrics, which will
+    // affect glyph metrics.  The default behaves as CAIRO_HINT_METRICS_ON.
+    // We should be considering the font_options of the surface on which this
+    // font will be used, but currently we don't have different gfxFonts for
+    // different surface font_options, so we'll create a font suitable for the
+    // Screen. Image and xlib surfaces default to CAIRO_HINT_METRICS_ON.
+    if (printing) {
+        cairo_font_options_set_hint_metrics(aFontOptions, CAIRO_HINT_METRICS_OFF);
+    } else {
+        cairo_font_options_set_hint_metrics(aFontOptions, CAIRO_HINT_METRICS_ON);
+    }
+
+    // The remaining options have been recorded on the pattern and the face.
+    // _cairo_ft_options_merge has some logic to decide which options from the
+    // scaled_font or from the cairo_ft_font_face take priority in the way the
+    // font behaves.
+    //
+    // In the majority of cases, _cairo_ft_options_merge uses the options from
+    // the cairo_ft_font_face, so sometimes it is not so important which
+    // values are set here so long as they are not defaults, but we'll set
+    // them to the exact values that we expect from the font, to be consistent
+    // and to protect against changes in cairo.
+    //
+    // In some cases, _cairo_ft_options_merge uses some options from the
+    // scaled_font's font_options rather than options on the
+    // cairo_ft_font_face (from fontconfig).
+    // https://bugs.freedesktop.org/show_bug.cgi?id=11838
+    //
+    // Surface font options were set on the pattern in
+    // cairo_ft_font_options_substitute.  If fontconfig has changed the
+    // hint_style then that is what the user (or distribution) wants, so we
+    // use the setting from the FcPattern.
+    //
+    // Fallback values here mirror treatment of defaults in cairo-ft-font.c.
+    FcBool hinting = FcFalse;
+    if (FcPatternGetBool(aPattern, FC_HINTING, 0, &hinting) != FcResultMatch) {
+        hinting = FcTrue;
+    }
+
+    cairo_hint_style_t hint_style;
+    if (printing || !hinting) {
+        hint_style = CAIRO_HINT_STYLE_NONE;
+    } else {
+        int fc_hintstyle;
+        if (FcPatternGetInteger(aPattern, FC_HINT_STYLE,
+                                0, &fc_hintstyle) != FcResultMatch) {
+            fc_hintstyle = FC_HINT_FULL;
+        }
+        switch (fc_hintstyle) {
+            case FC_HINT_NONE:
+                hint_style = CAIRO_HINT_STYLE_NONE;
+                break;
+            case FC_HINT_SLIGHT:
+                hint_style = CAIRO_HINT_STYLE_SLIGHT;
+                break;
+            case FC_HINT_MEDIUM:
+            default: // This fallback mirrors _get_pattern_ft_options in cairo.
+                hint_style = CAIRO_HINT_STYLE_MEDIUM;
+                break;
+            case FC_HINT_FULL:
+                hint_style = CAIRO_HINT_STYLE_FULL;
+                break;
+        }
+    }
+    cairo_font_options_set_hint_style(aFontOptions, hint_style);
+
+    int rgba;
+    if (FcPatternGetInteger(aPattern,
+                            FC_RGBA, 0, &rgba) != FcResultMatch) {
+        rgba = FC_RGBA_UNKNOWN;
+    }
+    cairo_subpixel_order_t subpixel_order = CAIRO_SUBPIXEL_ORDER_DEFAULT;
+    switch (rgba) {
+        case FC_RGBA_UNKNOWN:
+        case FC_RGBA_NONE:
+        default:
+            // There is no CAIRO_SUBPIXEL_ORDER_NONE.  Subpixel antialiasing
+            // is disabled through cairo_antialias_t.
+            rgba = FC_RGBA_NONE;
+            // subpixel_order won't be used by the font as we won't use
+            // CAIRO_ANTIALIAS_SUBPIXEL, but don't leave it at default for
+            // caching reasons described above.  Fall through:
+            MOZ_FALLTHROUGH;
+        case FC_RGBA_RGB:
+            subpixel_order = CAIRO_SUBPIXEL_ORDER_RGB;
+            break;
+        case FC_RGBA_BGR:
+            subpixel_order = CAIRO_SUBPIXEL_ORDER_BGR;
+            break;
+        case FC_RGBA_VRGB:
+            subpixel_order = CAIRO_SUBPIXEL_ORDER_VRGB;
+            break;
+        case FC_RGBA_VBGR:
+            subpixel_order = CAIRO_SUBPIXEL_ORDER_VBGR;
+            break;
+    }
+    cairo_font_options_set_subpixel_order(aFontOptions, subpixel_order);
+
+    FcBool fc_antialias;
+    if (FcPatternGetBool(aPattern,
+                         FC_ANTIALIAS, 0, &fc_antialias) != FcResultMatch) {
+        fc_antialias = FcTrue;
+    }
+    cairo_antialias_t antialias;
+    if (!fc_antialias) {
+        antialias = CAIRO_ANTIALIAS_NONE;
+    } else if (rgba == FC_RGBA_NONE) {
+        antialias = CAIRO_ANTIALIAS_GRAY;
+    } else {
+        antialias = CAIRO_ANTIALIAS_SUBPIXEL;
+    }
+    cairo_font_options_set_antialias(aFontOptions, antialias);
+}
+
+cairo_scaled_font_t*
+gfxFontconfigFontEntry::CreateScaledFont(FcPattern* aRenderPattern,
+                                         gfxFloat aAdjustedSize,
+                                         const gfxFontStyle *aStyle,
+                                         bool aNeedsBold)
+{
+    if (aNeedsBold) {
+        FcPatternAddBool(aRenderPattern, FC_EMBOLDEN, FcTrue);
+    }
+
+    // synthetic oblique by skewing via the font matrix
+    bool needsOblique = IsUpright() &&
+                        aStyle->style != NS_FONT_STYLE_NORMAL &&
+                        aStyle->allowSyntheticStyle;
+
+    if (needsOblique) {
+        // disable embedded bitmaps (mimics behavior in 90-synthetic.conf)
+        FcPatternDel(aRenderPattern, FC_EMBEDDED_BITMAP);
+        FcPatternAddBool(aRenderPattern, FC_EMBEDDED_BITMAP, FcFalse);
+    }
+
+    cairo_font_face_t *face =
+        cairo_ft_font_face_create_for_pattern(aRenderPattern);
+
+    if (mFontData) {
+        // for data fonts, add the face/data pointer to the cairo font face
+        // so that it gets deleted whenever cairo decides
+        NS_ASSERTION(mFTFace, "FT_Face is null when setting user data");
+        NS_ASSERTION(mUserFontData, "user font data is null when setting user data");
+        cairo_font_face_set_user_data(face,
+                                      &sFcFontlistUserFontDataKey,
+                                      new FTUserFontDataRef(mUserFontData),
+                                      FTUserFontDataRef::Destroy);
+    }
+
+    cairo_scaled_font_t *scaledFont = nullptr;
+
+    cairo_matrix_t sizeMatrix;
+    cairo_matrix_t identityMatrix;
+
+    cairo_matrix_init_scale(&sizeMatrix, aAdjustedSize, aAdjustedSize);
+    cairo_matrix_init_identity(&identityMatrix);
+
+    if (needsOblique) {
+        const double kSkewFactor = OBLIQUE_SKEW_FACTOR;
+
+        cairo_matrix_t style;
+        cairo_matrix_init(&style,
+                          1,                //xx
+                          0,                //yx
+                          -1 * kSkewFactor,  //xy
+                          1,                //yy
+                          0,                //x0
+                          0);               //y0
+        cairo_matrix_multiply(&sizeMatrix, &sizeMatrix, &style);
+    }
+
+    cairo_font_options_t *fontOptions = cairo_font_options_create();
+    PrepareFontOptions(aRenderPattern, fontOptions);
+
+    scaledFont = cairo_scaled_font_create(face, &sizeMatrix,
+                                          &identityMatrix, fontOptions);
+    cairo_font_options_destroy(fontOptions);
+
+    NS_ASSERTION(cairo_scaled_font_status(scaledFont) == CAIRO_STATUS_SUCCESS,
+                 "Failed to make scaled font");
+
+    cairo_font_face_destroy(face);
+
+    return scaledFont;
+}
+
+#ifdef MOZ_WIDGET_GTK
+// defintion included below
+static void ApplyGdkScreenFontOptions(FcPattern *aPattern);
+#endif
+
+#ifdef MOZ_X11
+static bool
+GetXftInt(Display* aDisplay, const char* aName, int* aResult)
+{
+    if (!aDisplay) {
+        return false;
+    }
+    char* value = XGetDefault(aDisplay, "Xft", aName);
+    if (!value) {
+        return false;
+    }
+    if (FcNameConstant(const_cast<FcChar8*>(ToFcChar8Ptr(value)), aResult)) {
+        return true;
+    }
+    char* end;
+    *aResult = strtol(value, &end, 0);
+    if (end != value) {
+        return true;
+    }
+    return false;
+}
+#endif
+
+static void
+PreparePattern(FcPattern* aPattern, bool aIsPrinterFont)
+{
+    FcConfigSubstitute(nullptr, aPattern, FcMatchPattern);
+
+    // This gets cairo_font_options_t for the Screen.  We should have
+    // different font options for printing (no hinting) but we are not told
+    // what we are measuring for.
+    //
+    // If cairo adds support for lcd_filter, gdk will not provide the default
+    // setting for that option.  We could get the default setting by creating
+    // an xlib surface once, recording its font_options, and then merging the
+    // gdk options.
+    //
+    // Using an xlib surface would also be an option to get Screen font
+    // options for non-GTK X11 toolkits, but less efficient than using GDK to
+    // pick up dynamic changes.
+    if(aIsPrinterFont) {
+       cairo_font_options_t *options = cairo_font_options_create();
+       cairo_font_options_set_hint_style (options, CAIRO_HINT_STYLE_NONE);
+       cairo_font_options_set_antialias (options, CAIRO_ANTIALIAS_GRAY);
+       cairo_ft_font_options_substitute(options, aPattern);
+       cairo_font_options_destroy(options);
+       FcPatternAddBool(aPattern, PRINTING_FC_PROPERTY, FcTrue);
+    } else {
+#ifdef MOZ_WIDGET_GTK
+       ApplyGdkScreenFontOptions(aPattern);
+#endif
+
+#ifdef MOZ_X11
+        FcValue value;
+        int lcdfilter;
+        if (FcPatternGet(aPattern, FC_LCD_FILTER, 0, &value)
+                == FcResultNoMatch &&
+            GetXftInt(DefaultXDisplay(), "lcdfilter", &lcdfilter)) {
+            FcPatternAddInteger(aPattern, FC_LCD_FILTER, lcdfilter);
+        }
+#endif
+    }
+
+    FcDefaultSubstitute(aPattern);
+}
+
+gfxFont*
+gfxFontconfigFontEntry::CreateFontInstance(const gfxFontStyle *aFontStyle,
+                                           bool aNeedsBold)
+{
+    nsAutoRef<FcPattern> pattern(FcPatternCreate());
+    if (!pattern) {
+        NS_WARNING("Failed to create Fontconfig pattern for font instance");
+        return nullptr;
+    }
+    FcPatternAddDouble(pattern, FC_PIXEL_SIZE, aFontStyle->size);
+
+    PreparePattern(pattern, aFontStyle->printerFont);
+    nsAutoRef<FcPattern> renderPattern
+        (FcFontRenderPrepare(nullptr, pattern, mFontPattern));
+    if (!renderPattern) {
+        NS_WARNING("Failed to prepare Fontconfig pattern for font instance");
+        return nullptr;
+    }
+
+    double adjustedSize = aFontStyle->size;
+    if (aFontStyle->sizeAdjust >= 0.0) {
+        adjustedSize = aFontStyle->GetAdjustedSize(GetAspect());
+    }
+
+    cairo_scaled_font_t* scaledFont =
+        CreateScaledFont(renderPattern, adjustedSize, aFontStyle, aNeedsBold);
+    gfxFont* newFont =
+        new gfxFontconfigFont(scaledFont, renderPattern, adjustedSize,
+                              this, aFontStyle, aNeedsBold);
+    cairo_scaled_font_destroy(scaledFont);
+
+    return newFont;
+}
+
+nsresult
+gfxFontconfigFontEntry::CopyFontTable(uint32_t aTableTag,
+                                      nsTArray<uint8_t>& aBuffer)
+{
+    NS_ASSERTION(!mIsDataUserFont,
+                 "data fonts should be reading tables directly from memory");
+
+    if (!mFTFaceInitialized) {
+        mFTFaceInitialized = true;
+        FcChar8 *filename;
+        if (FcPatternGetString(mFontPattern, FC_FILE, 0, &filename) != FcResultMatch) {
+            return NS_ERROR_FAILURE;
+        }
+        int index;
+        if (FcPatternGetInteger(mFontPattern, FC_INDEX, 0, &index) != FcResultMatch) {
+            index = 0; // default to 0 if not found in pattern
+        }
+        if (FT_New_Face(gfxFcPlatformFontList::GetFTLibrary(),
+                        (const char*)filename, index, &mFTFace) != 0) {
+            return NS_ERROR_FAILURE;
+        }
+    }
+
+    if (!mFTFace) {
+        return NS_ERROR_NOT_AVAILABLE;
+    }
+
+    FT_ULong length = 0;
+    if (FT_Load_Sfnt_Table(mFTFace, aTableTag, 0, nullptr, &length) != 0) {
+        return NS_ERROR_NOT_AVAILABLE;
+    }
+    if (!aBuffer.SetLength(length, fallible)) {
+        return NS_ERROR_OUT_OF_MEMORY;
+    }
+    if (FT_Load_Sfnt_Table(mFTFace, aTableTag, 0, aBuffer.Elements(), &length) != 0) {
+        aBuffer.Clear();
+        return NS_ERROR_FAILURE;
+    }
+
+    return NS_OK;
+}
+
+void
+gfxFontconfigFontFamily::FindStyleVariations(FontInfoData *aFontInfoData)
+{
+    if (mHasStyles) {
+        return;
+    }
+
+    // add font entries for each of the faces
+    uint32_t numFonts = mFontPatterns.Length();
+    NS_ASSERTION(numFonts, "font family containing no faces!!");
+    uint32_t numRegularFaces = 0;
+    for (uint32_t i = 0; i < numFonts; i++) {
+        FcPattern* face = mFontPatterns[i];
+
+        // figure out the psname/fullname and choose which to use as the facename
+        nsAutoString psname, fullname;
+        GetFaceNames(face, mName, psname, fullname);
+        const nsAutoString& faceName = !psname.IsEmpty() ? psname : fullname;
+
+        gfxFontconfigFontEntry *fontEntry =
+            new gfxFontconfigFontEntry(faceName, face, mContainsAppFonts);
+        AddFontEntry(fontEntry);
+
+        if (fontEntry->IsUpright() &&
+            fontEntry->Weight() == NS_FONT_WEIGHT_NORMAL &&
+            fontEntry->Stretch() == NS_FONT_STRETCH_NORMAL) {
+            numRegularFaces++;
+        }
+
+        if (LOG_FONTLIST_ENABLED()) {
+            LOG_FONTLIST(("(fontlist) added (%s) to family (%s)"
+                 " with style: %s weight: %d stretch: %d"
+                 " psname: %s fullname: %s",
+                 NS_ConvertUTF16toUTF8(fontEntry->Name()).get(),
+                 NS_ConvertUTF16toUTF8(Name()).get(),
+                 (fontEntry->IsItalic()) ?
+                  "italic" : (fontEntry->IsOblique() ? "oblique" : "normal"),
+                 fontEntry->Weight(), fontEntry->Stretch(),
+                 NS_ConvertUTF16toUTF8(psname).get(),
+                 NS_ConvertUTF16toUTF8(fullname).get()));
+        }
+    }
+
+    // somewhat arbitrary, but define a family with two or more regular
+    // faces as a family for which intra-family fallback should be used
+    if (numRegularFaces > 1) {
+        mCheckForFallbackFaces = true;
+    }
+    mFaceNamesInitialized = true;
+    mFontPatterns.Clear();
+    SetHasStyles(true);
+}
+
+void
+gfxFontconfigFontFamily::AddFontPattern(FcPattern* aFontPattern)
+{
+    NS_ASSERTION(!mHasStyles,
+                 "font patterns must not be added to already enumerated families");
+
+    nsCountedRef<FcPattern> pattern(aFontPattern);
+    mFontPatterns.AppendElement(pattern);
+}
+
+gfxFontconfigFont::gfxFontconfigFont(cairo_scaled_font_t *aScaledFont,
+                                     FcPattern *aPattern,
+                                     gfxFloat aAdjustedSize,
+                                     gfxFontEntry *aFontEntry,
+                                     const gfxFontStyle *aFontStyle,
+                                     bool aNeedsBold) :
+    gfxFontconfigFontBase(aScaledFont, aPattern, aFontEntry, aFontStyle)
+{
+    mAdjustedSize = aAdjustedSize;
+}
+
+gfxFontconfigFont::~gfxFontconfigFont()
+{
+}
+
+gfxFcPlatformFontList::gfxFcPlatformFontList()
+    : mLocalNames(64)
+    , mGenericMappings(32)
+    , mFcSubstituteCache(64)
+    , mLastConfig(nullptr)
+    , mAlwaysUseFontconfigGenerics(true)
+{
+    // if the rescan interval is set, start the timer
+    int rescanInterval = FcConfigGetRescanInterval(nullptr);
+    if (rescanInterval) {
+        mLastConfig = FcConfigGetCurrent();
+        mCheckFontUpdatesTimer = do_CreateInstance("@mozilla.org/timer;1");
+        if (mCheckFontUpdatesTimer) {
+            mCheckFontUpdatesTimer->
+                InitWithFuncCallback(CheckFontUpdates, this,
+                                     (rescanInterval + 1) * 1000,
+                                     nsITimer::TYPE_REPEATING_SLACK);
+        } else {
+            NS_WARNING("Failure to create font updates timer");
+        }
+    }
+
+#ifdef MOZ_BUNDLED_FONTS
+    mBundledFontsInitialized = false;
+#endif
+}
+
+gfxFcPlatformFontList::~gfxFcPlatformFontList()
+{
+    if (mCheckFontUpdatesTimer) {
+        mCheckFontUpdatesTimer->Cancel();
+        mCheckFontUpdatesTimer = nullptr;
+    }
+}
+
+void
+gfxFcPlatformFontList::AddFontSetFamilies(FcFontSet* aFontSet, bool aAppFonts)
+{
+    // This iterates over the fonts in a font set and adds in gfxFontFamily
+    // objects for each family. The patterns for individual fonts are not
+    // copied here. When a family is actually used, the fonts in the family
+    // are enumerated and the patterns copied. Note that we're explicitly
+    // excluding non-scalable fonts such as X11 bitmap fonts, which
+    // Chrome Skia/Webkit code does also.
+
+    if (!aFontSet) {
+        NS_WARNING("AddFontSetFamilies called with a null font set.");
+        return;
+    }
+
+    FcChar8* lastFamilyName = (FcChar8*)"";
+    RefPtr<gfxFontconfigFontFamily> fontFamily;
+    nsAutoString familyName;
+    for (int f = 0; f < aFontSet->nfont; f++) {
+        FcPattern* font = aFontSet->fonts[f];
+
+        // not scalable? skip...
+        FcBool scalable;
+        if (FcPatternGetBool(font, FC_SCALABLE, 0, &scalable) != FcResultMatch ||
+            !scalable) {
+            continue;
+        }
+
+        // get canonical name
+        uint32_t cIndex = FindCanonicalNameIndex(font, FC_FAMILYLANG);
+        FcChar8* canonical = nullptr;
+        FcPatternGetString(font, FC_FAMILY, cIndex, &canonical);
+        if (!canonical) {
+            continue;
+        }
+
+        // same as the last one? no need to add a new family, skip
+        if (FcStrCmp(canonical, lastFamilyName) != 0) {
+            lastFamilyName = canonical;
+
+            // add new family if one doesn't already exist
+            familyName.Truncate();
+            AppendUTF8toUTF16(ToCharPtr(canonical), familyName);
+            nsAutoString keyName(familyName);
+            ToLowerCase(keyName);
+
+            fontFamily = static_cast<gfxFontconfigFontFamily*>
+                             (mFontFamilies.GetWeak(keyName));
+            if (!fontFamily) {
+                fontFamily = new gfxFontconfigFontFamily(familyName);
+                mFontFamilies.Put(keyName, fontFamily);
+            }
+            // Record if the family contains fonts from the app font set
+            // (in which case we won't rely on fontconfig's charmap, due to
+            // bug 1276594).
+            if (aAppFonts) {
+                fontFamily->SetFamilyContainsAppFonts(true);
+            }
+
+            // Add pointers to other localized family names. Most fonts
+            // only have a single name, so the first call to GetString
+            // will usually not match
+            FcChar8* otherName;
+            int n = (cIndex == 0 ? 1 : 0);
+            while (FcPatternGetString(font, FC_FAMILY, n, &otherName) == FcResultMatch) {
+                NS_ConvertUTF8toUTF16 otherFamilyName(ToCharPtr(otherName));
+                AddOtherFamilyName(fontFamily, otherFamilyName);
+                n++;
+                if (n == int(cIndex)) {
+                    n++; // skip over canonical name
+                }
+            }
+        }
+
+        NS_ASSERTION(fontFamily, "font must belong to a font family");
+        fontFamily->AddFontPattern(font);
+
+        // map the psname, fullname ==> font family for local font lookups
+        nsAutoString psname, fullname;
+        GetFaceNames(font, familyName, psname, fullname);
+        if (!psname.IsEmpty()) {
+            ToLowerCase(psname);
+            mLocalNames.Put(psname, font);
+        }
+        if (!fullname.IsEmpty()) {
+            ToLowerCase(fullname);
+            mLocalNames.Put(fullname, font);
+        }
+    }
+}
+
+nsresult
+gfxFcPlatformFontList::InitFontListForPlatform()
+{
+    mLastConfig = FcConfigGetCurrent();
+
+    mLocalNames.Clear();
+    mFcSubstituteCache.Clear();
+
+    // iterate over available fonts
+    FcFontSet* systemFonts = FcConfigGetFonts(nullptr, FcSetSystem);
+    AddFontSetFamilies(systemFonts, /* aAppFonts = */ false);
+    mAlwaysUseFontconfigGenerics = PrefFontListsUseOnlyGenerics();
+
+#ifdef MOZ_BUNDLED_FONTS
+    ActivateBundledFonts();
+    FcFontSet* appFonts = FcConfigGetFonts(nullptr, FcSetApplication);
+    AddFontSetFamilies(appFonts, /* aAppFonts = */ true);
+#endif
+
+    mOtherFamilyNamesInitialized = true;
+
+    return NS_OK;
+}
+
+// For displaying the fontlist in UI, use explicit call to FcFontList. Using
+// FcFontList results in the list containing the localized names as dictated
+// by system defaults.
+static void
+GetSystemFontList(nsTArray<nsString>& aListOfFonts, nsIAtom *aLangGroup)
+{
+    aListOfFonts.Clear();
+
+    nsAutoRef<FcPattern> pat(FcPatternCreate());
+    if (!pat) {
+        return;
+    }
+
+    nsAutoRef<FcObjectSet> os(FcObjectSetBuild(FC_FAMILY, nullptr));
+    if (!os) {
+        return;
+    }
+
+    // add the lang to the pattern
+    nsAutoCString fcLang;
+    gfxFcPlatformFontList* pfl = gfxFcPlatformFontList::PlatformFontList();
+    pfl->GetSampleLangForGroup(aLangGroup, fcLang);
+    if (!fcLang.IsEmpty()) {
+        FcPatternAddString(pat, FC_LANG, ToFcChar8Ptr(fcLang.get()));
+    }
+
+    // ignore size-specific fonts
+    FcPatternAddBool(pat, FC_SCALABLE, FcTrue);
+
+    nsAutoRef<FcFontSet> fs(FcFontList(nullptr, pat, os));
+    if (!fs) {
+        return;
+    }
+
+    for (int i = 0; i < fs->nfont; i++) {
+        char *family;
+
+        if (FcPatternGetString(fs->fonts[i], FC_FAMILY, 0,
+                               (FcChar8 **) &family) != FcResultMatch)
+        {
+            continue;
+        }
+
+        // Remove duplicates...
+        nsAutoString strFamily;
+        AppendUTF8toUTF16(family, strFamily);
+        if (aListOfFonts.Contains(strFamily)) {
+            continue;
+        }
+
+        aListOfFonts.AppendElement(strFamily);
+    }
+
+    aListOfFonts.Sort();
+}
+
+void
+gfxFcPlatformFontList::GetFontList(nsIAtom *aLangGroup,
+                                   const nsACString& aGenericFamily,
+                                   nsTArray<nsString>& aListOfFonts)
+{
+    // Get the list of font family names using fontconfig
+    GetSystemFontList(aListOfFonts, aLangGroup);
+
+    // Under Linux, the generics "serif", "sans-serif" and "monospace"
+    // are included in the pref fontlist. These map to whatever fontconfig
+    // decides they should be for a given language, rather than one of the
+    // fonts listed in the prefs font lists (e.g. font.name.*, font.name-list.*)
+    bool serif = false, sansSerif = false, monospace = false;
+    if (aGenericFamily.IsEmpty())
+        serif = sansSerif = monospace = true;
+    else if (aGenericFamily.LowerCaseEqualsLiteral("serif"))
+        serif = true;
+    else if (aGenericFamily.LowerCaseEqualsLiteral("sans-serif"))
+        sansSerif = true;
+    else if (aGenericFamily.LowerCaseEqualsLiteral("monospace"))
+        monospace = true;
+    else if (aGenericFamily.LowerCaseEqualsLiteral("cursive") ||
+             aGenericFamily.LowerCaseEqualsLiteral("fantasy"))
+        serif = sansSerif = true;
+    else
+        NS_NOTREACHED("unexpected CSS generic font family");
+
+    // The first in the list becomes the default in
+    // FontBuilder.readFontSelection() if the preference-selected font is not
+    // available, so put system configured defaults first.
+    if (monospace)
+        aListOfFonts.InsertElementAt(0, NS_LITERAL_STRING("monospace"));
+    if (sansSerif)
+        aListOfFonts.InsertElementAt(0, NS_LITERAL_STRING("sans-serif"));
+    if (serif)
+        aListOfFonts.InsertElementAt(0, NS_LITERAL_STRING("serif"));
+}
+
+gfxFontFamily*
+gfxFcPlatformFontList::GetDefaultFontForPlatform(const gfxFontStyle* aStyle)
+{
+    // Get the default font by using a fake name to retrieve the first
+    // scalable font that fontconfig suggests for the given language.
+    PrefFontList* prefFonts =
+        FindGenericFamilies(NS_LITERAL_STRING("-moz-default"), aStyle->language);
+    NS_ASSERTION(prefFonts, "null list of generic fonts");
+    if (prefFonts && !prefFonts->IsEmpty()) {
+        return (*prefFonts)[0];
+    }
+    return nullptr;
+}
+
+gfxFontEntry*
+gfxFcPlatformFontList::LookupLocalFont(const nsAString& aFontName,
+                                       uint16_t aWeight,
+                                       int16_t aStretch,
+                                       uint8_t aStyle)
+{
+    nsAutoString keyName(aFontName);
+    ToLowerCase(keyName);
+
+    // if name is not in the global list, done
+    FcPattern* fontPattern = mLocalNames.Get(keyName);
+    if (!fontPattern) {
+        return nullptr;
+    }
+
+    return new gfxFontconfigFontEntry(aFontName, fontPattern,
+                                      aWeight, aStretch, aStyle);
+}
+
+gfxFontEntry*
+gfxFcPlatformFontList::MakePlatformFont(const nsAString& aFontName,
+                                        uint16_t aWeight,
+                                        int16_t aStretch,
+                                        uint8_t aStyle,
+                                        const uint8_t* aFontData,
+                                        uint32_t aLength)
+{
+    FT_Face face;
+    FT_Error error =
+        FT_New_Memory_Face(gfxFcPlatformFontList::GetFTLibrary(),
+                           aFontData, aLength, 0, &face);
+    if (error != FT_Err_Ok) {
+        NS_Free((void*)aFontData);
+        return nullptr;
+    }
+    if (FT_Err_Ok != FT_Select_Charmap(face, FT_ENCODING_UNICODE)) {
+        FT_Done_Face(face);
+        NS_Free((void*)aFontData);
+        return nullptr;
+    }
+
+    return new gfxFontconfigFontEntry(aFontName, aWeight, aStretch,
+                                      aStyle, aFontData, face);
+}
+
+bool
+gfxFcPlatformFontList::FindAndAddFamilies(const nsAString& aFamily,
+                                          nsTArray<gfxFontFamily*>* aOutput,
+                                          gfxFontStyle* aStyle,
+                                          gfxFloat aDevToCssSize)
+{
+    nsAutoString familyName(aFamily);
+    ToLowerCase(familyName);
+    nsIAtom* language = (aStyle ? aStyle->language.get() : nullptr);
+
+    // deprecated generic names are explicitly converted to standard generics
+    bool isDeprecatedGeneric = false;
+    if (familyName.EqualsLiteral("sans") ||
+        familyName.EqualsLiteral("sans serif")) {
+        familyName.AssignLiteral("sans-serif");
+        isDeprecatedGeneric = true;
+    } else if (familyName.EqualsLiteral("mono")) {
+        familyName.AssignLiteral("monospace");
+        isDeprecatedGeneric = true;
+    }
+
+    // fontconfig generics? use fontconfig to determine the family for lang
+    if (isDeprecatedGeneric ||
+        mozilla::FontFamilyName::Convert(familyName).IsGeneric()) {
+        PrefFontList* prefFonts = FindGenericFamilies(familyName, language);
+        if (prefFonts && !prefFonts->IsEmpty()) {
+            aOutput->AppendElements(*prefFonts);
+            return true;
+        }
+        return false;
+    }
+
+    // fontconfig allows conditional substitutions in such a way that it's
+    // difficult to distinguish an explicit substitution from other suggested
+    // choices. To sniff out explicit substitutions, compare the substitutions
+    // for "font, -moz-sentinel" to "-moz-sentinel" to sniff out the
+    // substitutions
+    //
+    // Example:
+    //
+    //   serif ==> DejaVu Serif, ...
+    //   Helvetica, serif ==> Helvetica, TeX Gyre Heros, Nimbus Sans L, DejaVu Serif
+    //
+    // In this case fontconfig is including Tex Gyre Heros and
+    // Nimbus Sans L as alternatives for Helvetica.
+
+    // Because the FcConfigSubstitute call is quite expensive, we cache the
+    // actual font families found via this process. So check the cache first:
+    NS_ConvertUTF16toUTF8 familyToFind(familyName);
+    AutoTArray<gfxFontFamily*,10> cachedFamilies;
+    if (mFcSubstituteCache.Get(familyToFind, &cachedFamilies)) {
+        if (cachedFamilies.IsEmpty()) {
+            return false;
+        }
+        aOutput->AppendElements(cachedFamilies);
+        return true;
+    }
+
+    // It wasn't in the cache, so we need to ask fontconfig...
+    const FcChar8* kSentinelName = ToFcChar8Ptr("-moz-sentinel");
+    FcChar8* sentinelFirstFamily = nullptr;
+    nsAutoRef<FcPattern> sentinelSubst(FcPatternCreate());
+    FcPatternAddString(sentinelSubst, FC_FAMILY, kSentinelName);
+    FcConfigSubstitute(nullptr, sentinelSubst, FcMatchPattern);
+    FcPatternGetString(sentinelSubst, FC_FAMILY, 0, &sentinelFirstFamily);
+
+    // substitutions for font, -moz-sentinel pattern
+    nsAutoRef<FcPattern> fontWithSentinel(FcPatternCreate());
+    FcPatternAddString(fontWithSentinel, FC_FAMILY,
+                       ToFcChar8Ptr(familyToFind.get()));
+    FcPatternAddString(fontWithSentinel, FC_FAMILY, kSentinelName);
+    FcConfigSubstitute(nullptr, fontWithSentinel, FcMatchPattern);
+
+    // Add all font family matches until reaching the sentinel.
+    FcChar8* substName = nullptr;
+    for (int i = 0;
+         FcPatternGetString(fontWithSentinel, FC_FAMILY,
+                            i, &substName) == FcResultMatch;
+         i++)
+    {
+        NS_ConvertUTF8toUTF16 subst(ToCharPtr(substName));
+        if (sentinelFirstFamily &&
+            FcStrCmp(substName, sentinelFirstFamily) == 0) {
+            break;
+        }
+        gfxPlatformFontList::FindAndAddFamilies(subst, &cachedFamilies);
+    }
+
+    // Cache the resulting list, so we don't have to do this again.
+    mFcSubstituteCache.Put(familyToFind, cachedFamilies);
+
+    if (cachedFamilies.IsEmpty()) {
+        return false;
+    }
+    aOutput->AppendElements(cachedFamilies);
+    return true;
+}
+
+bool
+gfxFcPlatformFontList::GetStandardFamilyName(const nsAString& aFontName,
+                                             nsAString& aFamilyName)
+{
+    aFamilyName.Truncate();
+
+    // The fontconfig list of fonts includes generic family names in the
+    // font list. For these, just use the generic name.
+    if (aFontName.EqualsLiteral("serif") ||
+        aFontName.EqualsLiteral("sans-serif") ||
+        aFontName.EqualsLiteral("monospace")) {
+        aFamilyName.Assign(aFontName);
+        return true;
+    }
+
+    nsAutoRef<FcPattern> pat(FcPatternCreate());
+    if (!pat) {
+        return true;
+    }
+
+    nsAutoRef<FcObjectSet> os(FcObjectSetBuild(FC_FAMILY, nullptr));
+    if (!os) {
+        return true;
+    }
+
+    // ignore size-specific fonts
+    FcPatternAddBool(pat, FC_SCALABLE, FcTrue);
+
+    // add the family name to the pattern
+    NS_ConvertUTF16toUTF8 familyName(aFontName);
+    FcPatternAddString(pat, FC_FAMILY, ToFcChar8Ptr(familyName.get()));
+
+    nsAutoRef<FcFontSet> givenFS(FcFontList(nullptr, pat, os));
+    if (!givenFS) {
+        return true;
+    }
+
+    // See if there is a font face with first family equal to the given family
+    // (needs to be in sync with names coming from GetFontList())
+    nsTArray<nsCString> candidates;
+    for (int i = 0; i < givenFS->nfont; i++) {
+        char* firstFamily;
+
+        if (FcPatternGetString(givenFS->fonts[i], FC_FAMILY, 0,
+                               (FcChar8 **) &firstFamily) != FcResultMatch)
+        {
+            continue;
+        }
+
+        nsDependentCString first(firstFamily);
+        if (!candidates.Contains(first)) {
+            candidates.AppendElement(first);
+
+            if (familyName.Equals(first)) {
+                aFamilyName.Assign(aFontName);
+                return true;
+            }
+        }
+    }
+
+    // Because fontconfig conflates different family name types, need to
+    // double check that the candidate name is not simply a different
+    // name type. For example, if a font with nameID=16 "Minion Pro" and
+    // nameID=21 "Minion Pro Caption" exists, calling FcFontList with
+    // family="Minion Pro" will return a set of patterns some of which
+    // will have a first family of "Minion Pro Caption". Ignore these
+    // patterns and use the first candidate that maps to a font set with
+    // the same number of faces and an identical set of patterns.
+    for (uint32_t j = 0; j < candidates.Length(); ++j) {
+        FcPatternDel(pat, FC_FAMILY);
+        FcPatternAddString(pat, FC_FAMILY, (FcChar8 *)candidates[j].get());
+
+        nsAutoRef<FcFontSet> candidateFS(FcFontList(nullptr, pat, os));
+        if (!candidateFS) {
+            return true;
+        }
+
+        if (candidateFS->nfont != givenFS->nfont) {
+            continue;
+        }
+
+        bool equal = true;
+        for (int i = 0; i < givenFS->nfont; ++i) {
+            if (!FcPatternEqual(candidateFS->fonts[i], givenFS->fonts[i])) {
+                equal = false;
+                break;
+            }
+        }
+        if (equal) {
+            AppendUTF8toUTF16(candidates[j], aFamilyName);
+            return true;
+        }
+    }
+
+    // didn't find localized name, leave family name blank
+    return true;
+}
+
+static const char kFontNamePrefix[] = "font.name.";
+
+void
+gfxFcPlatformFontList::AddGenericFonts(mozilla::FontFamilyType aGenericType,
+                                       nsIAtom* aLanguage,
+                                       nsTArray<gfxFontFamily*>& aFamilyList)
+{
+    bool usePrefFontList = false;
+
+    // treat -moz-fixed as monospace
+    if (aGenericType == eFamily_moz_fixed) {
+        aGenericType = eFamily_monospace;
+    }
+
+    const char* generic = GetGenericName(aGenericType);
+    NS_ASSERTION(generic, "weird generic font type");
+    if (!generic) {
+        return;
+    }
+
+    // By default, most font prefs on Linux map to "use fontconfig"
+    // keywords. So only need to explicitly lookup font pref if
+    // non-default settings exist
+    NS_ConvertASCIItoUTF16 genericToLookup(generic);
+    if ((!mAlwaysUseFontconfigGenerics && aLanguage) ||
+        aLanguage == nsGkAtoms::x_math) {
+        nsIAtom* langGroup = GetLangGroup(aLanguage);
+        nsAutoCString langGroupStr;
+        if (langGroup) {
+            langGroup->ToUTF8String(langGroupStr);
+        }
+        nsAutoCString prefFontName(kFontNamePrefix);
+        prefFontName.Append(generic);
+        prefFontName.Append('.');
+        prefFontName.Append(langGroupStr);
+        nsAdoptingString fontlistValue = Preferences::GetString(prefFontName.get());
+        if (fontlistValue) {
+            if (!fontlistValue.EqualsLiteral("serif") &&
+                !fontlistValue.EqualsLiteral("sans-serif") &&
+                !fontlistValue.EqualsLiteral("monospace")) {
+                usePrefFontList = true;
+            } else {
+                // serif, sans-serif or monospace was specified
+                genericToLookup.Assign(fontlistValue);
+            }
+        }
+    }
+
+    // when pref fonts exist, use standard pref font lookup
+    if (usePrefFontList) {
+        return gfxPlatformFontList::AddGenericFonts(aGenericType,
+                                                    aLanguage,
+                                                    aFamilyList);
+    }
+
+    PrefFontList* prefFonts = FindGenericFamilies(genericToLookup, aLanguage);
+    NS_ASSERTION(prefFonts, "null generic font list");
+    aFamilyList.AppendElements(*prefFonts);
+}
+
+void
+gfxFcPlatformFontList::ClearLangGroupPrefFonts()
+{
+    ClearGenericMappings();
+    gfxPlatformFontList::ClearLangGroupPrefFonts();
+    mAlwaysUseFontconfigGenerics = PrefFontListsUseOnlyGenerics();
+}
+
+/* static */ FT_Library
+gfxFcPlatformFontList::GetFTLibrary()
+{
+    if (!sCairoFTLibrary) {
+        // Use cairo's FT_Library so that cairo takes care of shutdown of the
+        // FT_Library after it has destroyed its font_faces, and FT_Done_Face
+        // has been called on each FT_Face, at least until this bug is fixed:
+        // https://bugs.freedesktop.org/show_bug.cgi?id=18857
+        //
+        // Cairo keeps it's own FT_Library object for creating FT_Face
+        // instances, so use that. There's no simple API for accessing this
+        // so use the hacky method below of making a font and extracting
+        // the library pointer from that.
+
+        bool needsBold;
+        gfxFontStyle style;
+        gfxPlatformFontList* pfl = gfxPlatformFontList::PlatformFontList();
+        gfxFontFamily* family = pfl->GetDefaultFont(&style);
+        NS_ASSERTION(family, "couldn't find a default font family");
+        gfxFontEntry* fe = family->FindFontForStyle(style, needsBold);
+        if (!fe) {
+            return nullptr;
+        }
+        RefPtr<gfxFont> font = fe->FindOrMakeFont(&style, false);
+        if (!font) {
+            return nullptr;
+        }
+
+        gfxFT2FontBase* ft2Font = reinterpret_cast<gfxFT2FontBase*>(font.get());
+        gfxFT2LockedFace face(ft2Font);
+        if (!face.get()) {
+            return nullptr;
+        }
+
+        sCairoFTLibrary = face.get()->glyph->library;
+    }
+
+    return sCairoFTLibrary;
+}
+
+gfxPlatformFontList::PrefFontList*
+gfxFcPlatformFontList::FindGenericFamilies(const nsAString& aGeneric,
+                                           nsIAtom* aLanguage)
+{
+    // set up name
+    NS_ConvertUTF16toUTF8 generic(aGeneric);
+
+    nsAutoCString fcLang;
+    GetSampleLangForGroup(aLanguage, fcLang);
+    ToLowerCase(fcLang);
+
+    nsAutoCString genericLang(generic);
+    if (fcLang.Length() > 0) {
+        genericLang.Append('-');
+    }
+    genericLang.Append(fcLang);
+
+    // try to get the family from the cache
+    PrefFontList* prefFonts = mGenericMappings.Get(genericLang);
+    if (prefFonts) {
+        return prefFonts;
+    }
+
+    // if not found, ask fontconfig to pick the appropriate font
+    nsAutoRef<FcPattern> genericPattern(FcPatternCreate());
+    FcPatternAddString(genericPattern, FC_FAMILY,
+                       ToFcChar8Ptr(generic.get()));
+
+    // -- prefer scalable fonts
+    FcPatternAddBool(genericPattern, FC_SCALABLE, FcTrue);
+
+    // -- add the lang to the pattern
+    if (!fcLang.IsEmpty()) {
+        FcPatternAddString(genericPattern, FC_LANG,
+                           ToFcChar8Ptr(fcLang.get()));
+    }
+
+    // -- perform substitutions
+    FcConfigSubstitute(nullptr, genericPattern, FcMatchPattern);
+    FcDefaultSubstitute(genericPattern);
+
+    // -- sort to get the closest matches
+    FcResult result;
+    nsAutoRef<FcFontSet> faces(FcFontSort(nullptr, genericPattern, FcFalse,
+                                          nullptr, &result));
+
+    if (!faces) {
+      return nullptr;
+    }
+
+    // -- select the fonts to be used for the generic
+    prefFonts = new PrefFontList; // can be empty but in practice won't happen
+    uint32_t limit = gfxPlatformGtk::GetPlatform()->MaxGenericSubstitions();
+    bool foundFontWithLang = false;
+    for (int i = 0; i < faces->nfont; i++) {
+        FcPattern* font = faces->fonts[i];
+        FcChar8* mappedGeneric = nullptr;
+
+        // not scalable? skip...
+        FcBool scalable;
+        if (FcPatternGetBool(font, FC_SCALABLE, 0, &scalable) != FcResultMatch ||
+            !scalable) {
+            continue;
+        }
+
+        FcPatternGetString(font, FC_FAMILY, 0, &mappedGeneric);
+        if (mappedGeneric) {
+            NS_ConvertUTF8toUTF16 mappedGenericName(ToCharPtr(mappedGeneric));
+            AutoTArray<gfxFontFamily*,1> genericFamilies;
+            if (gfxPlatformFontList::FindAndAddFamilies(mappedGenericName,
+                                                        &genericFamilies)) {
+                MOZ_ASSERT(genericFamilies.Length() == 1,
+                           "expected a single family");
+                if (!prefFonts->Contains(genericFamilies[0])) {
+                    prefFonts->AppendElement(genericFamilies[0]);
+                    bool foundLang =
+                        !fcLang.IsEmpty() &&
+                        PatternHasLang(font, ToFcChar8Ptr(fcLang.get()));
+                    foundFontWithLang = foundFontWithLang || foundLang;
+                    // check to see if the list is full
+                    if (prefFonts->Length() >= limit) {
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    // if no font in the list matches the lang, trim all but the first one
+    if (!prefFonts->IsEmpty() && !foundFontWithLang) {
+        prefFonts->TruncateLength(1);
+    }
+
+    mGenericMappings.Put(genericLang, prefFonts);
+    return prefFonts;
+}
+
+bool
+gfxFcPlatformFontList::PrefFontListsUseOnlyGenerics()
+{
+    bool prefFontsUseOnlyGenerics = true;
+    uint32_t count;
+    char** names;
+    nsresult rv = Preferences::GetRootBranch()->
+        GetChildList(kFontNamePrefix, &count, &names);
+    if (NS_SUCCEEDED(rv) && count) {
+        for (size_t i = 0; i < count; i++) {
+            // Check whether all font.name prefs map to generic keywords
+            // and that the pref name and keyword match.
+            //   Ex: font.name.serif.ar ==> "serif" (ok)
+            //   Ex: font.name.serif.ar ==> "monospace" (return false)
+            //   Ex: font.name.serif.ar ==> "DejaVu Serif" (return false)
+
+            nsDependentCString prefName(names[i] +
+                                        ArrayLength(kFontNamePrefix) - 1);
+            nsCCharSeparatedTokenizer tokenizer(prefName, '.');
+            const nsDependentCSubstring& generic = tokenizer.nextToken();
+            const nsDependentCSubstring& langGroup = tokenizer.nextToken();
+            nsAdoptingCString fontPrefValue = Preferences::GetCString(names[i]);
+
+            if (!langGroup.EqualsLiteral("x-math") &&
+                !generic.Equals(fontPrefValue)) {
+                prefFontsUseOnlyGenerics = false;
+                break;
+            }
+        }
+        NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(count, names);
+    }
+    return prefFontsUseOnlyGenerics;
+}
+
+/* static */ void
+gfxFcPlatformFontList::CheckFontUpdates(nsITimer *aTimer, void *aThis)
+{
+    // check for font updates
+    FcInitBringUptoDate();
+
+    // update fontlist if current config changed
+    gfxFcPlatformFontList *pfl = static_cast<gfxFcPlatformFontList*>(aThis);
+    FcConfig* current = FcConfigGetCurrent();
+    if (current != pfl->GetLastConfig()) {
+        pfl->UpdateFontList();
+        pfl->ForceGlobalReflow();
+    }
+}
+
+#ifdef MOZ_BUNDLED_FONTS
+void
+gfxFcPlatformFontList::ActivateBundledFonts()
+{
+    if (!mBundledFontsInitialized) {
+        mBundledFontsInitialized = true;
+        nsCOMPtr<nsIFile> localDir;
+        nsresult rv = NS_GetSpecialDirectory(NS_GRE_DIR, getter_AddRefs(localDir));
+        if (NS_FAILED(rv)) {
+            return;
+        }
+        if (NS_FAILED(localDir->Append(NS_LITERAL_STRING("fonts")))) {
+            return;
+        }
+        bool isDir;
+        if (NS_FAILED(localDir->IsDirectory(&isDir)) || !isDir) {
+            return;
+        }
+        if (NS_FAILED(localDir->GetNativePath(mBundledFontsPath))) {
+            return;
+        }
+    }
+    if (!mBundledFontsPath.IsEmpty()) {
+        FcConfigAppFontAddDir(nullptr, ToFcChar8Ptr(mBundledFontsPath.get()));
+    }
+}
+#endif
+
+#ifdef MOZ_WIDGET_GTK
+/***************************************************************************
+ *
+ * This function must be last in the file because it uses the system cairo
+ * library.  Above this point the cairo library used is the tree cairo if
+ * MOZ_TREE_CAIRO.
+ */
+
+#if MOZ_TREE_CAIRO
+// Tree cairo symbols have different names.  Disable their activation through
+// preprocessor macros.
+#undef cairo_ft_font_options_substitute
+
+// The system cairo functions are not declared because the include paths cause
+// the gdk headers to pick up the tree cairo.h.
+extern "C" {
+NS_VISIBILITY_DEFAULT void
+cairo_ft_font_options_substitute (const cairo_font_options_t *options,
+                                  FcPattern                  *pattern);
+}
+#endif
+
+static void
+ApplyGdkScreenFontOptions(FcPattern *aPattern)
+{
+    const cairo_font_options_t *options =
+        gdk_screen_get_font_options(gdk_screen_get_default());
+
+    cairo_ft_font_options_substitute(options, aPattern);
+}
+
+#endif // MOZ_WIDGET_GTK
diff -rupN a/gfx/thebes/gfxPlatformGtk.cpp b/gfx/thebes/gfxPlatformGtk.cpp
--- a/gfx/thebes/gfxPlatformGtk.cpp	2016-11-14 11:12:22.000000000 -0500
+++ b/gfx/thebes/gfxPlatformGtk.cpp	2017-03-07 23:40:34.290635643 -0500
@@ -55,6 +55,10 @@
 
 #endif /* MOZ_X11 */
 
+#if defined(GDK_WINDOWING_WAYLAND)
+#include <gdk/gdkwayland.h>
+#endif
+
 #include <fontconfig/fontconfig.h>
 
 #include "nsMathUtils.h"
@@ -105,14 +109,20 @@ gfxPlatformGtk::gfxPlatformGtk()
     InitBackendPrefs(canvasMask, BackendType::CAIRO,
                      contentMask, BackendType::CAIRO);
 
-#ifdef MOZ_X11
-    if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
-      mCompositorDisplay = XOpenDisplay(nullptr);
-      MOZ_ASSERT(mCompositorDisplay, "Failed to create compositor display!");
-    } else {
-      mCompositorDisplay = nullptr;
+#if defined(MOZ_X11)
+    GdkDisplay *gdkDisplay = gdk_display_get_default();
+    mIsX11Display = GDK_IS_X11_DISPLAY(gdkDisplay);
+    if (mIsX11Display) {
+      mXCompositorDisplay = XOpenDisplay(nullptr);
+      MOZ_ASSERT(mXCompositorDisplay, "Failed to create compositor display!");
     }
-#endif // MOZ_X11
+#if defined(GDK_WINDOWING_WAYLAND)
+    else {
+      mWaylandCompositorDisplay = wl_display_connect(nullptr);
+      MOZ_ASSERT(mWaylandCompositorDisplay, "Failed to create compositor display!");
+    }
+#endif
+#endif // defined(MOZ_X11)
 }
 
 gfxPlatformGtk::~gfxPlatformGtk()
@@ -123,11 +133,16 @@ gfxPlatformGtk::~gfxPlatformGtk()
         gfxPangoFontGroup::Shutdown();
     }
 
-#ifdef MOZ_X11
-    if (mCompositorDisplay) {
-      XCloseDisplay(mCompositorDisplay);
+#if defined(MOZ_X11)
+    if (mIsX11Display) {
+       XCloseDisplay(mXCompositorDisplay);
+    }
+#if defined(GDK_WINDOWING_WAYLAND)
+    else {
+       wl_display_disconnect(mWaylandCompositorDisplay);
     }
-#endif // MOZ_X11
+#endif
+#endif
 }
 
 void
diff -rupN a/gfx/thebes/gfxPlatformGtk.h b/gfx/thebes/gfxPlatformGtk.h
--- a/gfx/thebes/gfxPlatformGtk.h	2016-11-14 11:12:22.000000000 -0500
+++ b/gfx/thebes/gfxPlatformGtk.h	2017-03-07 23:40:34.290635643 -0500
@@ -21,6 +21,12 @@ extern "C" {
 struct _XDisplay;
 typedef struct _XDisplay Display;
 #endif // MOZ_X11
+#ifndef GDK_WINDOWING_WAYLAND
+#define GDK_WINDOWING_WAYLAND 1
+#endif
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_display;
+#endif
 
 class gfxFontconfigUtils;
 
@@ -104,7 +110,7 @@ public:
     static int32_t GetDPI();
     static double  GetDPIScale();
 
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(GDK_WINDOWING_WAYLAND)
     virtual void GetAzureBackendInfo(mozilla::widget::InfoObject &aObj) override {
       gfxPlatform::GetAzureBackendInfo(aObj);
       aObj.DefineProperty("CairoUseXRender", mozilla::gfx::gfxVars::UseXRender());
@@ -146,9 +152,17 @@ public:
 #endif
 
 #ifdef MOZ_X11
-    Display* GetCompositorDisplay() {
-      return mCompositorDisplay;
+    bool     IsXDisplay() {
+      return mIsX11Display;
+    }
+    Display* GetXCompositorDisplay() {
+      return mXCompositorDisplay;
     }
+#ifdef GDK_WINDOWING_WAYLAND
+    wl_display* GetWaylandCompositorDisplay() {
+      return mWaylandCompositorDisplay;
+    }
+#endif
 #endif // MOZ_X11
 
 protected:
@@ -159,9 +173,12 @@ protected:
 private:
     virtual void GetPlatformCMSOutputProfile(void *&mem,
                                              size_t &size) override;
-
 #ifdef MOZ_X11
-    Display* mCompositorDisplay;
+    bool        mIsX11Display;
+    Display*    mXCompositorDisplay;
+#ifdef GDK_WINDOWING_WAYLAND
+    wl_display* mWaylandCompositorDisplay;
+#endif
 #endif
 
     // xxx - this will be removed once the new fontconfig platform font list
diff -rupN a/.mozconfig b/.mozconfig
--- a/.mozconfig	1969-12-31 19:00:00.000000000 -0500
+++ b/.mozconfig	2017-03-07 23:43:20.977644571 -0500
@@ -0,0 +1,18 @@
+. $topsrcdir/browser/config/mozconfig
+
+ac_add_options --enable-default-toolkit=cairo-gtk3
+
+mk_add_options BUILD_OFFICIAL=1
+mk_add_options MOZILLA_OFFICIAL=1
+mk_add_options MOZ_OBJDIR=@TOPSRCDIR@/objdir
+mk_add_options AUTOCLOBBER=1
+
+ac_add_options --disable-crashreporter
+ac_add_options --without-system-nspr
+ac_add_options --without-system-nss
+
+ac_add_options --enable-debug
+ac_add_options --disable-optimize
+
+ac_add_options --enable-release
+ac_add_options --disable-tests
diff -rupN a/toolkit/library/moz.build b/toolkit/library/moz.build
--- a/toolkit/library/moz.build	2017-02-10 19:39:16.000000000 -0500
+++ b/toolkit/library/moz.build	2017-03-07 23:40:34.290635643 -0500
@@ -313,6 +313,9 @@ if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']
     OS_LIBS += [
         'gthread-2.0',
     ]
+    OS_LIBS += [
+        'wayland-client',
+    ]
 
 if CONFIG['MOZ_ENABLE_STARTUP_NOTIFICATION']:
     OS_LIBS += CONFIG['MOZ_STARTUP_NOTIFICATION_LIBS']
diff -rupN a/toolkit/library/moz.build.orig b/toolkit/library/moz.build.orig
--- a/toolkit/library/moz.build.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/toolkit/library/moz.build.orig	2017-02-10 19:39:16.000000000 -0500
@@ -0,0 +1,402 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+@template
+def Libxul_defines():
+    LIBRARY_DEFINES['MOZILLA_INTERNAL_API'] = True
+    LIBRARY_DEFINES['IMPL_LIBXUL'] = True
+    if not CONFIG['JS_SHARED_LIBRARY']:
+        LIBRARY_DEFINES['STATIC_EXPORTABLE_JS_API'] = True
+
+@template
+def Libxul(name):
+    if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('cocoa', 'uikit'):
+        # This is going to be a framework named "XUL", not an ordinary library named
+        # "libxul.dylib"
+        GeckoFramework(name, linkage=None)
+        SHARED_LIBRARY_NAME = 'XUL'
+    else:
+        GeckoSharedLibrary(name, linkage=None)
+        SHARED_LIBRARY_NAME = 'xul'
+
+    DELAYLOAD_DLLS += [
+        'comdlg32.dll',
+        'dbghelp.dll',
+        'netapi32.dll',
+        'PowrProf.dll',
+        'psapi.dll',
+        'rasapi32.dll',
+        'rasdlg.dll',
+        'secur32.dll',
+        'wininet.dll',
+        'winspool.drv'
+    ]
+
+    if CONFIG['ACCESSIBILITY']:
+        DELAYLOAD_DLLS += ['oleacc.dll']
+
+    if CONFIG['MOZ_WEBRTC']:
+        DELAYLOAD_DLLS += ['msdmo.dll']
+
+    if CONFIG['OS_ARCH'] == 'WINNT':
+        DELAYLOAD_DLLS += [
+            'api-ms-win-core-winrt-l1-1-0.dll',
+            'api-ms-win-core-winrt-string-l1-1-0.dll',
+        ]
+
+    if CONFIG['OS_ARCH'] == 'WINNT' and not CONFIG['GNU_CC']:
+        LOCAL_INCLUDES += [
+            '/widget/windows',
+            '/xpcom/base',
+        ]
+        # config/version.mk says $(srcdir)/$(RCINCLUDE), and this needs to
+        # be valid in both toolkit/library and toolkit/library/gtest.
+        # Eventually, the make backend would do its own path canonicalization
+        # and config/version.mk would lift the $(srcdir)
+        RCINCLUDE = '$(DEPTH)/toolkit/library/xulrunner.rc'
+
+    Libxul_defines()
+
+    if CONFIG['MOZ_NEEDS_LIBATOMIC']:
+        OS_LIBS += ['atomic']
+
+    # This option should go away in bug 1290972, but we need to wait until
+    # Rust 1.12 has been released.
+    if CONFIG['MOZ_RUST'] and CONFIG['OS_ARCH'] == 'Darwin':
+        LDFLAGS += ['-Wl,-no_compact_unwind']
+
+Libxul('xul')
+
+SDK_LIBRARY = True
+
+FORCE_STATIC_LIB = True
+
+STATIC_LIBRARY_NAME = 'xul_s'
+
+SOURCES += [
+    'StaticXULComponentsStart.cpp',
+]
+
+# This, combined with the fact the file is first, makes the start pointer
+# it contains first in Windows PGO builds.
+SOURCES['StaticXULComponentsStart.cpp'].no_pgo = True
+
+# Don't let LTO reorder StaticXULComponentsStart.o.
+if '-flto' in CONFIG['OS_CXXFLAGS']:
+    SOURCES['StaticXULComponentsStart.cpp'].flags += ['-fno-lto']
+
+if CONFIG['OS_ARCH'] == 'WINNT':
+    SOURCES += [
+        'nsDllMain.cpp',
+    ]
+
+LOCAL_INCLUDES += [
+    '/config',
+    # need widget/windows for resource.h (included from widget.rc)
+    '/widget/windows',
+]
+
+if CONFIG['OS_ARCH'] == 'WINNT' and not CONFIG['GNU_CC']:
+    LOCAL_INCLUDES += [
+        '/xpcom/base',
+    ]
+
+DIRS += ['gtest']
+
+if CONFIG['OS_ARCH'] == 'WINNT':
+  DIRS += ['dummydll']
+
+# js needs to come after xul for now, because it is an archive and its content
+# is discarded when it comes first.
+USE_LIBS += [
+    'js',
+]
+
+USE_LIBS += [
+    'gkmedias',
+    'lgpllibs',
+    'nspr',
+    'nss',
+    'psshparser',
+    'sqlite',
+    'zlib',
+]
+
+if CONFIG['USE_ICU']:
+    USE_LIBS += [
+        'icu',
+    ]
+
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
+    USE_LIBS += [
+        'mozgtk_stub',
+    ]
+
+if CONFIG['MOZ_JPROF']:
+    USE_LIBS += [
+        'jprof',
+    ]
+
+if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT'] or \
+        CONFIG['MOZ_TREE_FREETYPE']:
+    USE_LIBS += [
+        'freetype',
+    ]
+
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'cocoa':
+    CXXFLAGS += CONFIG['TK_CFLAGS']
+
+if CONFIG['MOZ_WEBRTC']:
+    if CONFIG['OS_TARGET'] == 'WINNT':
+        OS_LIBS += [
+            'secur32',
+            'iphlpapi',
+            'strmiids',
+            'dmoguids',
+            'wmcodecdspuuid',
+            'amstrmid',
+            'msdmo',
+            'wininet',
+        ]
+
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'cocoa':
+    OS_LIBS += [
+        '-framework OpenGL',
+        '-framework SystemConfiguration',
+        '-framework AVFoundation',
+        '-framework CoreMedia',
+        '-framework IOKit',
+        '-F%s' % CONFIG['MACOS_PRIVATE_FRAMEWORKS_DIR'],
+        '-framework CoreUI',
+        '-framework CoreSymbolication',
+        'cups',
+    ]
+
+if CONFIG['MOZ_WMF']:
+    OS_LIBS += [
+        'mfuuid',
+        'wmcodecdspuuid',
+        'strmiids',
+    ]
+
+if CONFIG['MOZ_DIRECTSHOW']:
+    OS_LIBS += [
+        'dmoguids',
+        'wmcodecdspuuid',
+        'strmiids',
+        'msdmo',
+    ]
+
+if CONFIG['OS_ARCH'] == 'FreeBSD':
+    OS_LIBS += [
+        'util',
+    ]
+
+if CONFIG['OS_ARCH'] == 'WINNT':
+    OS_LIBS += [
+        'crypt32',
+        'shell32',
+        'ole32',
+        'version',
+        'winspool',
+    ]
+
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gonk':
+    OS_LIBS += [
+        'dbus',
+    ]
+
+if CONFIG['OS_ARCH'] == 'Linux' and CONFIG['OS_TARGET'] != 'Android':
+    OS_LIBS += [
+        'rt',
+    ]
+
+OS_LIBS += CONFIG['MOZ_CAIRO_OSLIBS']
+OS_LIBS += CONFIG['MOZ_WEBRTC_X11_LIBS']
+
+if CONFIG['SERVO_TARGET_DIR']:
+    if CONFIG['_MSC_VER']:
+        OS_LIBS += ['%s/geckoservo' % CONFIG['SERVO_TARGET_DIR']]
+    else:
+        OS_LIBS += ['-L%s' % CONFIG['SERVO_TARGET_DIR'], '-lgeckoservo']
+
+if CONFIG['MOZ_SYSTEM_JPEG']:
+    OS_LIBS += CONFIG['MOZ_JPEG_LIBS']
+
+if CONFIG['MOZ_SYSTEM_PNG']:
+    OS_LIBS += CONFIG['MOZ_PNG_LIBS']
+
+if CONFIG['MOZ_SYSTEM_HUNSPELL']:
+    OS_LIBS += CONFIG['MOZ_HUNSPELL_LIBS']
+
+if CONFIG['MOZ_SYSTEM_LIBEVENT']:
+    OS_LIBS += CONFIG['MOZ_LIBEVENT_LIBS']
+
+if CONFIG['MOZ_SYSTEM_LIBVPX']:
+    OS_LIBS += CONFIG['MOZ_LIBVPX_LIBS']
+
+if not CONFIG['MOZ_TREE_PIXMAN']:
+    OS_LIBS += CONFIG['MOZ_PIXMAN_LIBS']
+
+if CONFIG['MOZ_ALSA']:
+    OS_LIBS += CONFIG['MOZ_ALSA_LIBS']
+
+if CONFIG['HAVE_CLOCK_MONOTONIC']:
+    OS_LIBS += CONFIG['REALTIME_LIBS']
+
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'android':
+    OS_LIBS += [
+        'GLESv2',
+    ]
+
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gonk':
+    OS_LIBS += [
+        'ui',
+        'media',
+        'hardware_legacy',
+        'hardware',
+        'utils',
+        'cutils',
+        'sysutils',
+        'camera_client',
+        'sensorservice',
+        'stagefright',
+        'stagefright_foundation',
+        'stagefright_omx',
+        'binder',
+        'gui',
+        'mtp',
+    ]
+
+    if int(CONFIG['ANDROID_VERSION']) >= 17:
+        OS_LIBS += [
+            'sync',
+        ]
+
+    if CONFIG['ANDROID_VERSION'] >= '16':
+        OS_LIBS += [
+            'mdnssd',
+        ]
+
+if 'rtsp' in CONFIG['NECKO_PROTOCOLS']:
+    OS_LIBS += [
+        'stagefright_foundation',
+    ]
+
+OS_LIBS += CONFIG['ICONV_LIBS']
+
+if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('cocoa', 'uikit'):
+    OS_LIBS += CONFIG['TK_LIBS']
+
+if CONFIG['OS_ARCH'] == 'OpenBSD':
+    OS_LIBS += [
+        'sndio',
+    ]
+
+if CONFIG['MOZ_ENABLE_DBUS']:
+    OS_LIBS += CONFIG['MOZ_DBUS_GLIB_LIBS']
+
+if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
+    if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk3':
+        OS_LIBS += [l for l in CONFIG['TK_LIBS']
+            if l not in ('-lgtk-3', '-lgdk-3')]
+    else:
+        OS_LIBS += CONFIG['TK_LIBS']
+    OS_LIBS += CONFIG['XLDFLAGS']
+    OS_LIBS += CONFIG['XLIBS']
+    OS_LIBS += CONFIG['XEXT_LIBS']
+    OS_LIBS += CONFIG['MOZ_PANGO_LIBS']
+    OS_LIBS += CONFIG['XT_LIBS']
+    OS_LIBS += [
+        'gthread-2.0',
+    ]
+
+if CONFIG['MOZ_ENABLE_STARTUP_NOTIFICATION']:
+    OS_LIBS += CONFIG['MOZ_STARTUP_NOTIFICATION_LIBS']
+
+if CONFIG['MOZ_ENABLE_LIBPROXY']:
+    OS_LIBS += CONFIG['MOZ_LIBPROXY_LIBS']
+
+if CONFIG['OS_ARCH'] == 'SunOS':
+    OS_LIBS += [
+        'elf',
+    ]
+    if CONFIG['GNU_CC']:
+        OS_LIBS += [
+            'demangle',
+        ]
+
+if CONFIG['OS_ARCH'] == 'FreeBSD':
+    OS_LIBS += [
+        'util',
+    ]
+
+if CONFIG['OS_ARCH'] == 'WINNT':
+    OS_LIBS += [
+        'shell32',
+        'ole32',
+        'version',
+        'winspool',
+        'comdlg32',
+        'imm32',
+        'msimg32',
+        'netapi32',
+        'shlwapi',
+        'psapi',
+        'ws2_32',
+        'dbghelp',
+        'rasapi32',
+        'rasdlg',
+        'iphlpapi',
+        'uxtheme',
+        'setupapi',
+        'secur32',
+        'sensorsapi',
+        'portabledeviceguids',
+        'windowscodecs',
+        'wininet',
+        'wbemuuid',
+        'wintrust',
+        'wtsapi32',
+        'locationapi',
+        'sapi',
+        'dxguid',
+    ]
+    if CONFIG['ACCESSIBILITY']:
+        OS_LIBS += [
+            'oleacc',
+        ]
+
+if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'windows':
+    OS_LIBS += [
+        'usp10',
+        'oleaut32',
+    ]
+
+if CONFIG['COMPILE_ENVIRONMENT']:
+    if CONFIG['MOZ_WIDGET_TOOLKIT'] in ('cocoa', 'uikit'):
+        full_libname = SHARED_LIBRARY_NAME
+    else:
+        full_libname = '%s%s%s' % (
+            CONFIG['DLL_PREFIX'],
+            LIBRARY_NAME,
+            CONFIG['DLL_SUFFIX']
+        )
+    GENERATED_FILES += ['dependentlibs.list']
+    GENERATED_FILES['dependentlibs.list'].script = 'dependentlibs.py:gen_list'
+    GENERATED_FILES['dependentlibs.list'].inputs = [
+        '!%s' % full_libname,
+    ]
+    FINAL_TARGET_FILES += ['!dependentlibs.list']
+
+# This library needs to be last to make XPCOM module registration work.
+USE_LIBS += ['StaticXULComponentsEnd']
+
+# The above library needs to be last for C++ purposes.  This library,
+# however, is entirely composed of Rust code, and needs to come after
+# all the C++ code so any possible C++ -> Rust calls can be resolved.
+if CONFIG['MOZ_RUST']:
+    USE_LIBS += ['gkrust']
diff -rupN a/widget/gtk/moz.build b/widget/gtk/moz.build
--- a/widget/gtk/moz.build	2016-11-14 11:12:28.000000000 -0500
+++ b/widget/gtk/moz.build	2017-03-07 23:40:34.291635643 -0500
@@ -34,6 +34,7 @@ UNIFIED_SOURCES += [
     'nsSound.cpp',
     'nsToolkit.cpp',
     'nsWidgetFactory.cpp',
+    'os-compatibility.c',
     'WakeLockListener.cpp',
     'WidgetTraceEvent.cpp',
     'WidgetUtilsGtk.cpp',
@@ -74,6 +75,7 @@ if CONFIG['MOZ_X11']:
         'nsClipboard.cpp',
         'nsDragService.cpp',
         'WindowSurfaceProvider.cpp',
+        'WindowSurfaceWayland.cpp',
         'WindowSurfaceX11.cpp',
         'WindowSurfaceX11Image.cpp',
         'WindowSurfaceXRender.cpp',
diff -rupN a/widget/gtk/mozcontainer.c b/widget/gtk/mozcontainer.c
--- a/widget/gtk/mozcontainer.c	2016-05-12 13:05:12.000000000 -0400
+++ b/widget/gtk/mozcontainer.c	2017-03-07 23:43:01.905643549 -0500
@@ -7,12 +7,17 @@
 
 #include "mozcontainer.h"
 #include <gtk/gtk.h>
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
+
 #include <stdio.h>
+#include <string.h>
 
 #ifdef ACCESSIBILITY
 #include <atk/atk.h>
 #include "maiRedundantObjectFactory.h"
-#endif 
+#endif
 
 /* init methods */
 static void moz_container_class_init          (MozContainerClass *klass);
@@ -22,6 +27,9 @@ static void moz_container_init
 static void moz_container_map                 (GtkWidget         *widget);
 static void moz_container_unmap               (GtkWidget         *widget);
 static void moz_container_realize             (GtkWidget         *widget);
+#if defined(GDK_WINDOWING_WAYLAND)
+static void moz_container_unrealize           (GtkWidget         *widget);
+#endif
 static void moz_container_size_allocate       (GtkWidget         *widget,
                                                GtkAllocation     *allocation);
 
@@ -35,6 +43,8 @@ static void moz_container_forall      (G
 static void moz_container_add         (GtkContainer      *container,
                                         GtkWidget        *widget);
 
+static struct wl_event_queue *mQueue;
+
 typedef struct _MozContainerChild MozContainerChild;
 
 struct _MozContainerChild {
@@ -143,6 +153,81 @@ moz_container_move (MozContainer *contai
 
 /* static methods */
 
+#if defined(GDK_WINDOWING_WAYLAND)
+/* We have to recreate our wl_surfaces when GdkWindow is shown,
+ * otherwise Gdk resources may not finished 
+ * and gdk_wayland_window_get_wl_surface() fails.
+ */
+gboolean
+moz_container_map_wl_surface(MozContainer *container)
+{
+    GdkDisplay *display;
+    struct wl_compositor *compositor;
+    struct wl_surface *gtk_surface;
+    struct wl_region *region;
+    GdkWindow *window;
+    gint x, y;
+    
+    if (container->subsurface)
+      return TRUE;
+
+    window = gtk_widget_get_window(GTK_WIDGET(container));
+    gtk_surface = gdk_wayland_window_get_wl_surface(window);
+    if (!gtk_surface) {
+      // We requested the underlying wl_surface too early. 
+      return FALSE;
+    }
+
+    container->subsurface =
+      wl_subcompositor_get_subsurface (container->subcompositor,
+                                       container->surface,
+                                       gtk_surface);
+    wl_proxy_set_queue((struct wl_proxy *)container->subsurface, mQueue);
+    gdk_window_get_position(window, &x, &y);
+    wl_subsurface_set_position(container->subsurface, x, y);
+    wl_subsurface_set_desync(container->subsurface);
+
+    // Don't accept input on subsurface
+    display = gtk_widget_get_display(GTK_WIDGET (container));
+    compositor = gdk_wayland_display_get_wl_compositor(display);
+    region = wl_compositor_create_region(compositor);
+    wl_surface_set_input_region(container->surface, region);
+    wl_region_destroy(region);
+    return TRUE;
+}
+
+static void
+moz_container_unmap_surface(MozContainer *container)
+{
+    g_clear_pointer(&container->subsurface, wl_subsurface_destroy);
+}
+
+static void
+moz_container_create_surface(MozContainer *container)
+{
+    if (!mQueue) {
+      GdkDisplay *display = gtk_widget_get_display(GTK_WIDGET(container));
+      mQueue = wl_display_create_queue(gdk_wayland_display_get_wl_display(display));
+    }
+  
+    if (!container->surface) {
+        GdkDisplay *display;
+        struct wl_compositor *compositor;
+
+        display = gtk_widget_get_display(GTK_WIDGET (container));
+        compositor = gdk_wayland_display_get_wl_compositor(display);
+        container->surface = wl_compositor_create_surface(compositor);
+        wl_proxy_set_queue((struct wl_proxy *)container->surface, mQueue);
+    }
+}
+
+static void
+moz_container_delete_surface(MozContainer *container)
+{  
+    g_clear_pointer(&container->surface, wl_surface_destroy);
+}
+#endif
+
 void
 moz_container_class_init (MozContainerClass *klass)
 {
@@ -154,6 +239,9 @@ moz_container_class_init (MozContainerCl
     widget_class->map = moz_container_map;
     widget_class->unmap = moz_container_unmap;
     widget_class->realize = moz_container_realize;
+#if defined(GDK_WINDOWING_WAYLAND)
+    widget_class->unrealize = moz_container_unrealize;
+#endif
     widget_class->size_allocate = moz_container_size_allocate;
 
     container_class->remove = moz_container_remove;
@@ -161,12 +249,61 @@ moz_container_class_init (MozContainerCl
     container_class->add = moz_container_add;
 }
 
+#if defined(GDK_WINDOWING_WAYLAND)
+static void
+registry_handle_global (void *data,
+                        struct wl_registry *registry,
+                        uint32_t name,
+                        const char *interface,
+                        uint32_t version)
+{
+    MozContainer *container = data;
+    if(strcmp(interface, "wl_subcompositor") == 0) {
+        container->subcompositor = wl_registry_bind(registry,
+                                                    name,
+                                                    &wl_subcompositor_interface,
+                                                    1);
+    }
+}
+
+static void
+registry_handle_global_remove (void *data,
+                               struct wl_registry *registry,
+                               uint32_t name)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_handle_global,
+    registry_handle_global_remove
+};
+#endif
+
 void
 moz_container_init (MozContainer *container)
 {
     gtk_widget_set_can_focus(GTK_WIDGET(container), TRUE);
     gtk_container_set_resize_mode(GTK_CONTAINER(container), GTK_RESIZE_IMMEDIATE);
     gtk_widget_set_redraw_on_allocate(GTK_WIDGET(container), FALSE);
+
+#if defined(GDK_WINDOWING_WAYLAND)
+    {
+      GdkDisplay *gdk_display = gtk_widget_get_display(GTK_WIDGET(container));
+      if (GDK_IS_WAYLAND_DISPLAY (gdk_display)) {
+          struct wl_display *display;
+          struct wl_registry *registry;
+
+          display = gdk_wayland_display_get_wl_display(gdk_display);
+          if (!mQueue) {
+            mQueue = wl_display_create_queue(display);
+          }
+          registry = wl_display_get_registry(display);
+          wl_registry_add_listener(registry, &registry_listener, container);
+          wl_proxy_set_queue((struct wl_proxy *)registry, mQueue);
+          wl_display_roundtrip_queue(display, mQueue);
+        }
+    }
+#endif
 }
 
 void
@@ -184,7 +321,7 @@ moz_container_map (GtkWidget *widget)
     tmp_list = container->children;
     while (tmp_list) {
         tmp_child = ((MozContainerChild *)tmp_list->data)->widget;
-    
+
         if (gtk_widget_get_visible(tmp_child)) {
             if (!gtk_widget_get_mapped(tmp_child))
                 gtk_widget_map(tmp_child);
@@ -207,6 +344,13 @@ moz_container_unmap (GtkWidget *widget)
     if (gtk_widget_get_has_window (widget)) {
         gdk_window_hide (gtk_widget_get_window(widget));
     }
+#if defined(GDK_WINDOWING_WAYLAND)
+  /* Gdk/Wayland deletes underlying GdkWindow wl_surface on unmap event.
+   * Delete the wl_subsurface interface which
+   * keeps wl_surface object and it's available for reuse.
+   */
+    moz_container_unmap_surface(MOZ_CONTAINER(widget));
+#endif
 }
 
 void
@@ -221,6 +365,7 @@ moz_container_realize (GtkWidget *widget
         GdkWindowAttr attributes;
         gint attributes_mask = GDK_WA_VISUAL | GDK_WA_X | GDK_WA_Y;
         GtkAllocation allocation;
+        GtkWidget* parent_widget;
 
         gtk_widget_get_allocation (widget, &allocation);
         attributes.event_mask = gtk_widget_get_events (widget);
@@ -231,6 +376,15 @@ moz_container_realize (GtkWidget *widget
         attributes.wclass = GDK_INPUT_OUTPUT;
         attributes.visual = gtk_widget_get_visual (widget);
         attributes.window_type = GDK_WINDOW_CHILD;
+#if defined(GDK_WINDOWING_WAYLAND)
+/*
+        parent_widget = gtk_widget_get_parent(widget);
+        if (parent_widget &&
+            gtk_window_get_window_type(GTK_WINDOW(parent_widget)) == GTK_WINDOW_POPUP) {
+            attributes.window_type = GDK_WINDOW_SUBSURFACE;
+        }
+*/        
+#endif
 
 #if (MOZ_WIDGET_GTK == 2)
         attributes.colormap = gtk_widget_get_colormap (widget);
@@ -255,7 +409,20 @@ moz_container_realize (GtkWidget *widget
 #if (MOZ_WIDGET_GTK == 2)
     widget->style = gtk_style_attach (widget->style, widget->window);
 #endif
+#if defined(GDK_WINDOWING_WAYLAND)
+    moz_container_create_surface(MOZ_CONTAINER(widget));    
+#endif
+}
+
+#if defined(GDK_WINDOWING_WAYLAND)
+static void
+moz_container_unrealize (GtkWidget *widget)
+{
+  MozContainer* container = MOZ_CONTAINER(widget);
+  moz_container_unmap_surface(container);
+  moz_container_delete_surface(container);
 }
+#endif
 
 void
 moz_container_size_allocate (GtkWidget     *widget,
@@ -267,7 +434,7 @@ moz_container_size_allocate (GtkWidget
 
     g_return_if_fail (IS_MOZ_CONTAINER (widget));
 
-    /*  printf("moz_container_size_allocate %p %d %d %d %d\n",
+      /* printf("moz_container_size_allocate %p %d %d %d %d\n",
         (void *)widget,
         allocation->x,
         allocation->y,
@@ -306,6 +473,14 @@ moz_container_size_allocate (GtkWidget
                                allocation->width,
                                allocation->height);
     }
+
+#if defined(GDK_WINDOWING_WAYLAND)
+    if (container->subsurface) {        
+        gint x, y;
+        gdk_window_get_position(gtk_widget_get_window(widget), &x, &y);
+        wl_subsurface_set_position(container->subsurface, x, y);
+      }
+#endif
 }
 
 void
@@ -363,7 +538,7 @@ moz_container_forall (GtkContainer *cont
 {
     MozContainer *moz_container;
     GList *tmp_list;
-  
+
     g_return_if_fail (IS_MOZ_CONTAINER(container));
     g_return_if_fail (callback != NULL);
 
@@ -399,7 +574,7 @@ moz_container_get_child (MozContainer *c
     tmp_list = container->children;
     while (tmp_list) {
         MozContainerChild *child;
-    
+
         child = tmp_list->data;
         tmp_list = tmp_list->next;
 
@@ -410,9 +585,21 @@ moz_container_get_child (MozContainer *c
     return NULL;
 }
 
-static void 
+static void
 moz_container_add(GtkContainer *container, GtkWidget *widget)
 {
     moz_container_put(MOZ_CONTAINER(container), widget, 0, 0);
 }
 
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_surface*
+moz_container_get_wl_surface(MozContainer *container)
+{
+    return container->surface;
+}
+struct wl_event_queue*
+moz_container_get_wl_queue()
+{
+    return mQueue;
+}
+#endif
diff -rupN a/widget/gtk/mozcontainer.h b/widget/gtk/mozcontainer.h
--- a/widget/gtk/mozcontainer.h	2016-05-12 13:05:12.000000000 -0400
+++ b/widget/gtk/mozcontainer.h	2017-03-07 23:40:34.291635643 -0500
@@ -44,7 +44,7 @@ extern "C" {
  * gtk_widget_set_parent_window should be called on the child GtkWidget before
  * it is realized.
  */
- 
+
 #define MOZ_CONTAINER_TYPE            (moz_container_get_type())
 #define MOZ_CONTAINER(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), MOZ_CONTAINER_TYPE, MozContainer))
 #define MOZ_CONTAINER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), MOZ_CONTAINER_TYPE, MozContainerClass))
@@ -55,10 +55,25 @@ extern "C" {
 typedef struct _MozContainer      MozContainer;
 typedef struct _MozContainerClass MozContainerClass;
 
+/* Workaround for bug at wayland-util.h,
+ * present in wayland < 1.12
+ */
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_subcompositor;
+struct wl_surface;
+struct wl_subsurface;
+#endif
+
 struct _MozContainer
 {
     GtkContainer   container;
     GList         *children;
+
+#ifdef GDK_WINDOWING_WAYLAND
+    struct wl_subcompositor *subcompositor;
+    struct wl_surface       *surface;
+    struct wl_subsurface    *subsurface;
+#endif
 };
 
 struct _MozContainerClass
@@ -79,6 +94,12 @@ void       moz_container_move          (
                                         gint          width,
                                         gint          height);
 
+#ifdef GDK_WINDOWING_WAYLAND
+struct wl_surface * moz_container_get_wl_surface (MozContainer *container);
+gboolean            moz_container_map_wl_surface (MozContainer *container);
+struct wl_event_queue* moz_container_get_wl_queue();
+#endif
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff -rupN a/widget/gtk/mozgtk/mozgtk.c b/widget/gtk/mozgtk/mozgtk.c
--- a/widget/gtk/mozgtk/mozgtk.c	2017-02-01 11:16:32.000000000 -0500
+++ b/widget/gtk/mozgtk/mozgtk.c	2017-03-07 23:40:34.291635643 -0500
@@ -515,11 +515,19 @@ STUB(gdk_device_manager_get_client_point
 STUB(gdk_disable_multidevice)
 STUB(gdk_device_manager_list_devices)
 STUB(gdk_display_get_device_manager)
+STUB(gdk_display_get_default_seat)
 STUB(gdk_error_trap_pop_ignored)
 STUB(gdk_event_get_source_device)
+STUB(gdk_seat_grab)
+STUB(gdk_seat_ungrab)
 STUB(gdk_window_get_type)
 STUB(gdk_x11_window_get_xid)
 STUB(gdk_x11_display_get_type)
+STUB(gdk_wayland_window_get_wl_surface)
+STUB(gdk_wayland_window_set_use_custom_surface)
+STUB(gdk_wayland_display_get_wl_display)
+STUB(gdk_wayland_display_get_wl_compositor)
+STUB(gdk_wayland_display_get_type)
 STUB(gtk_box_new)
 STUB(gtk_cairo_should_draw_window)
 STUB(gtk_cairo_transform_to_window)
@@ -586,6 +594,7 @@ STUB(gtk_widget_path_iter_add_class)
 STUB(gtk_widget_path_new)
 STUB(gtk_widget_path_unref)
 STUB(gtk_widget_set_visual)
+STUB(gtk_widget_unregister_window)
 STUB(gtk_app_chooser_dialog_new_for_content_type)
 STUB(gtk_app_chooser_get_type)
 STUB(gtk_app_chooser_get_app_info)
diff -rupN a/widget/gtk/mozgtk/mozgtk.c.orig b/widget/gtk/mozgtk/mozgtk.c.orig
--- a/widget/gtk/mozgtk/mozgtk.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/widget/gtk/mozgtk/mozgtk.c.orig	2017-02-01 11:16:32.000000000 -0500
@@ -0,0 +1,634 @@
+#include "mozilla/Types.h"
+#include "mozilla/Assertions.h"
+
+#define STUB(symbol) MOZ_EXPORT void symbol (void) { MOZ_CRASH(); }
+
+#ifdef COMMON_SYMBOLS
+STUB(gdk_atom_intern)
+STUB(gdk_atom_name)
+STUB(gdk_beep)
+STUB(gdk_cairo_create)
+STUB(gdk_color_free)
+STUB(gdk_color_parse)
+STUB(gdk_cursor_new_for_display)
+STUB(gdk_cursor_new_from_name)
+STUB(gdk_cursor_new_from_pixbuf)
+STUB(gdk_display_close)
+STUB(gdk_display_get_default)
+STUB(gdk_display_get_default_screen)
+STUB(gdk_display_get_pointer)
+STUB(gdk_display_get_window_at_pointer)
+STUB(gdk_display_manager_get)
+STUB(gdk_display_manager_set_default_display)
+STUB(gdk_display_open)
+STUB(gdk_display_sync)
+STUB(gdk_display_warp_pointer)
+STUB(gdk_drag_context_get_actions)
+STUB(gdk_drag_context_get_dest_window)
+STUB(gdk_drag_context_list_targets)
+STUB(gdk_drag_status)
+STUB(gdk_error_trap_pop)
+STUB(gdk_error_trap_push)
+STUB(gdk_event_copy)
+STUB(gdk_event_free)
+STUB(gdk_event_get_axis)
+STUB(gdk_event_get_time)
+STUB(gdk_event_handler_set)
+STUB(gdk_event_peek)
+STUB(gdk_event_put)
+STUB(gdk_flush)
+STUB(gdk_get_default_root_window)
+STUB(gdk_get_display)
+STUB(gdk_get_display_arg_name)
+STUB(gdk_get_program_class)
+STUB(gdk_keymap_get_default)
+STUB(gdk_keymap_get_direction)
+STUB(gdk_keymap_get_entries_for_keyval)
+STUB(gdk_keymap_get_for_display)
+STUB(gdk_keymap_have_bidi_layouts)
+STUB(gdk_keymap_translate_keyboard_state)
+STUB(gdk_keyval_name)
+STUB(gdk_keyval_to_unicode)
+STUB(gdk_pango_context_get)
+STUB(gdk_pointer_grab)
+STUB(gdk_pointer_ungrab)
+STUB(gdk_property_get)
+STUB(gdk_screen_get_default)
+STUB(gdk_screen_get_display)
+STUB(gdk_screen_get_font_options)
+STUB(gdk_screen_get_height)
+STUB(gdk_screen_get_height_mm)
+STUB(gdk_screen_get_monitor_at_window)
+STUB(gdk_screen_get_monitor_geometry)
+STUB(gdk_screen_get_number)
+STUB(gdk_screen_get_resolution)
+STUB(gdk_screen_get_rgba_visual)
+STUB(gdk_screen_get_root_window)
+STUB(gdk_screen_get_system_visual)
+STUB(gdk_screen_get_width)
+STUB(gdk_screen_height)
+STUB(gdk_screen_is_composited)
+STUB(gdk_screen_width)
+STUB(gdk_unicode_to_keyval)
+STUB(gdk_visual_get_depth)
+STUB(gdk_visual_get_system)
+STUB(gdk_window_add_filter)
+STUB(gdk_window_begin_move_drag)
+STUB(gdk_window_begin_resize_drag)
+STUB(gdk_window_destroy)
+STUB(gdk_window_focus)
+STUB(gdk_window_get_children)
+STUB(gdk_window_get_display)
+STUB(gdk_window_get_events)
+STUB(gdk_window_get_geometry)
+STUB(gdk_window_get_height)
+STUB(gdk_window_get_origin)
+STUB(gdk_window_get_parent)
+STUB(gdk_window_get_position)
+STUB(gdk_window_get_root_origin)
+STUB(gdk_window_get_screen)
+STUB(gdk_window_get_state)
+STUB(gdk_window_get_toplevel)
+STUB(gdk_window_get_update_area)
+STUB(gdk_window_get_user_data)
+STUB(gdk_window_get_visual)
+STUB(gdk_window_get_width)
+STUB(gdk_window_hide)
+STUB(gdk_window_input_shape_combine_region)
+STUB(gdk_window_invalidate_rect)
+STUB(gdk_window_invalidate_region)
+STUB(gdk_window_is_destroyed)
+STUB(gdk_window_is_visible)
+STUB(gdk_window_lower)
+STUB(gdk_window_move)
+STUB(gdk_window_move_resize)
+STUB(gdk_window_new)
+STUB(gdk_window_peek_children)
+STUB(gdk_window_process_updates)
+STUB(gdk_window_raise)
+STUB(gdk_window_remove_filter)
+STUB(gdk_window_reparent)
+STUB(gdk_window_resize)
+STUB(gdk_window_set_cursor)
+STUB(gdk_window_set_debug_updates)
+STUB(gdk_window_set_decorations)
+STUB(gdk_window_set_events)
+STUB(gdk_window_set_role)
+STUB(gdk_window_set_urgency_hint)
+STUB(gdk_window_set_user_data)
+STUB(gdk_window_shape_combine_region)
+STUB(gdk_window_show)
+STUB(gdk_window_show_unraised)
+STUB(gdk_x11_atom_to_xatom)
+STUB(gdk_x11_display_get_user_time)
+STUB(gdk_x11_display_get_xdisplay)
+STUB(gdk_x11_get_default_root_xwindow)
+STUB(gdk_x11_get_default_xdisplay)
+STUB(gdk_x11_get_server_time)
+STUB(gdk_x11_get_xatom_by_name)
+STUB(gdk_x11_get_xatom_by_name_for_display)
+STUB(gdk_x11_lookup_xdisplay)
+STUB(gdk_x11_screen_get_xscreen)
+STUB(gdk_x11_screen_supports_net_wm_hint)
+STUB(gdk_x11_visual_get_xvisual)
+STUB(gdk_x11_window_foreign_new_for_display)
+STUB(gdk_x11_window_lookup_for_display)
+STUB(gdk_x11_window_set_user_time)
+STUB(gdk_x11_xatom_to_atom)
+STUB(gdk_x11_set_sm_client_id)
+STUB(gtk_accel_label_new)
+STUB(gtk_alignment_get_type)
+STUB(gtk_alignment_new)
+STUB(gtk_alignment_set_padding)
+STUB(gtk_arrow_get_type)
+STUB(gtk_arrow_new)
+STUB(gtk_bindings_activate)
+STUB(gtk_bin_get_child)
+STUB(gtk_bin_get_type)
+STUB(gtk_border_free)
+STUB(gtk_box_get_type)
+STUB(gtk_box_pack_start)
+STUB(gtk_button_new)
+STUB(gtk_button_new_with_label)
+STUB(gtk_check_button_new_with_label)
+STUB(gtk_check_button_new_with_mnemonic)
+STUB(gtk_check_menu_item_new)
+STUB(gtk_check_version)
+STUB(gtk_clipboard_clear)
+STUB(gtk_clipboard_get)
+STUB(gtk_clipboard_request_contents)
+STUB(gtk_clipboard_request_text)
+STUB(gtk_clipboard_set_can_store)
+STUB(gtk_clipboard_set_with_data)
+STUB(gtk_clipboard_store)
+STUB(gtk_color_selection_dialog_get_color_selection)
+STUB(gtk_color_selection_dialog_get_type)
+STUB(gtk_color_selection_dialog_new)
+STUB(gtk_color_selection_get_current_color)
+STUB(gtk_color_selection_get_type)
+STUB(gtk_color_selection_set_current_color)
+STUB(gtk_combo_box_get_active)
+STUB(gtk_combo_box_get_type)
+STUB(gtk_combo_box_new)
+STUB(gtk_combo_box_new_with_entry)
+STUB(gtk_combo_box_set_active)
+STUB(gtk_combo_box_text_get_type)
+STUB(gtk_combo_box_text_new)
+STUB(gtk_container_add)
+STUB(gtk_container_forall)
+STUB(gtk_container_get_border_width)
+STUB(gtk_container_get_type)
+STUB(gtk_container_set_border_width)
+STUB(gtk_container_set_resize_mode)
+STUB(gtk_dialog_get_content_area)
+STUB(gtk_dialog_get_type)
+STUB(gtk_dialog_new_with_buttons)
+STUB(gtk_dialog_run)
+STUB(gtk_dialog_set_alternative_button_order)
+STUB(gtk_dialog_set_default_response)
+STUB(gtk_drag_begin)
+STUB(gtk_drag_dest_set)
+STUB(gtk_drag_finish)
+STUB(gtk_drag_get_data)
+STUB(gtk_drag_get_source_widget)
+STUB(gtk_drag_set_icon_pixbuf)
+STUB(gtk_drag_set_icon_widget)
+STUB(gtk_editable_get_type)
+STUB(gtk_editable_select_region)
+STUB(gtk_entry_get_text)
+STUB(gtk_entry_get_type)
+STUB(gtk_entry_new)
+STUB(gtk_entry_set_activates_default)
+STUB(gtk_entry_set_text)
+STUB(gtk_enumerate_printers)
+STUB(gtk_expander_new)
+STUB(gtk_file_chooser_add_filter)
+STUB(gtk_file_chooser_dialog_new)
+STUB(gtk_file_chooser_get_filenames)
+STUB(gtk_file_chooser_get_filter)
+STUB(gtk_file_chooser_get_preview_filename)
+STUB(gtk_file_chooser_get_type)
+STUB(gtk_file_chooser_get_uri)
+STUB(gtk_file_chooser_list_filters)
+STUB(gtk_file_chooser_set_current_folder)
+STUB(gtk_file_chooser_set_current_name)
+STUB(gtk_file_chooser_set_do_overwrite_confirmation)
+STUB(gtk_file_chooser_set_filename)
+STUB(gtk_file_chooser_set_filter)
+STUB(gtk_file_chooser_set_local_only)
+STUB(gtk_file_chooser_set_preview_widget)
+STUB(gtk_file_chooser_set_preview_widget_active)
+STUB(gtk_file_chooser_set_select_multiple)
+STUB(gtk_file_chooser_widget_get_type)
+STUB(gtk_file_filter_add_pattern)
+STUB(gtk_file_filter_new)
+STUB(gtk_file_filter_set_name)
+STUB(gtk_fixed_new)
+STUB(gtk_frame_new)
+STUB(gtk_grab_add)
+STUB(gtk_grab_remove)
+STUB(gtk_handle_box_new)
+STUB(gtk_hbox_new)
+STUB(gtk_icon_info_free)
+STUB(gtk_icon_info_load_icon)
+STUB(gtk_icon_set_add_source)
+STUB(gtk_icon_set_new)
+STUB(gtk_icon_set_render_icon)
+STUB(gtk_icon_set_unref)
+STUB(gtk_icon_size_lookup)
+STUB(gtk_icon_source_free)
+STUB(gtk_icon_source_new)
+STUB(gtk_icon_source_set_icon_name)
+STUB(gtk_icon_theme_add_builtin_icon)
+STUB(gtk_icon_theme_get_default)
+STUB(gtk_icon_theme_get_icon_sizes)
+STUB(gtk_icon_theme_lookup_by_gicon)
+STUB(gtk_icon_theme_lookup_icon)
+STUB(gtk_image_get_type)
+STUB(gtk_image_menu_item_new)
+STUB(gtk_image_new)
+STUB(gtk_image_new_from_stock)
+STUB(gtk_image_set_from_pixbuf)
+STUB(gtk_im_context_filter_keypress)
+STUB(gtk_im_context_focus_in)
+STUB(gtk_im_context_focus_out)
+STUB(gtk_im_context_get_preedit_string)
+STUB(gtk_im_context_reset)
+STUB(gtk_im_context_set_client_window)
+STUB(gtk_im_context_set_cursor_location)
+STUB(gtk_im_context_set_surrounding)
+STUB(gtk_im_context_simple_new)
+STUB(gtk_im_multicontext_get_type)
+STUB(gtk_im_multicontext_new)
+STUB(gtk_info_bar_get_type)
+STUB(gtk_info_bar_get_content_area)
+STUB(gtk_info_bar_new)
+STUB(gtk_init)
+STUB(gtk_invisible_new)
+STUB(gtk_key_snooper_install)
+STUB(gtk_key_snooper_remove)
+STUB(gtk_label_get_type)
+STUB(gtk_label_new)
+STUB(gtk_label_set_markup)
+STUB(gtk_link_button_new)
+STUB(gtk_main_do_event)
+STUB(gtk_main_iteration)
+STUB(gtk_menu_attach_to_widget)
+STUB(gtk_menu_bar_new)
+STUB(gtk_menu_get_type)
+STUB(gtk_menu_item_get_type)
+STUB(gtk_menu_item_new)
+STUB(gtk_menu_item_set_submenu)
+STUB(gtk_menu_new)
+STUB(gtk_menu_shell_append)
+STUB(gtk_menu_shell_get_type)
+STUB(gtk_misc_get_alignment)
+STUB(gtk_misc_get_padding)
+STUB(gtk_misc_get_type)
+STUB(gtk_misc_set_alignment)
+STUB(gtk_misc_set_padding)
+STUB(gtk_notebook_new)
+STUB(gtk_page_setup_copy)
+STUB(gtk_page_setup_get_bottom_margin)
+STUB(gtk_page_setup_get_left_margin)
+STUB(gtk_page_setup_get_orientation)
+STUB(gtk_page_setup_get_paper_size)
+STUB(gtk_page_setup_get_right_margin)
+STUB(gtk_page_setup_get_top_margin)
+STUB(gtk_page_setup_new)
+STUB(gtk_page_setup_set_bottom_margin)
+STUB(gtk_page_setup_set_left_margin)
+STUB(gtk_page_setup_set_orientation)
+STUB(gtk_page_setup_set_paper_size)
+STUB(gtk_page_setup_set_paper_size_and_default_margins)
+STUB(gtk_page_setup_set_right_margin)
+STUB(gtk_page_setup_set_top_margin)
+STUB(gtk_paper_size_free)
+STUB(gtk_paper_size_get_display_name)
+STUB(gtk_paper_size_get_height)
+STUB(gtk_paper_size_get_name)
+STUB(gtk_paper_size_get_width)
+STUB(gtk_paper_size_is_custom)
+STUB(gtk_paper_size_is_equal)
+STUB(gtk_paper_size_new)
+STUB(gtk_paper_size_new_custom)
+STUB(gtk_paper_size_set_size)
+STUB(gtk_parse_args)
+STUB(gtk_plug_get_socket_window)
+STUB(gtk_plug_get_type)
+STUB(gtk_printer_accepts_pdf)
+STUB(gtk_printer_get_name)
+STUB(gtk_printer_get_type)
+STUB(gtk_printer_is_default)
+STUB(gtk_print_job_new)
+STUB(gtk_print_job_send)
+STUB(gtk_print_job_set_source_file)
+STUB(gtk_print_run_page_setup_dialog)
+STUB(gtk_print_settings_copy)
+STUB(gtk_print_settings_foreach)
+STUB(gtk_print_settings_get)
+STUB(gtk_print_settings_get_duplex)
+STUB(gtk_print_settings_get_n_copies)
+STUB(gtk_print_settings_get_page_ranges)
+STUB(gtk_print_settings_get_paper_size)
+STUB(gtk_print_settings_get_printer)
+STUB(gtk_print_settings_get_print_pages)
+STUB(gtk_print_settings_get_resolution)
+STUB(gtk_print_settings_get_reverse)
+STUB(gtk_print_settings_get_scale)
+STUB(gtk_print_settings_get_use_color)
+STUB(gtk_print_settings_has_key)
+STUB(gtk_print_settings_new)
+STUB(gtk_print_settings_set)
+STUB(gtk_print_settings_set_duplex)
+STUB(gtk_print_settings_set_n_copies)
+STUB(gtk_print_settings_set_orientation)
+STUB(gtk_print_settings_set_page_ranges)
+STUB(gtk_print_settings_set_paper_size)
+STUB(gtk_print_settings_set_printer)
+STUB(gtk_print_settings_set_print_pages)
+STUB(gtk_print_settings_set_resolution)
+STUB(gtk_print_settings_set_reverse)
+STUB(gtk_print_settings_set_scale)
+STUB(gtk_print_settings_set_use_color)
+STUB(gtk_print_unix_dialog_add_custom_tab)
+STUB(gtk_print_unix_dialog_get_page_setup)
+STUB(gtk_print_unix_dialog_get_selected_printer)
+STUB(gtk_print_unix_dialog_get_settings)
+STUB(gtk_print_unix_dialog_get_type)
+STUB(gtk_print_unix_dialog_new)
+STUB(gtk_print_unix_dialog_set_manual_capabilities)
+STUB(gtk_print_unix_dialog_set_page_setup)
+STUB(gtk_print_unix_dialog_set_settings)
+STUB(gtk_progress_bar_new)
+STUB(gtk_propagate_event)
+STUB(gtk_radio_button_get_type)
+STUB(gtk_radio_button_new_with_label)
+STUB(gtk_radio_button_new_with_mnemonic)
+STUB(gtk_radio_button_new_with_mnemonic_from_widget)
+STUB(gtk_range_get_min_slider_size)
+STUB(gtk_range_get_type)
+STUB(gtk_recent_manager_add_item)
+STUB(gtk_recent_manager_get_default)
+STUB(gtk_scrollbar_get_type)
+STUB(gtk_scrolled_window_new)
+STUB(gtk_selection_data_copy)
+STUB(gtk_selection_data_free)
+STUB(gtk_selection_data_get_data)
+STUB(gtk_selection_data_get_length)
+STUB(gtk_selection_data_get_selection)
+STUB(gtk_selection_data_get_target)
+STUB(gtk_selection_data_get_targets)
+STUB(gtk_selection_data_set)
+STUB(gtk_selection_data_set_pixbuf)
+STUB(gtk_selection_data_set_text)
+STUB(gtk_selection_data_targets_include_text)
+STUB(gtk_separator_get_type)
+STUB(gtk_separator_menu_item_new)
+STUB(gtk_separator_tool_item_new)
+STUB(gtk_settings_get_default)
+STUB(gtk_settings_get_for_screen)
+STUB(gtk_socket_add_id)
+STUB(gtk_socket_get_id)
+STUB(gtk_socket_get_type)
+STUB(gtk_socket_get_plug_window)
+STUB(gtk_socket_new)
+STUB(gtk_spin_button_new)
+STUB(gtk_statusbar_new)
+STUB(gtk_style_lookup_icon_set)
+STUB(gtk_table_attach)
+STUB(gtk_table_get_type)
+STUB(gtk_table_new)
+STUB(gtk_target_list_add)
+STUB(gtk_target_list_add_image_targets)
+STUB(gtk_target_list_new)
+STUB(gtk_target_list_unref)
+STUB(gtk_targets_include_image)
+STUB(gtk_target_table_free)
+STUB(gtk_target_table_new_from_list)
+STUB(gtk_text_view_new)
+STUB(gtk_toggle_button_get_active)
+STUB(gtk_toggle_button_get_type)
+STUB(gtk_toggle_button_new)
+STUB(gtk_toggle_button_set_active)
+STUB(gtk_toggle_button_set_inconsistent)
+STUB(gtk_toolbar_new)
+STUB(gtk_tooltip_get_type)
+STUB(gtk_tree_view_append_column)
+STUB(gtk_tree_view_column_new)
+STUB(gtk_tree_view_column_set_title)
+STUB(gtk_tree_view_get_type)
+STUB(gtk_tree_view_new)
+STUB(gtk_vbox_new)
+STUB(gtk_widget_add_events)
+STUB(gtk_widget_class_find_style_property)
+STUB(gtk_widget_destroy)
+STUB(gtk_widget_destroyed)
+STUB(gtk_widget_ensure_style)
+STUB(gtk_widget_event)
+STUB(gtk_widget_get_accessible)
+STUB(gtk_widget_get_allocation)
+STUB(gtk_widget_get_default_direction)
+STUB(gtk_widget_get_display)
+STUB(gtk_widget_get_events)
+STUB(gtk_widget_get_has_window)
+STUB(gtk_widget_get_mapped)
+STUB(gtk_widget_get_parent)
+STUB(gtk_widget_get_parent_window)
+STUB(gtk_widget_get_realized)
+STUB(gtk_widget_get_screen)
+STUB(gtk_widget_get_settings)
+STUB(gtk_widget_get_style)
+STUB(gtk_widget_get_toplevel)
+STUB(gtk_widget_get_type)
+STUB(gtk_widget_get_visible)
+STUB(gtk_widget_get_visual)
+STUB(gtk_widget_get_window)
+STUB(gtk_widget_grab_focus)
+STUB(gtk_widget_has_focus)
+STUB(gtk_widget_has_grab)
+STUB(gtk_widget_hide)
+STUB(gtk_widget_is_focus)
+STUB(gtk_widget_is_toplevel)
+STUB(gtk_widget_map)
+STUB(gtk_widget_modify_bg)
+STUB(gtk_widget_realize)
+STUB(gtk_widget_reparent)
+STUB(gtk_widget_set_allocation)
+STUB(gtk_widget_set_app_paintable)
+STUB(gtk_window_set_auto_startup_notification)
+STUB(gtk_window_set_opacity)
+STUB(gtk_window_set_screen)
+STUB(gtk_widget_set_can_focus)
+STUB(gtk_widget_set_direction)
+STUB(gtk_widget_set_double_buffered)
+STUB(gtk_widget_set_has_window)
+STUB(gtk_widget_set_mapped)
+STUB(gtk_widget_set_name)
+STUB(gtk_widget_set_parent)
+STUB(gtk_widget_set_parent_window)
+STUB(gtk_widget_set_realized)
+STUB(gtk_widget_set_redraw_on_allocate)
+STUB(gtk_widget_set_sensitive)
+STUB(gtk_widget_set_window)
+STUB(gtk_widget_show)
+STUB(gtk_widget_show_all)
+STUB(gtk_widget_size_allocate)
+STUB(gtk_widget_style_get)
+STUB(gtk_widget_unparent)
+STUB(gtk_window_deiconify)
+STUB(gtk_window_fullscreen)
+STUB(gtk_window_get_group)
+STUB(gtk_window_get_transient_for)
+STUB(gtk_window_get_type)
+STUB(gtk_window_get_type_hint)
+STUB(gtk_window_get_window_type)
+STUB(gtk_window_group_add_window)
+STUB(gtk_window_group_get_current_grab)
+STUB(gtk_window_group_new)
+STUB(gtk_window_iconify)
+STUB(gtk_window_is_active)
+STUB(gtk_window_maximize)
+STUB(gtk_window_move)
+STUB(gtk_window_new)
+STUB(gtk_window_present_with_time)
+STUB(gtk_window_resize)
+STUB(gtk_window_set_accept_focus)
+STUB(gtk_window_set_decorated)
+STUB(gtk_window_set_deletable)
+STUB(gtk_window_set_destroy_with_parent)
+STUB(gtk_window_set_geometry_hints)
+STUB(gtk_window_set_icon_name)
+STUB(gtk_window_set_modal)
+STUB(gtk_window_set_skip_taskbar_hint)
+STUB(gtk_window_set_title)
+STUB(gtk_window_set_transient_for)
+STUB(gtk_window_set_type_hint)
+STUB(gtk_window_set_wmclass)
+STUB(gtk_window_unfullscreen)
+STUB(gtk_window_unmaximize)
+#endif
+
+#ifdef GTK3_SYMBOLS
+STUB(gdk_device_get_source)
+STUB(gdk_device_manager_get_client_pointer)
+STUB(gdk_disable_multidevice)
+STUB(gdk_device_manager_list_devices)
+STUB(gdk_display_get_device_manager)
+STUB(gdk_error_trap_pop_ignored)
+STUB(gdk_event_get_source_device)
+STUB(gdk_window_get_type)
+STUB(gdk_x11_window_get_xid)
+STUB(gdk_x11_display_get_type)
+STUB(gtk_box_new)
+STUB(gtk_cairo_should_draw_window)
+STUB(gtk_cairo_transform_to_window)
+STUB(gtk_combo_box_text_append)
+STUB(gtk_drag_set_icon_surface)
+STUB(gtk_get_major_version)
+STUB(gtk_get_micro_version)
+STUB(gtk_get_minor_version)
+STUB(gtk_menu_button_new)
+STUB(gtk_offscreen_window_new)
+STUB(gtk_paned_new)
+STUB(gtk_radio_menu_item_new)
+STUB(gtk_render_activity)
+STUB(gtk_render_arrow)
+STUB(gtk_render_background)
+STUB(gtk_render_check)
+STUB(gtk_render_expander)
+STUB(gtk_render_extension)
+STUB(gtk_render_focus)
+STUB(gtk_render_frame)
+STUB(gtk_render_frame_gap)
+STUB(gtk_render_handle)
+STUB(gtk_render_line)
+STUB(gtk_render_option)
+STUB(gtk_render_slider)
+STUB(gtk_scale_new)
+STUB(gtk_scrollbar_new)
+STUB(gtk_style_context_add_class)
+STUB(gtk_style_context_add_region)
+STUB(gtk_style_context_get)
+STUB(gtk_style_context_get_background_color)
+STUB(gtk_style_context_get_border)
+STUB(gtk_style_context_get_border_color)
+STUB(gtk_style_context_get_color)
+STUB(gtk_style_context_get_direction)
+STUB(gtk_style_context_get_margin)
+STUB(gtk_style_context_get_padding)
+STUB(gtk_style_context_get_path)
+STUB(gtk_style_context_get_property)
+STUB(gtk_style_context_get_state)
+STUB(gtk_style_context_get_style)
+STUB(gtk_style_context_has_class)
+STUB(gtk_style_context_invalidate)
+STUB(gtk_style_context_list_classes)
+STUB(gtk_style_context_new)
+STUB(gtk_style_context_remove_class)
+STUB(gtk_style_context_remove_region)
+STUB(gtk_style_context_restore)
+STUB(gtk_style_context_save)
+STUB(gtk_style_context_set_direction)
+STUB(gtk_style_context_set_path)
+STUB(gtk_style_context_set_parent)
+STUB(gtk_style_context_set_state)
+STUB(gtk_style_properties_lookup_property)
+STUB(gtk_tree_view_column_get_button)
+STUB(gtk_widget_get_preferred_size)
+STUB(gtk_widget_get_state_flags)
+STUB(gtk_widget_get_style_context)
+STUB(gtk_widget_path_append_for_widget)
+STUB(gtk_widget_path_append_type)
+STUB(gtk_widget_path_copy)
+STUB(gtk_widget_path_free)
+STUB(gtk_widget_path_iter_add_class)
+STUB(gtk_widget_path_new)
+STUB(gtk_widget_path_unref)
+STUB(gtk_widget_set_visual)
+STUB(gtk_app_chooser_dialog_new_for_content_type)
+STUB(gtk_app_chooser_get_type)
+STUB(gtk_app_chooser_get_app_info)
+STUB(gtk_app_chooser_dialog_get_type)
+STUB(gtk_app_chooser_dialog_set_heading)
+STUB(gtk_color_chooser_dialog_new)
+STUB(gtk_color_chooser_dialog_get_type)
+STUB(gtk_color_chooser_get_type)
+STUB(gtk_color_chooser_set_rgba)
+STUB(gtk_color_chooser_get_rgba)
+STUB(gtk_color_chooser_set_use_alpha)
+#endif
+
+#ifdef GTK2_SYMBOLS
+STUB(gdk_drawable_get_screen)
+STUB(gdk_rgb_get_colormap)
+STUB(gdk_rgb_get_visual)
+STUB(gdk_window_lookup)
+STUB(gdk_window_set_back_pixmap)
+STUB(gdk_x11_colormap_foreign_new)
+STUB(gdk_x11_colormap_get_xcolormap)
+STUB(gdk_x11_drawable_get_xdisplay)
+STUB(gdk_x11_drawable_get_xid)
+STUB(gdk_x11_window_get_drawable_impl)
+STUB(gdkx_visual_get)
+STUB(gtk_object_get_type)
+#endif
+
+#ifndef GTK3_SYMBOLS
+// Only define the following workaround when using GTK3, which we detect
+// by checking if GTK3 stubs are not provided.
+#include <X11/Xlib.h>
+// Bug 1271100
+// We need to trick system Cairo into not using the XShm extension due to
+// a race condition in it that results in frequent BadAccess errors. Cairo
+// relies upon XShmQueryExtension to initially detect if XShm is available.
+// So we define our own stub that always indicates XShm not being present.
+// mozgtk loads before libXext/libcairo and so this stub will take priority.
+// Our tree usage goes through xcb and remains unaffected by this.
+MOZ_EXPORT Bool
+XShmQueryExtension(Display* aDisplay)
+{
+  return False;
+}
+#endif
+
diff -rupN a/widget/gtk/nsNativeThemeGTK.cpp b/widget/gtk/nsNativeThemeGTK.cpp
--- a/widget/gtk/nsNativeThemeGTK.cpp	2017-01-23 11:13:56.000000000 -0500
+++ b/widget/gtk/nsNativeThemeGTK.cpp	2017-03-07 23:40:34.292635643 -0500
@@ -1212,7 +1212,11 @@ nsNativeThemeGTK::DrawWidgetBackground(n
 #endif
 
   if (!safeState) {
-    gdk_flush();
+    // gdk_flush() call from expose event crashes Gtk+ on Wayland
+    // (Gnome BZ #773307)
+    if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+      gdk_flush();
+    }
     gLastGdkError = gdk_error_trap_pop ();
 
     if (gLastGdkError) {
diff -rupN a/widget/gtk/nsNativeThemeGTK.cpp.orig b/widget/gtk/nsNativeThemeGTK.cpp.orig
--- a/widget/gtk/nsNativeThemeGTK.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/widget/gtk/nsNativeThemeGTK.cpp.orig	2017-01-23 11:13:56.000000000 -0500
@@ -0,0 +1,1994 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsNativeThemeGTK.h"
+#include "nsThemeConstants.h"
+#include "gtkdrawing.h"
+#include "nsScreenGtk.h"
+
+#include "gfx2DGlue.h"
+#include "nsIObserverService.h"
+#include "nsIServiceManager.h"
+#include "nsIFrame.h"
+#include "nsIPresShell.h"
+#include "nsIContent.h"
+#include "nsViewManager.h"
+#include "nsNameSpaceManager.h"
+#include "nsGfxCIID.h"
+#include "nsTransform2D.h"
+#include "nsMenuFrame.h"
+#include "prlink.h"
+#include "nsIDOMHTMLInputElement.h"
+#include "nsRenderingContext.h"
+#include "nsGkAtoms.h"
+#include "nsAttrValueInlines.h"
+
+#include "mozilla/EventStates.h"
+#include "mozilla/Services.h"
+
+#include <gdk/gdkprivate.h>
+#include <gtk/gtk.h>
+
+#include "gfxContext.h"
+#include "gfxPlatformGtk.h"
+#include "gfxGdkNativeRenderer.h"
+#include "mozilla/gfx/BorrowedContext.h"
+#include "mozilla/gfx/HelpersCairo.h"
+#include "mozilla/gfx/PathHelpers.h"
+
+#ifdef MOZ_X11
+#  ifdef CAIRO_HAS_XLIB_SURFACE
+#    include "cairo-xlib.h"
+#  endif
+#  ifdef CAIRO_HAS_XLIB_XRENDER_SURFACE
+#    include "cairo-xlib-xrender.h"
+#  endif
+#endif
+
+#include <algorithm>
+#include <dlfcn.h>
+
+using namespace mozilla;
+using namespace mozilla::gfx;
+
+NS_IMPL_ISUPPORTS_INHERITED(nsNativeThemeGTK, nsNativeTheme, nsITheme,
+                                                             nsIObserver)
+
+static int gLastGdkError;
+
+nsNativeThemeGTK::nsNativeThemeGTK()
+{
+  if (moz_gtk_init() != MOZ_GTK_SUCCESS) {
+    memset(mDisabledWidgetTypes, 0xff, sizeof(mDisabledWidgetTypes));
+    return;
+  }
+
+  // We have to call moz_gtk_shutdown before the event loop stops running.
+  nsCOMPtr<nsIObserverService> obsServ =
+    mozilla::services::GetObserverService();
+  obsServ->AddObserver(this, "xpcom-shutdown", false);
+
+  memset(mDisabledWidgetTypes, 0, sizeof(mDisabledWidgetTypes));
+  memset(mSafeWidgetStates, 0, sizeof(mSafeWidgetStates));
+}
+
+nsNativeThemeGTK::~nsNativeThemeGTK() {
+}
+
+NS_IMETHODIMP
+nsNativeThemeGTK::Observe(nsISupports *aSubject, const char *aTopic,
+                          const char16_t *aData)
+{
+  if (!nsCRT::strcmp(aTopic, "xpcom-shutdown")) {
+    moz_gtk_shutdown();
+  } else {
+    NS_NOTREACHED("unexpected topic");
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  return NS_OK;
+}
+
+void
+nsNativeThemeGTK::RefreshWidgetWindow(nsIFrame* aFrame)
+{
+  nsIPresShell *shell = GetPresShell(aFrame);
+  if (!shell)
+    return;
+
+  nsViewManager* vm = shell->GetViewManager();
+  if (!vm)
+    return;
+ 
+  vm->InvalidateAllViews();
+}
+
+
+static bool IsFrameContentNodeInNamespace(nsIFrame *aFrame, uint32_t aNamespace)
+{
+  nsIContent *content = aFrame ? aFrame->GetContent() : nullptr;
+  if (!content)
+    return false;
+  return content->IsInNamespace(aNamespace);
+}
+
+static bool IsWidgetTypeDisabled(uint8_t* aDisabledVector, uint8_t aWidgetType) {
+  return (aDisabledVector[aWidgetType >> 3] & (1 << (aWidgetType & 7))) != 0;
+}
+
+static void SetWidgetTypeDisabled(uint8_t* aDisabledVector, uint8_t aWidgetType) {
+  aDisabledVector[aWidgetType >> 3] |= (1 << (aWidgetType & 7));
+}
+
+static inline uint16_t
+GetWidgetStateKey(uint8_t aWidgetType, GtkWidgetState *aWidgetState)
+{
+  return (aWidgetState->active |
+          aWidgetState->focused << 1 |
+          aWidgetState->inHover << 2 |
+          aWidgetState->disabled << 3 |
+          aWidgetState->isDefault << 4 |
+          aWidgetType << 5);
+}
+
+static bool IsWidgetStateSafe(uint8_t* aSafeVector,
+                                uint8_t aWidgetType,
+                                GtkWidgetState *aWidgetState)
+{
+  uint8_t key = GetWidgetStateKey(aWidgetType, aWidgetState);
+  return (aSafeVector[key >> 3] & (1 << (key & 7))) != 0;
+}
+
+static void SetWidgetStateSafe(uint8_t *aSafeVector,
+                               uint8_t aWidgetType,
+                               GtkWidgetState *aWidgetState)
+{
+  uint8_t key = GetWidgetStateKey(aWidgetType, aWidgetState);
+  aSafeVector[key >> 3] |= (1 << (key & 7));
+}
+
+/* static */ GtkTextDirection
+nsNativeThemeGTK::GetTextDirection(nsIFrame* aFrame)
+{
+  // IsFrameRTL() treats vertical-rl modes as right-to-left (in addition to
+  // horizontal text with direction=RTL), rather than just considering the
+  // text direction.  GtkTextDirection does not have distinct values for
+  // vertical writing modes, but considering the block flow direction is
+  // important for resizers and scrollbar elements, at least.
+  return IsFrameRTL(aFrame) ? GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR;
+}
+
+// Returns positive for negative margins (otherwise 0).
+gint
+nsNativeThemeGTK::GetTabMarginPixels(nsIFrame* aFrame)
+{
+  nscoord margin =
+    IsBottomTab(aFrame) ? aFrame->GetUsedMargin().top
+    : aFrame->GetUsedMargin().bottom;
+
+  return std::min<gint>(MOZ_GTK_TAB_MARGIN_MASK,
+                std::max(0,
+                       aFrame->PresContext()->AppUnitsToDevPixels(-margin)));
+}
+
+static bool ShouldScrollbarButtonBeDisabled(int32_t aCurpos, int32_t aMaxpos,
+                                            uint8_t aWidgetType)
+{
+  return ((aCurpos == 0 && (aWidgetType == NS_THEME_SCROLLBARBUTTON_UP ||
+                            aWidgetType == NS_THEME_SCROLLBARBUTTON_LEFT))
+      || (aCurpos == aMaxpos && (aWidgetType == NS_THEME_SCROLLBARBUTTON_DOWN ||
+                                 aWidgetType == NS_THEME_SCROLLBARBUTTON_RIGHT)));
+}
+
+bool
+nsNativeThemeGTK::GetGtkWidgetAndState(uint8_t aWidgetType, nsIFrame* aFrame,
+                                       WidgetNodeType& aGtkWidgetType,
+                                       GtkWidgetState* aState,
+                                       gint* aWidgetFlags)
+{
+  if (aState) {
+    // For XUL checkboxes and radio buttons, the state of the parent
+    // determines our state.
+    nsIFrame *stateFrame = aFrame;
+    if (aFrame && ((aWidgetFlags && (aWidgetType == NS_THEME_CHECKBOX ||
+                                     aWidgetType == NS_THEME_RADIO)) ||
+                   aWidgetType == NS_THEME_CHECKBOX_LABEL ||
+                   aWidgetType == NS_THEME_RADIO_LABEL)) {
+
+      nsIAtom* atom = nullptr;
+      if (IsFrameContentNodeInNamespace(aFrame, kNameSpaceID_XUL)) {
+        if (aWidgetType == NS_THEME_CHECKBOX_LABEL ||
+            aWidgetType == NS_THEME_RADIO_LABEL) {
+          // Adjust stateFrame so GetContentState finds the correct state.
+          stateFrame = aFrame = aFrame->GetParent()->GetParent();
+        } else {
+          // GetContentState knows to look one frame up for radio/checkbox
+          // widgets, so don't adjust stateFrame here.
+          aFrame = aFrame->GetParent();
+        }
+        if (aWidgetFlags) {
+          if (!atom) {
+            atom = (aWidgetType == NS_THEME_CHECKBOX ||
+                    aWidgetType == NS_THEME_CHECKBOX_LABEL) ? nsGkAtoms::checked
+                                                            : nsGkAtoms::selected;
+          }
+          *aWidgetFlags = CheckBooleanAttr(aFrame, atom);
+        }
+      } else {
+        if (aWidgetFlags) {
+          nsCOMPtr<nsIDOMHTMLInputElement> inputElt(do_QueryInterface(aFrame->GetContent()));
+          *aWidgetFlags = 0;
+          if (inputElt) {
+            bool isHTMLChecked;
+            inputElt->GetChecked(&isHTMLChecked);
+            if (isHTMLChecked)
+              *aWidgetFlags |= MOZ_GTK_WIDGET_CHECKED;
+          }
+
+          if (GetIndeterminate(aFrame))
+            *aWidgetFlags |= MOZ_GTK_WIDGET_INCONSISTENT;
+        }
+      }
+    } else if (aWidgetType == NS_THEME_TOOLBARBUTTON_DROPDOWN ||
+               aWidgetType == NS_THEME_TREEHEADERSORTARROW ||
+               aWidgetType == NS_THEME_BUTTON_ARROW_PREVIOUS ||
+               aWidgetType == NS_THEME_BUTTON_ARROW_NEXT ||
+               aWidgetType == NS_THEME_BUTTON_ARROW_UP ||
+               aWidgetType == NS_THEME_BUTTON_ARROW_DOWN) {
+      // The state of an arrow comes from its parent.
+      stateFrame = aFrame = aFrame->GetParent();
+    }
+
+    EventStates eventState = GetContentState(stateFrame, aWidgetType);
+
+    aState->disabled = IsDisabled(aFrame, eventState) || IsReadOnly(aFrame);
+    aState->active  = eventState.HasState(NS_EVENT_STATE_ACTIVE);
+    aState->focused = eventState.HasState(NS_EVENT_STATE_FOCUS);
+    aState->inHover = eventState.HasState(NS_EVENT_STATE_HOVER);
+    aState->isDefault = IsDefaultButton(aFrame);
+    aState->canDefault = FALSE; // XXX fix me
+    aState->depressed = FALSE;
+
+    if (aWidgetType == NS_THEME_FOCUS_OUTLINE) {
+      aState->disabled = FALSE;
+      aState->active  = FALSE;
+      aState->inHover = FALSE;
+      aState->isDefault = FALSE;
+      aState->canDefault = FALSE;
+
+      aState->focused = TRUE;
+      aState->depressed = TRUE; // see moz_gtk_entry_paint()
+    } else if (aWidgetType == NS_THEME_BUTTON ||
+               aWidgetType == NS_THEME_TOOLBARBUTTON ||
+               aWidgetType == NS_THEME_DUALBUTTON ||
+               aWidgetType == NS_THEME_TOOLBARBUTTON_DROPDOWN ||
+               aWidgetType == NS_THEME_MENULIST ||
+               aWidgetType == NS_THEME_MENULIST_BUTTON) {
+      aState->active &= aState->inHover;
+    }
+
+    if (IsFrameContentNodeInNamespace(aFrame, kNameSpaceID_XUL)) {
+      // For these widget types, some element (either a child or parent)
+      // actually has element focus, so we check the focused attribute
+      // to see whether to draw in the focused state.
+      if (aWidgetType == NS_THEME_NUMBER_INPUT ||
+          aWidgetType == NS_THEME_TEXTFIELD ||
+          aWidgetType == NS_THEME_TEXTFIELD_MULTILINE ||
+          aWidgetType == NS_THEME_MENULIST_TEXTFIELD ||
+          aWidgetType == NS_THEME_SPINNER_TEXTFIELD ||
+          aWidgetType == NS_THEME_RADIO_CONTAINER ||
+          aWidgetType == NS_THEME_RADIO_LABEL) {
+        aState->focused = IsFocused(aFrame);
+      } else if (aWidgetType == NS_THEME_RADIO ||
+                 aWidgetType == NS_THEME_CHECKBOX) {
+        // In XUL, checkboxes and radios shouldn't have focus rings, their labels do
+        aState->focused = FALSE;
+      }
+
+      if (aWidgetType == NS_THEME_SCROLLBARTHUMB_VERTICAL ||
+          aWidgetType == NS_THEME_SCROLLBARTHUMB_HORIZONTAL) {
+        // for scrollbars we need to go up two to go from the thumb to
+        // the slider to the actual scrollbar object
+        nsIFrame *tmpFrame = aFrame->GetParent()->GetParent();
+
+        aState->curpos = CheckIntAttr(tmpFrame, nsGkAtoms::curpos, 0);
+        aState->maxpos = CheckIntAttr(tmpFrame, nsGkAtoms::maxpos, 100);
+
+        if (CheckBooleanAttr(aFrame, nsGkAtoms::active)) {
+          aState->active = TRUE;
+          // Set hover state to emulate Gtk style of active scrollbar thumb
+          aState->inHover = TRUE;
+        }
+      }
+
+      if (aWidgetType == NS_THEME_SCROLLBARBUTTON_UP ||
+          aWidgetType == NS_THEME_SCROLLBARBUTTON_DOWN ||
+          aWidgetType == NS_THEME_SCROLLBARBUTTON_LEFT ||
+          aWidgetType == NS_THEME_SCROLLBARBUTTON_RIGHT) {
+        // set the state to disabled when the scrollbar is scrolled to
+        // the beginning or the end, depending on the button type.
+        int32_t curpos = CheckIntAttr(aFrame, nsGkAtoms::curpos, 0);
+        int32_t maxpos = CheckIntAttr(aFrame, nsGkAtoms::maxpos, 100);
+        if (ShouldScrollbarButtonBeDisabled(curpos, maxpos, aWidgetType)) {
+          aState->disabled = true;
+        }
+
+        // In order to simulate native GTK scrollbar click behavior,
+        // we set the active attribute on the element to true if it's
+        // pressed with any mouse button.
+        // This allows us to show that it's active without setting :active
+        else if (CheckBooleanAttr(aFrame, nsGkAtoms::active))
+          aState->active = true;
+
+        if (aWidgetFlags) {
+          *aWidgetFlags = GetScrollbarButtonType(aFrame);
+          if (aWidgetType - NS_THEME_SCROLLBARBUTTON_UP < 2)
+            *aWidgetFlags |= MOZ_GTK_STEPPER_VERTICAL;
+        }
+      }
+
+      // menu item state is determined by the attribute "_moz-menuactive",
+      // and not by the mouse hovering (accessibility).  as a special case,
+      // menus which are children of a menu bar are only marked as prelight
+      // if they are open, not on normal hover.
+
+      if (aWidgetType == NS_THEME_MENUITEM ||
+          aWidgetType == NS_THEME_CHECKMENUITEM ||
+          aWidgetType == NS_THEME_RADIOMENUITEM ||
+          aWidgetType == NS_THEME_MENUSEPARATOR ||
+          aWidgetType == NS_THEME_MENUARROW) {
+        bool isTopLevel = false;
+        nsMenuFrame *menuFrame = do_QueryFrame(aFrame);
+        if (menuFrame) {
+          isTopLevel = menuFrame->IsOnMenuBar();
+        }
+
+        if (isTopLevel) {
+          aState->inHover = menuFrame->IsOpen();
+        } else {
+          aState->inHover = CheckBooleanAttr(aFrame, nsGkAtoms::menuactive);
+        }
+
+        aState->active = FALSE;
+
+        if (aWidgetType == NS_THEME_CHECKMENUITEM ||
+            aWidgetType == NS_THEME_RADIOMENUITEM) {
+          *aWidgetFlags = 0;
+          if (aFrame && aFrame->GetContent()) {
+            *aWidgetFlags = aFrame->GetContent()->
+              AttrValueIs(kNameSpaceID_None, nsGkAtoms::checked,
+                          nsGkAtoms::_true, eIgnoreCase);
+          }
+        }
+      }
+
+      // A button with drop down menu open or an activated toggle button
+      // should always appear depressed.
+      if (aWidgetType == NS_THEME_BUTTON ||
+          aWidgetType == NS_THEME_TOOLBARBUTTON ||
+          aWidgetType == NS_THEME_DUALBUTTON ||
+          aWidgetType == NS_THEME_TOOLBARBUTTON_DROPDOWN ||
+          aWidgetType == NS_THEME_MENULIST ||
+          aWidgetType == NS_THEME_MENULIST_BUTTON) {
+        bool menuOpen = IsOpenButton(aFrame);
+        aState->depressed = IsCheckedButton(aFrame) || menuOpen;
+        // we must not highlight buttons with open drop down menus on hover.
+        aState->inHover = aState->inHover && !menuOpen;
+      }
+
+      // When the input field of the drop down button has focus, some themes
+      // should draw focus for the drop down button as well.
+      if (aWidgetType == NS_THEME_MENULIST_BUTTON && aWidgetFlags) {
+        *aWidgetFlags = CheckBooleanAttr(aFrame, nsGkAtoms::parentfocused);
+      }
+    }
+  }
+
+  switch (aWidgetType) {
+  case NS_THEME_BUTTON:
+    if (aWidgetFlags)
+      *aWidgetFlags = GTK_RELIEF_NORMAL;
+    aGtkWidgetType = MOZ_GTK_BUTTON;
+    break;
+  case NS_THEME_TOOLBARBUTTON:
+  case NS_THEME_DUALBUTTON:
+    if (aWidgetFlags)
+      *aWidgetFlags = GTK_RELIEF_NONE;
+    aGtkWidgetType = MOZ_GTK_TOOLBAR_BUTTON;
+    break;
+  case NS_THEME_FOCUS_OUTLINE:
+    aGtkWidgetType = MOZ_GTK_ENTRY;
+    break;
+  case NS_THEME_CHECKBOX:
+  case NS_THEME_RADIO:
+    aGtkWidgetType = (aWidgetType == NS_THEME_RADIO) ? MOZ_GTK_RADIOBUTTON : MOZ_GTK_CHECKBUTTON;
+    break;
+  case NS_THEME_SCROLLBARBUTTON_UP:
+  case NS_THEME_SCROLLBARBUTTON_DOWN:
+  case NS_THEME_SCROLLBARBUTTON_LEFT:
+  case NS_THEME_SCROLLBARBUTTON_RIGHT:
+    aGtkWidgetType = MOZ_GTK_SCROLLBAR_BUTTON;
+    break;
+  case NS_THEME_SCROLLBAR_VERTICAL:
+    aGtkWidgetType = MOZ_GTK_SCROLLBAR_VERTICAL;
+    if (GetWidgetTransparency(aFrame, aWidgetType) == eOpaque)
+        *aWidgetFlags = MOZ_GTK_TRACK_OPAQUE;
+    else
+        *aWidgetFlags = 0;
+    break;
+  case NS_THEME_SCROLLBAR_HORIZONTAL:
+    aGtkWidgetType = MOZ_GTK_SCROLLBAR_HORIZONTAL;
+    if (GetWidgetTransparency(aFrame, aWidgetType) == eOpaque)
+        *aWidgetFlags = MOZ_GTK_TRACK_OPAQUE;
+    else
+        *aWidgetFlags = 0;
+    break;
+  case NS_THEME_SCROLLBARTRACK_HORIZONTAL:
+    aGtkWidgetType = MOZ_GTK_SCROLLBAR_TROUGH_HORIZONTAL;
+    break;
+  case NS_THEME_SCROLLBARTRACK_VERTICAL:
+    aGtkWidgetType = MOZ_GTK_SCROLLBAR_TROUGH_VERTICAL;
+    break;
+  case NS_THEME_SCROLLBARTHUMB_VERTICAL:
+    aGtkWidgetType = MOZ_GTK_SCROLLBAR_THUMB_VERTICAL;
+    break;
+  case NS_THEME_SCROLLBARTHUMB_HORIZONTAL:
+    aGtkWidgetType = MOZ_GTK_SCROLLBAR_THUMB_HORIZONTAL;
+    break;
+  case NS_THEME_SPINNER:
+    aGtkWidgetType = MOZ_GTK_SPINBUTTON;
+    break;
+  case NS_THEME_SPINNER_UPBUTTON:
+    aGtkWidgetType = MOZ_GTK_SPINBUTTON_UP;
+    break;
+  case NS_THEME_SPINNER_DOWNBUTTON:
+    aGtkWidgetType = MOZ_GTK_SPINBUTTON_DOWN;
+    break;
+  case NS_THEME_SPINNER_TEXTFIELD:
+    aGtkWidgetType = MOZ_GTK_SPINBUTTON_ENTRY;
+    break;
+  case NS_THEME_RANGE:
+    {
+      if (IsRangeHorizontal(aFrame)) {
+        if (aWidgetFlags)
+          *aWidgetFlags = GTK_ORIENTATION_HORIZONTAL;
+        aGtkWidgetType = MOZ_GTK_SCALE_HORIZONTAL;
+      } else {
+        if (aWidgetFlags)
+          *aWidgetFlags = GTK_ORIENTATION_VERTICAL;
+        aGtkWidgetType = MOZ_GTK_SCALE_VERTICAL;
+      }
+      break;
+    }
+  case NS_THEME_RANGE_THUMB:
+    {
+      if (IsRangeHorizontal(aFrame)) {
+        if (aWidgetFlags)
+          *aWidgetFlags = GTK_ORIENTATION_HORIZONTAL;
+        aGtkWidgetType = MOZ_GTK_SCALE_THUMB_HORIZONTAL;
+      } else {
+        if (aWidgetFlags)
+          *aWidgetFlags = GTK_ORIENTATION_VERTICAL;
+        aGtkWidgetType = MOZ_GTK_SCALE_THUMB_VERTICAL;
+      }
+      break;
+    }
+  case NS_THEME_SCALE_HORIZONTAL:
+    if (aWidgetFlags)
+      *aWidgetFlags = GTK_ORIENTATION_HORIZONTAL;
+    aGtkWidgetType = MOZ_GTK_SCALE_HORIZONTAL;
+    break;
+  case NS_THEME_SCALETHUMB_HORIZONTAL:
+    if (aWidgetFlags)
+      *aWidgetFlags = GTK_ORIENTATION_HORIZONTAL;
+    aGtkWidgetType = MOZ_GTK_SCALE_THUMB_HORIZONTAL;
+    break;
+  case NS_THEME_SCALE_VERTICAL:
+    if (aWidgetFlags)
+      *aWidgetFlags = GTK_ORIENTATION_VERTICAL;
+    aGtkWidgetType = MOZ_GTK_SCALE_VERTICAL;
+    break;
+  case NS_THEME_SEPARATOR:
+    aGtkWidgetType = MOZ_GTK_TOOLBAR_SEPARATOR;
+    break;
+  case NS_THEME_SCALETHUMB_VERTICAL:
+    if (aWidgetFlags)
+      *aWidgetFlags = GTK_ORIENTATION_VERTICAL;
+    aGtkWidgetType = MOZ_GTK_SCALE_THUMB_VERTICAL;
+    break;
+  case NS_THEME_TOOLBARGRIPPER:
+    aGtkWidgetType = MOZ_GTK_GRIPPER;
+    break;
+  case NS_THEME_RESIZER:
+    aGtkWidgetType = MOZ_GTK_RESIZER;
+    break;
+  case NS_THEME_NUMBER_INPUT:
+  case NS_THEME_TEXTFIELD:
+    aGtkWidgetType = MOZ_GTK_ENTRY;
+    break;
+  case NS_THEME_TEXTFIELD_MULTILINE:
+#if (MOZ_WIDGET_GTK == 3)
+    aGtkWidgetType = MOZ_GTK_TEXT_VIEW;
+#else
+    aGtkWidgetType = MOZ_GTK_ENTRY;
+#endif
+    break;
+  case NS_THEME_LISTBOX:
+  case NS_THEME_TREEVIEW:
+    aGtkWidgetType = MOZ_GTK_TREEVIEW;
+    break;
+  case NS_THEME_TREEHEADERCELL:
+    if (aWidgetFlags) {
+      // In this case, the flag denotes whether the header is the sorted one or not
+      if (GetTreeSortDirection(aFrame) == eTreeSortDirection_Natural)
+        *aWidgetFlags = false;
+      else
+        *aWidgetFlags = true;
+    }
+    aGtkWidgetType = MOZ_GTK_TREE_HEADER_CELL;
+    break;
+  case NS_THEME_TREEHEADERSORTARROW:
+    if (aWidgetFlags) {
+      switch (GetTreeSortDirection(aFrame)) {
+        case eTreeSortDirection_Ascending:
+          *aWidgetFlags = GTK_ARROW_DOWN;
+          break;
+        case eTreeSortDirection_Descending:
+          *aWidgetFlags = GTK_ARROW_UP;
+          break;
+        case eTreeSortDirection_Natural:
+        default:
+          /* This prevents the treecolums from getting smaller
+           * and wider when switching sort direction off and on
+           * */
+          *aWidgetFlags = GTK_ARROW_NONE;
+          break;
+      }
+    }
+    aGtkWidgetType = MOZ_GTK_TREE_HEADER_SORTARROW;
+    break;
+  case NS_THEME_TREETWISTY:
+    aGtkWidgetType = MOZ_GTK_TREEVIEW_EXPANDER;
+    if (aWidgetFlags)
+      *aWidgetFlags = GTK_EXPANDER_COLLAPSED;
+    break;
+  case NS_THEME_TREETWISTYOPEN:
+    aGtkWidgetType = MOZ_GTK_TREEVIEW_EXPANDER;
+    if (aWidgetFlags)
+      *aWidgetFlags = GTK_EXPANDER_EXPANDED;
+    break;
+  case NS_THEME_MENULIST:
+    aGtkWidgetType = MOZ_GTK_DROPDOWN;
+    if (aWidgetFlags)
+        *aWidgetFlags = IsFrameContentNodeInNamespace(aFrame, kNameSpaceID_XHTML);
+    break;
+  case NS_THEME_MENULIST_TEXT:
+    return false; // nothing to do, but prevents the bg from being drawn
+  case NS_THEME_MENULIST_TEXTFIELD:
+    aGtkWidgetType = MOZ_GTK_DROPDOWN_ENTRY;
+    break;
+  case NS_THEME_MENULIST_BUTTON:
+    aGtkWidgetType = MOZ_GTK_DROPDOWN_ARROW;
+    break;
+  case NS_THEME_TOOLBARBUTTON_DROPDOWN:
+  case NS_THEME_BUTTON_ARROW_DOWN:
+  case NS_THEME_BUTTON_ARROW_UP:
+  case NS_THEME_BUTTON_ARROW_NEXT:
+  case NS_THEME_BUTTON_ARROW_PREVIOUS:
+    aGtkWidgetType = MOZ_GTK_TOOLBARBUTTON_ARROW;
+    if (aWidgetFlags) {
+      *aWidgetFlags = GTK_ARROW_DOWN;
+
+      if (aWidgetType == NS_THEME_BUTTON_ARROW_UP)
+        *aWidgetFlags = GTK_ARROW_UP;
+      else if (aWidgetType == NS_THEME_BUTTON_ARROW_NEXT)
+        *aWidgetFlags = GTK_ARROW_RIGHT;
+      else if (aWidgetType == NS_THEME_BUTTON_ARROW_PREVIOUS)
+        *aWidgetFlags = GTK_ARROW_LEFT;
+    }
+    break;
+  case NS_THEME_CHECKBOX_CONTAINER:
+    aGtkWidgetType = MOZ_GTK_CHECKBUTTON_CONTAINER;
+    break;
+  case NS_THEME_RADIO_CONTAINER:
+    aGtkWidgetType = MOZ_GTK_RADIOBUTTON_CONTAINER;
+    break;
+  case NS_THEME_CHECKBOX_LABEL:
+    aGtkWidgetType = MOZ_GTK_CHECKBUTTON_LABEL;
+    break;
+  case NS_THEME_RADIO_LABEL:
+    aGtkWidgetType = MOZ_GTK_RADIOBUTTON_LABEL;
+    break;
+  case NS_THEME_TOOLBAR:
+    aGtkWidgetType = MOZ_GTK_TOOLBAR;
+    break;
+  case NS_THEME_TOOLTIP:
+    aGtkWidgetType = MOZ_GTK_TOOLTIP;
+    break;
+  case NS_THEME_STATUSBARPANEL:
+  case NS_THEME_RESIZERPANEL:
+    aGtkWidgetType = MOZ_GTK_FRAME;
+    break;
+  case NS_THEME_PROGRESSBAR:
+  case NS_THEME_PROGRESSBAR_VERTICAL:
+    aGtkWidgetType = MOZ_GTK_PROGRESSBAR;
+    break;
+  case NS_THEME_PROGRESSCHUNK:
+  case NS_THEME_PROGRESSCHUNK_VERTICAL:
+    {
+      nsIFrame* stateFrame = aFrame->GetParent();
+      EventStates eventStates = GetContentState(stateFrame, aWidgetType);
+
+      aGtkWidgetType = IsIndeterminateProgress(stateFrame, eventStates)
+                         ? IsVerticalProgress(stateFrame)
+                           ? MOZ_GTK_PROGRESS_CHUNK_VERTICAL_INDETERMINATE
+                           : MOZ_GTK_PROGRESS_CHUNK_INDETERMINATE
+                         : MOZ_GTK_PROGRESS_CHUNK;
+    }
+    break;
+  case NS_THEME_TAB_SCROLL_ARROW_BACK:
+  case NS_THEME_TAB_SCROLL_ARROW_FORWARD:
+    if (aWidgetFlags)
+      *aWidgetFlags = aWidgetType == NS_THEME_TAB_SCROLL_ARROW_BACK ?
+                        GTK_ARROW_LEFT : GTK_ARROW_RIGHT;
+    aGtkWidgetType = MOZ_GTK_TAB_SCROLLARROW;
+    break;
+  case NS_THEME_TABPANELS:
+    aGtkWidgetType = MOZ_GTK_TABPANELS;
+    break;
+  case NS_THEME_TAB:
+    {
+      if (IsBottomTab(aFrame)) {
+        aGtkWidgetType = MOZ_GTK_TAB_BOTTOM;
+      } else {
+        aGtkWidgetType = MOZ_GTK_TAB_TOP;
+      }
+
+      if (aWidgetFlags) {
+        /* First bits will be used to store max(0,-bmargin) where bmargin
+         * is the bottom margin of the tab in pixels  (resp. top margin,
+         * for bottom tabs). */
+        *aWidgetFlags = GetTabMarginPixels(aFrame);
+
+        if (IsSelectedTab(aFrame))
+          *aWidgetFlags |= MOZ_GTK_TAB_SELECTED;
+
+        if (IsFirstTab(aFrame))
+          *aWidgetFlags |= MOZ_GTK_TAB_FIRST;
+      }
+    }
+    break;
+  case NS_THEME_SPLITTER:
+    if (IsHorizontal(aFrame))
+      aGtkWidgetType = MOZ_GTK_SPLITTER_VERTICAL;
+    else 
+      aGtkWidgetType = MOZ_GTK_SPLITTER_HORIZONTAL;
+    break;
+  case NS_THEME_MENUBAR:
+    aGtkWidgetType = MOZ_GTK_MENUBAR;
+    break;
+  case NS_THEME_MENUPOPUP:
+    aGtkWidgetType = MOZ_GTK_MENUPOPUP;
+    break;
+  case NS_THEME_MENUITEM:
+    {
+      nsMenuFrame *menuFrame = do_QueryFrame(aFrame);
+      if (menuFrame && menuFrame->IsOnMenuBar()) {
+        aGtkWidgetType = MOZ_GTK_MENUBARITEM;
+        break;
+      }
+    }
+    aGtkWidgetType = MOZ_GTK_MENUITEM;
+    break;
+  case NS_THEME_MENUSEPARATOR:
+    aGtkWidgetType = MOZ_GTK_MENUSEPARATOR;
+    break;
+  case NS_THEME_MENUARROW:
+    aGtkWidgetType = MOZ_GTK_MENUARROW;
+    break;
+  case NS_THEME_CHECKMENUITEM:
+    aGtkWidgetType = MOZ_GTK_CHECKMENUITEM;
+    break;
+  case NS_THEME_RADIOMENUITEM:
+    aGtkWidgetType = MOZ_GTK_RADIOMENUITEM;
+    break;
+  case NS_THEME_WINDOW:
+  case NS_THEME_DIALOG:
+    aGtkWidgetType = MOZ_GTK_WINDOW;
+    break;
+  case NS_THEME_GTK_INFO_BAR:
+    aGtkWidgetType = MOZ_GTK_INFO_BAR;
+    break;
+  default:
+    return false;
+  }
+
+  return true;
+}
+
+#if (MOZ_WIDGET_GTK == 2)
+class ThemeRenderer : public gfxGdkNativeRenderer {
+public:
+  ThemeRenderer(GtkWidgetState aState, WidgetNodeType aGTKWidgetType,
+                gint aFlags, GtkTextDirection aDirection,
+                const GdkRectangle& aGDKRect, const GdkRectangle& aGDKClip)
+    : mState(aState), mGTKWidgetType(aGTKWidgetType), mFlags(aFlags),
+      mDirection(aDirection), mGDKRect(aGDKRect), mGDKClip(aGDKClip) {}
+  nsresult DrawWithGDK(GdkDrawable * drawable, gint offsetX, gint offsetY,
+                       GdkRectangle * clipRects, uint32_t numClipRects);
+private:
+  GtkWidgetState mState;
+  WidgetNodeType mGTKWidgetType;
+  gint mFlags;
+  GtkTextDirection mDirection;
+  const GdkRectangle& mGDKRect;
+  const GdkRectangle& mGDKClip;
+};
+
+nsresult
+ThemeRenderer::DrawWithGDK(GdkDrawable * drawable, gint offsetX, 
+        gint offsetY, GdkRectangle * clipRects, uint32_t numClipRects)
+{
+  GdkRectangle gdk_rect = mGDKRect;
+  gdk_rect.x += offsetX;
+  gdk_rect.y += offsetY;
+
+  GdkRectangle gdk_clip = mGDKClip;
+  gdk_clip.x += offsetX;
+  gdk_clip.y += offsetY;
+
+  GdkRectangle surfaceRect;
+  surfaceRect.x = 0;
+  surfaceRect.y = 0;
+  gdk_drawable_get_size(drawable, &surfaceRect.width, &surfaceRect.height);
+  gdk_rectangle_intersect(&gdk_clip, &surfaceRect, &gdk_clip);
+  
+  NS_ASSERTION(numClipRects == 0, "We don't support clipping!!!");
+  moz_gtk_widget_paint(mGTKWidgetType, drawable, &gdk_rect, &gdk_clip,
+                       &mState, mFlags, mDirection);
+
+  return NS_OK;
+}
+#else
+class SystemCairoClipper : public ClipExporter {
+public:
+  explicit SystemCairoClipper(cairo_t* aContext) : mContext(aContext)
+  {
+  }
+
+  void
+  BeginClip(const Matrix& aTransform) override
+  {
+    cairo_matrix_t mat;
+    GfxMatrixToCairoMatrix(aTransform, mat);
+    cairo_set_matrix(mContext, &mat);
+
+    cairo_new_path(mContext);
+  }
+
+  void
+  MoveTo(const Point &aPoint) override
+  {
+    cairo_move_to(mContext, aPoint.x, aPoint.y);
+    mCurrentPoint = aPoint;
+  }
+
+  void
+  LineTo(const Point &aPoint) override
+  {
+    cairo_line_to(mContext, aPoint.x, aPoint.y);
+    mCurrentPoint = aPoint;
+  }
+
+  void
+  BezierTo(const Point &aCP1, const Point &aCP2, const Point &aCP3) override
+  {
+    cairo_curve_to(mContext, aCP1.x, aCP1.y, aCP2.x, aCP2.y, aCP3.x, aCP3.y);
+    mCurrentPoint = aCP3;
+  }
+
+  void
+  QuadraticBezierTo(const Point &aCP1, const Point &aCP2) override
+  {
+    Point CP0 = CurrentPoint();
+    Point CP1 = (CP0 + aCP1 * 2.0) / 3.0;
+    Point CP2 = (aCP2 + aCP1 * 2.0) / 3.0;
+    Point CP3 = aCP2;
+    cairo_curve_to(mContext, CP1.x, CP1.y, CP2.x, CP2.y, CP3.x, CP3.y);
+    mCurrentPoint = aCP2;
+  }
+
+  void
+  Arc(const Point &aOrigin, float aRadius, float aStartAngle, float aEndAngle,
+      bool aAntiClockwise) override
+  {
+    ArcToBezier(this, aOrigin, Size(aRadius, aRadius), aStartAngle, aEndAngle,
+                aAntiClockwise);
+  }
+
+  void
+  Close() override
+  {
+    cairo_close_path(mContext);
+  }
+
+  void
+  EndClip() override
+  {
+    cairo_clip(mContext);
+  }
+
+  Point
+  CurrentPoint() const override
+  {
+    return mCurrentPoint;
+  }
+
+private:
+  cairo_t* mContext;
+  Point mCurrentPoint;
+};
+
+static void
+DrawThemeWithCairo(gfxContext* aContext, DrawTarget* aDrawTarget,
+                   GtkWidgetState aState, WidgetNodeType aGTKWidgetType,
+                   gint aFlags, GtkTextDirection aDirection, gint aScaleFactor,
+                   bool aSnapped, const Point& aDrawOrigin, const nsIntSize& aDrawSize,
+                   GdkRectangle& aGDKRect, nsITheme::Transparency aTransparency)
+{
+  Point drawOffset;
+  Matrix transform;
+  if (!aSnapped) {
+    // If we are not snapped, we depend on the DT for translation.
+    drawOffset = aDrawOrigin;
+    transform = aDrawTarget->GetTransform().PreTranslate(aDrawOrigin);
+  } else {
+    // Otherwise, we only need to take the device offset into account.
+    drawOffset = aDrawOrigin - aContext->GetDeviceOffset();
+    transform = Matrix::Translation(drawOffset);
+  }
+
+  if (aScaleFactor != 1)
+    transform.PreScale(aScaleFactor, aScaleFactor);
+
+  cairo_matrix_t mat;
+  GfxMatrixToCairoMatrix(transform, mat);
+
+  nsIntSize clipSize((aDrawSize.width + aScaleFactor - 1) / aScaleFactor,
+                     (aDrawSize.height + aScaleFactor - 1) / aScaleFactor);
+
+#ifndef MOZ_TREE_CAIRO
+  // Directly use the Cairo draw target to render the widget if using system Cairo everywhere.
+  BorrowedCairoContext borrowCairo(aDrawTarget);
+  if (borrowCairo.mCairo) {
+    cairo_set_matrix(borrowCairo.mCairo, &mat);
+
+    cairo_new_path(borrowCairo.mCairo);
+    cairo_rectangle(borrowCairo.mCairo, 0, 0, clipSize.width, clipSize.height);
+    cairo_clip(borrowCairo.mCairo);
+
+    moz_gtk_widget_paint(aGTKWidgetType, borrowCairo.mCairo, &aGDKRect, &aState, aFlags, aDirection);
+
+    borrowCairo.Finish();
+    return;
+  }
+#endif
+
+  // A direct Cairo draw target is not available, so we need to create a temporary one.
+#if defined(MOZ_X11) && defined(CAIRO_HAS_XLIB_SURFACE)
+  // If using a Cairo xlib surface, then try to reuse it.
+  BorrowedXlibDrawable borrow(aDrawTarget);
+  if (borrow.GetDrawable()) {
+    nsIntSize size = borrow.GetSize();
+    cairo_surface_t* surf = nullptr;
+    // Check if the surface is using XRender.
+#ifdef CAIRO_HAS_XLIB_XRENDER_SURFACE
+    if (borrow.GetXRenderFormat()) {
+      surf = cairo_xlib_surface_create_with_xrender_format(
+          borrow.GetDisplay(), borrow.GetDrawable(), borrow.GetScreen(),
+          borrow.GetXRenderFormat(), size.width, size.height);
+    } else {
+#else
+      if (! borrow.GetXRenderFormat()) {
+#endif
+        surf = cairo_xlib_surface_create(
+            borrow.GetDisplay(), borrow.GetDrawable(), borrow.GetVisual(),
+            size.width, size.height);
+      }
+      if (!NS_WARN_IF(!surf)) {
+        Point offset = borrow.GetOffset();
+        if (offset != Point()) {
+          cairo_surface_set_device_offset(surf, offset.x, offset.y);
+        }
+        cairo_t* cr = cairo_create(surf);
+        if (!NS_WARN_IF(!cr)) {
+          RefPtr<SystemCairoClipper> clipper = new SystemCairoClipper(cr);
+          aContext->ExportClip(*clipper);
+
+          cairo_set_matrix(cr, &mat);
+
+          cairo_new_path(cr);
+          cairo_rectangle(cr, 0, 0, clipSize.width, clipSize.height);
+          cairo_clip(cr);
+
+          moz_gtk_widget_paint(aGTKWidgetType, cr, &aGDKRect, &aState, aFlags, aDirection);
+
+          cairo_destroy(cr);
+        }
+        cairo_surface_destroy(surf);
+      }
+      borrow.Finish();
+      return;
+    }
+#endif
+
+  // Check if the widget requires complex masking that must be composited.
+  // Try to directly write to the draw target's pixels if possible.
+  uint8_t* data;
+  nsIntSize size;
+  int32_t stride;
+  SurfaceFormat format;
+  IntPoint origin;
+  if (aDrawTarget->LockBits(&data, &size, &stride, &format, &origin)) {
+    // Create a Cairo image surface context the device rectangle.
+    cairo_surface_t* surf =
+      cairo_image_surface_create_for_data(
+        data, GfxFormatToCairoFormat(format), size.width, size.height, stride);
+    if (!NS_WARN_IF(!surf)) {
+      if (origin != IntPoint()) {
+        cairo_surface_set_device_offset(surf, -origin.x, -origin.y);
+      }
+      cairo_t* cr = cairo_create(surf);
+      if (!NS_WARN_IF(!cr)) {
+        RefPtr<SystemCairoClipper> clipper = new SystemCairoClipper(cr);
+        aContext->ExportClip(*clipper);
+
+        cairo_set_matrix(cr, &mat);
+
+        cairo_new_path(cr);
+        cairo_rectangle(cr, 0, 0, clipSize.width, clipSize.height);
+        cairo_clip(cr);
+
+        moz_gtk_widget_paint(aGTKWidgetType, cr, &aGDKRect, &aState, aFlags, aDirection);
+
+        cairo_destroy(cr);
+      }
+      cairo_surface_destroy(surf);
+    }
+    aDrawTarget->ReleaseBits(data);
+  } else {
+    // If the widget has any transparency, make sure to choose an alpha format.
+    format = aTransparency != nsITheme::eOpaque ? SurfaceFormat::B8G8R8A8 : aDrawTarget->GetFormat();
+    // Create a temporary data surface to render the widget into.
+    RefPtr<DataSourceSurface> dataSurface =
+      Factory::CreateDataSourceSurface(aDrawSize, format, aTransparency != nsITheme::eOpaque);
+    DataSourceSurface::MappedSurface map;
+    if (!NS_WARN_IF(!(dataSurface && dataSurface->Map(DataSourceSurface::MapType::WRITE, &map)))) {
+      // Create a Cairo image surface wrapping the data surface.
+      cairo_surface_t* surf =
+        cairo_image_surface_create_for_data(map.mData, GfxFormatToCairoFormat(format),
+                                            aDrawSize.width, aDrawSize.height, map.mStride);
+      cairo_t* cr = nullptr;
+      if (!NS_WARN_IF(!surf)) {
+        cr = cairo_create(surf);
+        if (!NS_WARN_IF(!cr)) {
+          if (aScaleFactor != 1) {
+            cairo_scale(cr, aScaleFactor, aScaleFactor);
+          }
+
+          moz_gtk_widget_paint(aGTKWidgetType, cr, &aGDKRect, &aState, aFlags, aDirection);
+        }
+      }
+
+      // Unmap the surface before using it as a source
+      dataSurface->Unmap();
+
+      if (cr) {
+        if (!aSnapped || aTransparency != nsITheme::eOpaque) {
+          // The widget either needs to be masked or has transparency, so use the slower drawing path.
+          aDrawTarget->DrawSurface(dataSurface,
+                                   Rect(aSnapped ? drawOffset - aDrawTarget->GetTransform().GetTranslation() : drawOffset,
+                                        Size(aDrawSize)),
+                                   Rect(0, 0, aDrawSize.width, aDrawSize.height));
+        } else {
+          // The widget is a simple opaque rectangle, so just copy it out.
+          aDrawTarget->CopySurface(dataSurface,
+                                   IntRect(0, 0, aDrawSize.width, aDrawSize.height),
+                                   TruncatedToInt(drawOffset));
+        }
+
+        cairo_destroy(cr);
+      }
+
+      if (surf) {
+        cairo_surface_destroy(surf);
+      }
+    }
+  }
+}
+#endif
+
+bool
+nsNativeThemeGTK::GetExtraSizeForWidget(nsIFrame* aFrame, uint8_t aWidgetType,
+                                        nsIntMargin* aExtra)
+{
+  *aExtra = nsIntMargin(0,0,0,0);
+  // Allow an extra one pixel above and below the thumb for certain
+  // GTK2 themes (Ximian Industrial, Bluecurve, Misty, at least);
+  // We modify the frame's overflow area.  See bug 297508.
+  switch (aWidgetType) {
+  case NS_THEME_SCROLLBARTHUMB_VERTICAL:
+    aExtra->top = aExtra->bottom = 1;
+    break;
+  case NS_THEME_SCROLLBARTHUMB_HORIZONTAL:
+    aExtra->left = aExtra->right = 1;
+    break;
+
+  // Include the indicator spacing (the padding around the control).
+  case NS_THEME_CHECKBOX:
+  case NS_THEME_RADIO:
+    {
+      gint indicator_size, indicator_spacing;
+
+      if (aWidgetType == NS_THEME_CHECKBOX) {
+        moz_gtk_checkbox_get_metrics(&indicator_size, &indicator_spacing);
+      } else {
+        moz_gtk_radio_get_metrics(&indicator_size, &indicator_spacing);
+      }
+
+      aExtra->top = indicator_spacing;
+      aExtra->right = indicator_spacing;
+      aExtra->bottom = indicator_spacing;
+      aExtra->left = indicator_spacing;
+      break;
+    }
+  case NS_THEME_BUTTON :
+    {
+      if (IsDefaultButton(aFrame)) {
+        // Some themes draw a default indicator outside the widget,
+        // include that in overflow
+        gint top, left, bottom, right;
+        moz_gtk_button_get_default_overflow(&top, &left, &bottom, &right);
+        aExtra->top = top;
+        aExtra->right = right;
+        aExtra->bottom = bottom;
+        aExtra->left = left;
+        break;
+      }
+      return false;
+    }
+  case NS_THEME_FOCUS_OUTLINE:
+    {
+      moz_gtk_get_focus_outline_size(&aExtra->left, &aExtra->top);
+      aExtra->right = aExtra->left;
+      aExtra->bottom = aExtra->top;
+      break;
+    }
+  case NS_THEME_TAB :
+    {
+      if (!IsSelectedTab(aFrame))
+        return false;
+
+      gint gap_height = moz_gtk_get_tab_thickness(IsBottomTab(aFrame) ?
+                            MOZ_GTK_TAB_BOTTOM : MOZ_GTK_TAB_TOP);
+      if (!gap_height)
+        return false;
+
+      int32_t extra = gap_height - GetTabMarginPixels(aFrame);
+      if (extra <= 0)
+        return false;
+
+      if (IsBottomTab(aFrame)) {
+        aExtra->top = extra;
+      } else {
+        aExtra->bottom = extra;
+      }
+      return false;
+    }
+  default:
+    return false;
+  }
+  gint scale = nsScreenGtk::GetGtkMonitorScaleFactor();
+  aExtra->top *= scale;
+  aExtra->right *= scale;
+  aExtra->bottom *= scale;
+  aExtra->left *= scale;
+  return true;
+}
+
+NS_IMETHODIMP
+nsNativeThemeGTK::DrawWidgetBackground(nsRenderingContext* aContext,
+                                       nsIFrame* aFrame,
+                                       uint8_t aWidgetType,
+                                       const nsRect& aRect,
+                                       const nsRect& aDirtyRect)
+{
+  GtkWidgetState state;
+  WidgetNodeType gtkWidgetType;
+  GtkTextDirection direction = GetTextDirection(aFrame);
+  gint flags;
+  if (!GetGtkWidgetAndState(aWidgetType, aFrame, gtkWidgetType, &state,
+                            &flags))
+    return NS_OK;
+
+  gfxContext* ctx = aContext->ThebesContext();
+  nsPresContext *presContext = aFrame->PresContext();
+
+  gfxRect rect = presContext->AppUnitsToGfxUnits(aRect);
+  gfxRect dirtyRect = presContext->AppUnitsToGfxUnits(aDirtyRect);
+  gint scaleFactor = nsScreenGtk::GetGtkMonitorScaleFactor();
+
+  // Align to device pixels where sensible
+  // to provide crisper and faster drawing.
+  // Don't snap if it's a non-unit scale factor. We're going to have to take
+  // slow paths then in any case.
+  bool snapped = ctx->UserToDevicePixelSnapped(rect);
+  if (snapped) {
+    // Leave rect in device coords but make dirtyRect consistent.
+    dirtyRect = ctx->UserToDevice(dirtyRect);
+  }
+
+  // Translate the dirty rect so that it is wrt the widget top-left.
+  dirtyRect.MoveBy(-rect.TopLeft());
+  // Round out the dirty rect to gdk pixels to ensure that gtk draws
+  // enough pixels for interpolation to device pixels.
+  dirtyRect.RoundOut();
+
+  // GTK themes can only draw an integer number of pixels
+  // (even when not snapped).
+  nsIntRect widgetRect(0, 0, NS_lround(rect.Width()), NS_lround(rect.Height()));
+  nsIntRect overflowRect(widgetRect);
+  nsIntMargin extraSize;
+  if (GetExtraSizeForWidget(aFrame, aWidgetType, &extraSize)) {
+    overflowRect.Inflate(extraSize);
+  }
+
+  // This is the rectangle that will actually be drawn, in gdk pixels
+  nsIntRect drawingRect(int32_t(dirtyRect.X()),
+                        int32_t(dirtyRect.Y()),
+                        int32_t(dirtyRect.Width()),
+                        int32_t(dirtyRect.Height()));
+  if (widgetRect.IsEmpty()
+      || !drawingRect.IntersectRect(overflowRect, drawingRect))
+    return NS_OK;
+
+  NS_ASSERTION(!IsWidgetTypeDisabled(mDisabledWidgetTypes, aWidgetType),
+               "Trying to render an unsafe widget!");
+
+  bool safeState = IsWidgetStateSafe(mSafeWidgetStates, aWidgetType, &state);
+  if (!safeState) {
+    gLastGdkError = 0;
+    gdk_error_trap_push ();
+  }
+
+  Transparency transparency = GetWidgetTransparency(aFrame, aWidgetType);
+
+  // gdk rectangles are wrt the drawing rect.
+  GdkRectangle gdk_rect = {-drawingRect.x/scaleFactor,
+                           -drawingRect.y/scaleFactor,
+                           widgetRect.width/scaleFactor,
+                           widgetRect.height/scaleFactor};
+
+  // translate everything so (0,0) is the top left of the drawingRect
+  gfxPoint origin = rect.TopLeft() + drawingRect.TopLeft();
+
+#if (MOZ_WIDGET_GTK == 2)
+  gfxContextAutoSaveRestore autoSR(ctx);
+  gfxMatrix matrix;
+  if (!snapped) { // else rects are in device coords
+    matrix = ctx->CurrentMatrix();
+  }
+  matrix.Translate(origin);
+  matrix.Scale(scaleFactor, scaleFactor); // Draw in GDK coords
+  ctx->SetMatrix(matrix);
+
+  // The gdk_clip is just advisory here, meaning "you don't
+  // need to draw outside this rect if you don't feel like it!"
+  GdkRectangle gdk_clip = {0, 0, drawingRect.width, drawingRect.height};
+
+  ThemeRenderer renderer(state, gtkWidgetType, flags, direction,
+                         gdk_rect, gdk_clip);
+
+  // Some themes (e.g. Clearlooks) just don't clip properly to any
+  // clip rect we provide, so we cannot advertise support for clipping within
+  // the widget bounds.
+  uint32_t rendererFlags = 0;
+  if (transparency == eOpaque) {
+    rendererFlags |= gfxGdkNativeRenderer::DRAW_IS_OPAQUE;
+  }
+
+  // GtkStyles (used by the widget drawing backend) are created for a
+  // particular colormap/visual.
+  GdkColormap* colormap = moz_gtk_widget_get_colormap();
+
+  renderer.Draw(ctx, drawingRect.Size(), rendererFlags, colormap);
+#else 
+  DrawThemeWithCairo(ctx, aContext->GetDrawTarget(),
+                     state, gtkWidgetType, flags, direction, scaleFactor,
+                     snapped, ToPoint(origin), drawingRect.Size(),
+                     gdk_rect, transparency);
+#endif
+
+  if (!safeState) {
+    gdk_flush();
+    gLastGdkError = gdk_error_trap_pop ();
+
+    if (gLastGdkError) {
+#ifdef DEBUG
+      printf("GTK theme failed for widget type %d, error was %d, state was "
+             "[active=%d,focused=%d,inHover=%d,disabled=%d]\n",
+             aWidgetType, gLastGdkError, state.active, state.focused,
+             state.inHover, state.disabled);
+#endif
+      NS_WARNING("GTK theme failed; disabling unsafe widget");
+      SetWidgetTypeDisabled(mDisabledWidgetTypes, aWidgetType);
+      // force refresh of the window, because the widget was not
+      // successfully drawn it must be redrawn using the default look
+      RefreshWidgetWindow(aFrame);
+    } else {
+      SetWidgetStateSafe(mSafeWidgetStates, aWidgetType, &state);
+    }
+  }
+
+  // Indeterminate progress bar are animated.
+  if (gtkWidgetType == MOZ_GTK_PROGRESS_CHUNK_INDETERMINATE ||
+      gtkWidgetType == MOZ_GTK_PROGRESS_CHUNK_VERTICAL_INDETERMINATE) {
+    if (!QueueAnimatedContentForRefresh(aFrame->GetContent(), 30)) {
+      NS_WARNING("unable to animate widget!");
+    }
+  }
+
+  return NS_OK;
+}
+
+WidgetNodeType
+nsNativeThemeGTK::NativeThemeToGtkTheme(uint8_t aWidgetType, nsIFrame* aFrame)
+{
+  WidgetNodeType gtkWidgetType;
+  gint unusedFlags;
+
+  if (!GetGtkWidgetAndState(aWidgetType, aFrame, gtkWidgetType, nullptr,
+                            &unusedFlags))
+  {
+    MOZ_ASSERT_UNREACHABLE("Unknown native widget to gtk widget mapping");
+    return MOZ_GTK_WINDOW;
+  }
+  return gtkWidgetType;
+}
+
+NS_IMETHODIMP
+nsNativeThemeGTK::GetWidgetBorder(nsDeviceContext* aContext, nsIFrame* aFrame,
+                                  uint8_t aWidgetType, nsIntMargin* aResult)
+{
+  GtkTextDirection direction = GetTextDirection(aFrame);
+  aResult->top = aResult->left = aResult->right = aResult->bottom = 0;
+  switch (aWidgetType) {
+  case NS_THEME_TOOLBOX:
+    // gtk has no toolbox equivalent.  So, although we map toolbox to
+    // gtk's 'toolbar' for purposes of painting the widget background,
+    // we don't use the toolbar border for toolbox.
+    break;
+  case NS_THEME_DUALBUTTON:
+    // TOOLBAR_DUAL_BUTTON is an interesting case.  We want a border to draw
+    // around the entire button + dropdown, and also an inner border if you're
+    // over the button part.  But, we want the inner button to be right up
+    // against the edge of the outer button so that the borders overlap.
+    // To make this happen, we draw a button border for the outer button,
+    // but don't reserve any space for it.
+    break;
+  case NS_THEME_TAB:
+    {
+      WidgetNodeType gtkWidgetType;
+      gint flags;
+
+      if (!GetGtkWidgetAndState(aWidgetType, aFrame, gtkWidgetType, nullptr,
+                                &flags))
+        return NS_OK;
+
+      moz_gtk_get_tab_border(&aResult->left, &aResult->top,
+                             &aResult->right, &aResult->bottom, direction,
+                             (GtkTabFlags)flags, gtkWidgetType);
+    }
+    break;
+  case NS_THEME_MENUITEM:
+  case NS_THEME_CHECKMENUITEM:
+  case NS_THEME_RADIOMENUITEM:
+    // For regular menuitems, we will be using GetWidgetPadding instead of
+    // GetWidgetBorder to pad up the widget's internals; other menuitems
+    // will need to fall through and use the default case as before.
+    if (IsRegularMenuItem(aFrame))
+      break;
+    MOZ_FALLTHROUGH;
+  default:
+    {
+      WidgetNodeType gtkWidgetType;
+      gint unusedFlags;
+      if (GetGtkWidgetAndState(aWidgetType, aFrame, gtkWidgetType, nullptr,
+                               &unusedFlags)) {
+        moz_gtk_get_widget_border(gtkWidgetType, &aResult->left, &aResult->top,
+                                  &aResult->right, &aResult->bottom, direction,
+                                  IsFrameContentNodeInNamespace(aFrame, kNameSpaceID_XHTML));
+      }
+    }
+  }
+
+  gint scale = nsScreenGtk::GetGtkMonitorScaleFactor();
+  aResult->top *= scale;
+  aResult->right *= scale;
+  aResult->bottom *= scale;
+  aResult->left *= scale;
+  return NS_OK;
+}
+
+bool
+nsNativeThemeGTK::GetWidgetPadding(nsDeviceContext* aContext,
+                                   nsIFrame* aFrame, uint8_t aWidgetType,
+                                   nsIntMargin* aResult)
+{
+  switch (aWidgetType) {
+    case NS_THEME_BUTTON_FOCUS:
+    case NS_THEME_TOOLBARBUTTON:
+    case NS_THEME_DUALBUTTON:
+    case NS_THEME_TAB_SCROLL_ARROW_BACK:
+    case NS_THEME_TAB_SCROLL_ARROW_FORWARD:
+    case NS_THEME_MENULIST_BUTTON:
+    case NS_THEME_TOOLBARBUTTON_DROPDOWN:
+    case NS_THEME_BUTTON_ARROW_UP:
+    case NS_THEME_BUTTON_ARROW_DOWN:
+    case NS_THEME_BUTTON_ARROW_NEXT:
+    case NS_THEME_BUTTON_ARROW_PREVIOUS:
+    case NS_THEME_RANGE_THUMB:
+    // Radios and checkboxes return a fixed size in GetMinimumWidgetSize
+    // and have a meaningful baseline, so they can't have
+    // author-specified padding.
+    case NS_THEME_CHECKBOX:
+    case NS_THEME_RADIO:
+      aResult->SizeTo(0, 0, 0, 0);
+      return true;
+    case NS_THEME_MENUITEM:
+    case NS_THEME_CHECKMENUITEM:
+    case NS_THEME_RADIOMENUITEM:
+      {
+        // Menubar and menulist have their padding specified in CSS.
+        if (!IsRegularMenuItem(aFrame))
+          return false;
+
+        aResult->SizeTo(0, 0, 0, 0);
+        WidgetNodeType gtkWidgetType;
+        if (GetGtkWidgetAndState(aWidgetType, aFrame, gtkWidgetType, nullptr,
+                                 nullptr)) {
+          moz_gtk_get_widget_border(gtkWidgetType, &aResult->left, &aResult->top,
+                                    &aResult->right, &aResult->bottom, GetTextDirection(aFrame),
+                                    IsFrameContentNodeInNamespace(aFrame, kNameSpaceID_XHTML));
+        }
+
+        gint horizontal_padding;
+
+        if (aWidgetType == NS_THEME_MENUITEM)
+          moz_gtk_menuitem_get_horizontal_padding(&horizontal_padding);
+        else
+          moz_gtk_checkmenuitem_get_horizontal_padding(&horizontal_padding);
+
+        aResult->left += horizontal_padding;
+        aResult->right += horizontal_padding;
+
+        gint scale = nsScreenGtk::GetGtkMonitorScaleFactor();
+        aResult->top *= scale;
+        aResult->right *= scale;
+        aResult->bottom *= scale;
+        aResult->left *= scale;
+
+        return true;
+      }
+  }
+
+  return false;
+}
+
+bool
+nsNativeThemeGTK::GetWidgetOverflow(nsDeviceContext* aContext,
+                                    nsIFrame* aFrame, uint8_t aWidgetType,
+                                    nsRect* aOverflowRect)
+{
+  nsIntMargin extraSize;
+  if (!GetExtraSizeForWidget(aFrame, aWidgetType, &extraSize))
+    return false;
+
+  int32_t p2a = aContext->AppUnitsPerDevPixel();
+  nsMargin m(NSIntPixelsToAppUnits(extraSize.top, p2a),
+             NSIntPixelsToAppUnits(extraSize.right, p2a),
+             NSIntPixelsToAppUnits(extraSize.bottom, p2a),
+             NSIntPixelsToAppUnits(extraSize.left, p2a));
+
+  aOverflowRect->Inflate(m);
+  return true;
+}
+
+NS_IMETHODIMP
+nsNativeThemeGTK::GetMinimumWidgetSize(nsPresContext* aPresContext,
+                                       nsIFrame* aFrame, uint8_t aWidgetType,
+                                       LayoutDeviceIntSize* aResult,
+                                       bool* aIsOverridable)
+{
+  aResult->width = aResult->height = 0;
+  *aIsOverridable = true;
+
+  switch (aWidgetType) {
+    case NS_THEME_SCROLLBARBUTTON_UP:
+    case NS_THEME_SCROLLBARBUTTON_DOWN:
+      {
+        if (gtk_check_version(3,20,0) == nullptr) {
+          moz_gtk_get_widget_min_size(MOZ_GTK_SCROLLBAR_BUTTON,
+                                      &(aResult->width), &(aResult->height));
+        } else {
+          MozGtkScrollbarMetrics metrics;
+          moz_gtk_get_scrollbar_metrics(&metrics);
+
+          aResult->width = metrics.slider_width;
+          aResult->height = metrics.stepper_size;
+        }
+
+        *aIsOverridable = false;
+      }
+      break;
+    case NS_THEME_SCROLLBARBUTTON_LEFT:
+    case NS_THEME_SCROLLBARBUTTON_RIGHT:
+      {
+        if (gtk_check_version(3,20,0) == nullptr) {
+          moz_gtk_get_widget_min_size(MOZ_GTK_SCROLLBAR_BUTTON,
+                                      &(aResult->width), &(aResult->height));
+        } else {
+          MozGtkScrollbarMetrics metrics;
+          moz_gtk_get_scrollbar_metrics(&metrics);
+
+          aResult->width = metrics.stepper_size;
+          aResult->height = metrics.slider_width;
+        }
+        *aIsOverridable = false;
+      }
+      break;
+    case NS_THEME_SPLITTER:
+    {
+      gint metrics;
+      if (IsHorizontal(aFrame)) {
+        moz_gtk_splitter_get_metrics(GTK_ORIENTATION_HORIZONTAL, &metrics);
+        aResult->width = metrics;
+        aResult->height = 0;
+      } else {
+        moz_gtk_splitter_get_metrics(GTK_ORIENTATION_VERTICAL, &metrics);
+        aResult->width = 0;
+        aResult->height = metrics;
+      }
+      *aIsOverridable = false;
+    }
+    break;
+    case NS_THEME_SCROLLBAR_HORIZONTAL:
+    case NS_THEME_SCROLLBAR_VERTICAL:
+    {
+      /* While we enforce a minimum size for the thumb, this is ignored
+       * for the some scrollbars if buttons are hidden (bug 513006) because
+       * the thumb isn't a direct child of the scrollbar, unlike the buttons
+       * or track. So add a minimum size to the track as well to prevent a
+       * 0-width scrollbar. */
+      if (gtk_check_version(3,20,0) == nullptr) {
+        // Thumb min dimensions to start with
+        WidgetNodeType thumbType = aWidgetType == NS_THEME_SCROLLBAR_VERTICAL ?
+          MOZ_GTK_SCROLLBAR_THUMB_VERTICAL : MOZ_GTK_SCROLLBAR_THUMB_HORIZONTAL;
+        moz_gtk_get_widget_min_size(thumbType, &(aResult->width), &(aResult->height));
+
+        // Add scrollbar's borders
+        nsIntMargin border;
+        nsNativeThemeGTK::GetWidgetBorder(aFrame->PresContext()->DeviceContext(),
+                                          aFrame, aWidgetType, &border);
+        aResult->width += border.left + border.right;
+        aResult->height += border.top + border.bottom;
+
+        // Add track's borders
+        uint8_t trackType = aWidgetType == NS_THEME_SCROLLBAR_VERTICAL ?
+          NS_THEME_SCROLLBARTRACK_VERTICAL : NS_THEME_SCROLLBARTRACK_HORIZONTAL;
+        nsNativeThemeGTK::GetWidgetBorder(aFrame->PresContext()->DeviceContext(),
+                                          aFrame, trackType, &border);
+        aResult->width += border.left + border.right;
+        aResult->height += border.top + border.bottom;
+      } else {
+        MozGtkScrollbarMetrics metrics;
+        moz_gtk_get_scrollbar_metrics(&metrics);
+
+        // Require room for the slider in the track if we don't have buttons.
+        bool hasScrollbarButtons = moz_gtk_has_scrollbar_buttons();
+
+        if (aWidgetType == NS_THEME_SCROLLBAR_VERTICAL) {
+          aResult->width = metrics.slider_width + 2 * metrics.trough_border;
+          if (!hasScrollbarButtons)
+            aResult->height = metrics.min_slider_size + 2 * metrics.trough_border;
+        } else {
+          aResult->height = metrics.slider_width + 2 * metrics.trough_border;
+          if (!hasScrollbarButtons)
+            aResult->width = metrics.min_slider_size + 2 * metrics.trough_border;
+        }
+        *aIsOverridable = false;
+      }
+
+    }
+    break;
+    case NS_THEME_SCROLLBARTHUMB_VERTICAL:
+    case NS_THEME_SCROLLBARTHUMB_HORIZONTAL:
+      {
+        if (gtk_check_version(3,20,0) == nullptr) {
+          moz_gtk_get_widget_min_size(NativeThemeToGtkTheme(aWidgetType, aFrame),
+                                      &(aResult->width), &(aResult->height));
+        } else {
+          MozGtkScrollbarMetrics metrics;
+          moz_gtk_get_scrollbar_metrics(&metrics);
+
+          if (aWidgetType == NS_THEME_SCROLLBARTHUMB_VERTICAL) {
+            aResult->width = metrics.slider_width;
+            aResult->height = metrics.min_slider_size;
+          } else {
+            aResult->height = metrics.slider_width;
+            aResult->width = metrics.min_slider_size;
+          }
+        }
+        *aIsOverridable = false;
+      }
+      break;
+    case NS_THEME_RANGE_THUMB:
+      {
+        gint thumb_length, thumb_height;
+
+        if (IsRangeHorizontal(aFrame)) {
+          moz_gtk_get_scalethumb_metrics(GTK_ORIENTATION_HORIZONTAL, &thumb_length, &thumb_height);
+        } else {
+          moz_gtk_get_scalethumb_metrics(GTK_ORIENTATION_VERTICAL, &thumb_height, &thumb_length);
+        }
+        aResult->width = thumb_length;
+        aResult->height = thumb_height;
+
+        *aIsOverridable = false;
+      }
+      break;
+    case NS_THEME_RANGE:
+      {
+        gint scale_width, scale_height;
+
+        moz_gtk_get_scale_metrics(IsRangeHorizontal(aFrame) ?
+            GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL,
+            &scale_width, &scale_height);
+        aResult->width = scale_width;
+        aResult->height = scale_height;
+
+        *aIsOverridable = true;
+      }
+      break;
+    case NS_THEME_SCALETHUMB_HORIZONTAL:
+    case NS_THEME_SCALETHUMB_VERTICAL:
+      {
+        gint thumb_length, thumb_height;
+
+        if (aWidgetType == NS_THEME_SCALETHUMB_VERTICAL) {
+          moz_gtk_get_scalethumb_metrics(GTK_ORIENTATION_VERTICAL, &thumb_length, &thumb_height);
+          aResult->width = thumb_height;
+          aResult->height = thumb_length;
+        } else {
+          moz_gtk_get_scalethumb_metrics(GTK_ORIENTATION_HORIZONTAL, &thumb_length, &thumb_height);
+          aResult->width = thumb_length;
+          aResult->height = thumb_height;
+        }
+
+        *aIsOverridable = false;
+      }
+      break;
+    case NS_THEME_TAB_SCROLL_ARROW_BACK:
+    case NS_THEME_TAB_SCROLL_ARROW_FORWARD:
+      {
+        moz_gtk_get_tab_scroll_arrow_size(&aResult->width, &aResult->height);
+        *aIsOverridable = false;
+      }
+      break;
+  case NS_THEME_MENULIST_BUTTON:
+    {
+      moz_gtk_get_combo_box_entry_button_size(&aResult->width,
+                                              &aResult->height);
+      *aIsOverridable = false;
+    }
+    break;
+  case NS_THEME_MENUSEPARATOR:
+    {
+      gint separator_height;
+
+      moz_gtk_get_menu_separator_height(&separator_height);
+      aResult->height = separator_height;
+    
+      *aIsOverridable = false;
+    }
+    break;
+  case NS_THEME_CHECKBOX:
+  case NS_THEME_RADIO:
+    {
+      gint indicator_size, indicator_spacing;
+
+      if (aWidgetType == NS_THEME_CHECKBOX) {
+        moz_gtk_checkbox_get_metrics(&indicator_size, &indicator_spacing);
+      } else {
+        moz_gtk_radio_get_metrics(&indicator_size, &indicator_spacing);
+      }
+
+      // Include space for the indicator and the padding around it.
+      aResult->width = indicator_size;
+      aResult->height = indicator_size;
+    }
+    break;
+  case NS_THEME_TOOLBARBUTTON_DROPDOWN:
+  case NS_THEME_BUTTON_ARROW_UP:
+  case NS_THEME_BUTTON_ARROW_DOWN:
+  case NS_THEME_BUTTON_ARROW_NEXT:
+  case NS_THEME_BUTTON_ARROW_PREVIOUS:
+    {
+      moz_gtk_get_arrow_size(MOZ_GTK_TOOLBARBUTTON_ARROW,
+                             &aResult->width, &aResult->height);
+      *aIsOverridable = false;
+    }
+    break;
+  case NS_THEME_CHECKBOX_CONTAINER:
+  case NS_THEME_RADIO_CONTAINER:
+  case NS_THEME_CHECKBOX_LABEL:
+  case NS_THEME_RADIO_LABEL:
+  case NS_THEME_BUTTON:
+  case NS_THEME_MENULIST:
+  case NS_THEME_TOOLBARBUTTON:
+  case NS_THEME_TREEHEADERCELL:
+    {
+      if (aWidgetType == NS_THEME_MENULIST) {
+        // Include the arrow size.
+        moz_gtk_get_arrow_size(MOZ_GTK_DROPDOWN,
+                               &aResult->width, &aResult->height);
+      }
+      // else the minimum size is missing consideration of container
+      // descendants; the value returned here will not be helpful, but the
+      // box model may consider border and padding with child minimum sizes.
+
+      nsIntMargin border;
+      nsNativeThemeGTK::GetWidgetBorder(aFrame->PresContext()->DeviceContext(),
+                                        aFrame, aWidgetType, &border);
+      aResult->width += border.left + border.right;
+      aResult->height += border.top + border.bottom;
+    }
+    break;
+#if (MOZ_WIDGET_GTK == 3)
+  case NS_THEME_NUMBER_INPUT:
+  case NS_THEME_TEXTFIELD:
+    {
+      moz_gtk_get_entry_min_height(&aResult->height);
+    }
+    break;
+#endif
+  case NS_THEME_SEPARATOR:
+    {
+      gint separator_width;
+    
+      moz_gtk_get_toolbar_separator_width(&separator_width);
+    
+      aResult->width = separator_width;
+    }
+    break;
+  case NS_THEME_SPINNER:
+    // hard code these sizes
+    aResult->width = 14;
+    aResult->height = 26;
+    break;
+  case NS_THEME_TREEHEADERSORTARROW:
+  case NS_THEME_SPINNER_UPBUTTON:
+  case NS_THEME_SPINNER_DOWNBUTTON:
+    // hard code these sizes
+    aResult->width = 14;
+    aResult->height = 13;
+    break;
+  case NS_THEME_RESIZER:
+    // same as Windows to make our lives easier
+    aResult->width = aResult->height = 15;
+    *aIsOverridable = false;
+    break;
+  case NS_THEME_TREETWISTY:
+  case NS_THEME_TREETWISTYOPEN:
+    {
+      gint expander_size;
+
+      moz_gtk_get_treeview_expander_size(&expander_size);
+      aResult->width = aResult->height = expander_size;
+      *aIsOverridable = false;
+    }
+    break;
+  }
+
+  *aResult = *aResult * nsScreenGtk::GetGtkMonitorScaleFactor();
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNativeThemeGTK::WidgetStateChanged(nsIFrame* aFrame, uint8_t aWidgetType, 
+                                     nsIAtom* aAttribute, bool* aShouldRepaint,
+                                     const nsAttrValue* aOldValue)
+{
+  // Some widget types just never change state.
+  if (aWidgetType == NS_THEME_TOOLBOX ||
+      aWidgetType == NS_THEME_TOOLBAR ||
+      aWidgetType == NS_THEME_STATUSBAR ||
+      aWidgetType == NS_THEME_STATUSBARPANEL ||
+      aWidgetType == NS_THEME_RESIZERPANEL ||
+      aWidgetType == NS_THEME_PROGRESSCHUNK ||
+      aWidgetType == NS_THEME_PROGRESSCHUNK_VERTICAL ||
+      aWidgetType == NS_THEME_PROGRESSBAR ||
+      aWidgetType == NS_THEME_PROGRESSBAR_VERTICAL ||
+      aWidgetType == NS_THEME_MENUBAR ||
+      aWidgetType == NS_THEME_MENUPOPUP ||
+      aWidgetType == NS_THEME_TOOLTIP ||
+      aWidgetType == NS_THEME_MENUSEPARATOR ||
+      aWidgetType == NS_THEME_WINDOW ||
+      aWidgetType == NS_THEME_DIALOG) {
+    *aShouldRepaint = false;
+    return NS_OK;
+  }
+
+  if ((aWidgetType == NS_THEME_SCROLLBARTHUMB_VERTICAL ||
+       aWidgetType == NS_THEME_SCROLLBARTHUMB_HORIZONTAL) &&
+       aAttribute == nsGkAtoms::active) {
+    *aShouldRepaint = true;
+    return NS_OK;
+  }
+
+  if ((aWidgetType == NS_THEME_SCROLLBARBUTTON_UP ||
+       aWidgetType == NS_THEME_SCROLLBARBUTTON_DOWN ||
+       aWidgetType == NS_THEME_SCROLLBARBUTTON_LEFT ||
+       aWidgetType == NS_THEME_SCROLLBARBUTTON_RIGHT) &&
+      (aAttribute == nsGkAtoms::curpos ||
+       aAttribute == nsGkAtoms::maxpos)) {
+    // If 'curpos' has changed and we are passed its old value, we can
+    // determine whether the button's enablement actually needs to change.
+    if (aAttribute == nsGkAtoms::curpos && aOldValue) {
+      int32_t curpos = CheckIntAttr(aFrame, nsGkAtoms::curpos, 0);
+      int32_t maxpos = CheckIntAttr(aFrame, nsGkAtoms::maxpos, 0);
+      nsAutoString str;
+      aOldValue->ToString(str);
+      nsresult err;
+      int32_t oldCurpos = str.ToInteger(&err);
+      if (str.IsEmpty() || NS_FAILED(err)) {
+        *aShouldRepaint = true;
+      } else {
+        bool disabledBefore = ShouldScrollbarButtonBeDisabled(oldCurpos, maxpos, aWidgetType);
+        bool disabledNow = ShouldScrollbarButtonBeDisabled(curpos, maxpos, aWidgetType);
+        *aShouldRepaint = (disabledBefore != disabledNow);
+      }
+    } else {
+      *aShouldRepaint = true;
+    }
+    return NS_OK;
+  }
+
+  // XXXdwh Not sure what can really be done here.  Can at least guess for
+  // specific widgets that they're highly unlikely to have certain states.
+  // For example, a toolbar doesn't care about any states.
+  if (!aAttribute) {
+    // Hover/focus/active changed.  Always repaint.
+    *aShouldRepaint = true;
+  }
+  else {
+    // Check the attribute to see if it's relevant.  
+    // disabled, checked, dlgtype, default, etc.
+    *aShouldRepaint = false;
+    if (aAttribute == nsGkAtoms::disabled ||
+        aAttribute == nsGkAtoms::checked ||
+        aAttribute == nsGkAtoms::selected ||
+        aAttribute == nsGkAtoms::visuallyselected ||
+        aAttribute == nsGkAtoms::focused ||
+        aAttribute == nsGkAtoms::readonly ||
+        aAttribute == nsGkAtoms::_default ||
+        aAttribute == nsGkAtoms::menuactive ||
+        aAttribute == nsGkAtoms::open ||
+        aAttribute == nsGkAtoms::parentfocused)
+      *aShouldRepaint = true;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNativeThemeGTK::ThemeChanged()
+{
+  memset(mDisabledWidgetTypes, 0, sizeof(mDisabledWidgetTypes));
+  return NS_OK;
+}
+
+NS_IMETHODIMP_(bool)
+nsNativeThemeGTK::ThemeSupportsWidget(nsPresContext* aPresContext,
+                                      nsIFrame* aFrame,
+                                      uint8_t aWidgetType)
+{
+  if (IsWidgetTypeDisabled(mDisabledWidgetTypes, aWidgetType))
+    return false;
+
+  switch (aWidgetType) {
+  // Combobox dropdowns don't support native theming in vertical mode.
+  case NS_THEME_MENULIST:
+  case NS_THEME_MENULIST_TEXT:
+  case NS_THEME_MENULIST_TEXTFIELD:
+    if (aFrame && aFrame->GetWritingMode().IsVertical()) {
+      return false;
+    }
+    MOZ_FALLTHROUGH;
+
+  case NS_THEME_BUTTON:
+  case NS_THEME_BUTTON_FOCUS:
+  case NS_THEME_RADIO:
+  case NS_THEME_CHECKBOX:
+  case NS_THEME_TOOLBOX: // N/A
+  case NS_THEME_TOOLBAR:
+  case NS_THEME_TOOLBARBUTTON:
+  case NS_THEME_DUALBUTTON: // so we can override the border with 0
+  case NS_THEME_TOOLBARBUTTON_DROPDOWN:
+  case NS_THEME_BUTTON_ARROW_UP:
+  case NS_THEME_BUTTON_ARROW_DOWN:
+  case NS_THEME_BUTTON_ARROW_NEXT:
+  case NS_THEME_BUTTON_ARROW_PREVIOUS:
+  case NS_THEME_SEPARATOR:
+  case NS_THEME_TOOLBARGRIPPER:
+  case NS_THEME_STATUSBAR:
+  case NS_THEME_STATUSBARPANEL:
+  case NS_THEME_RESIZERPANEL:
+  case NS_THEME_RESIZER:
+  case NS_THEME_LISTBOX:
+    // case NS_THEME_LISTITEM:
+  case NS_THEME_TREEVIEW:
+    // case NS_THEME_TREEITEM:
+  case NS_THEME_TREETWISTY:
+    // case NS_THEME_TREELINE:
+    // case NS_THEME_TREEHEADER:
+  case NS_THEME_TREEHEADERCELL:
+  case NS_THEME_TREEHEADERSORTARROW:
+  case NS_THEME_TREETWISTYOPEN:
+    case NS_THEME_PROGRESSBAR:
+    case NS_THEME_PROGRESSCHUNK:
+    case NS_THEME_PROGRESSBAR_VERTICAL:
+    case NS_THEME_PROGRESSCHUNK_VERTICAL:
+    case NS_THEME_TAB:
+    // case NS_THEME_TABPANEL:
+    case NS_THEME_TABPANELS:
+    case NS_THEME_TAB_SCROLL_ARROW_BACK:
+    case NS_THEME_TAB_SCROLL_ARROW_FORWARD:
+  case NS_THEME_TOOLTIP:
+  case NS_THEME_SPINNER:
+  case NS_THEME_SPINNER_UPBUTTON:
+  case NS_THEME_SPINNER_DOWNBUTTON:
+  case NS_THEME_SPINNER_TEXTFIELD:
+    // case NS_THEME_SCROLLBAR:  (n/a for gtk)
+    // case NS_THEME_SCROLLBAR_SMALL: (n/a for gtk)
+  case NS_THEME_SCROLLBARBUTTON_UP:
+  case NS_THEME_SCROLLBARBUTTON_DOWN:
+  case NS_THEME_SCROLLBARBUTTON_LEFT:
+  case NS_THEME_SCROLLBARBUTTON_RIGHT:
+  case NS_THEME_SCROLLBAR_HORIZONTAL:
+  case NS_THEME_SCROLLBAR_VERTICAL:
+  case NS_THEME_SCROLLBARTRACK_HORIZONTAL:
+  case NS_THEME_SCROLLBARTRACK_VERTICAL:
+  case NS_THEME_SCROLLBARTHUMB_HORIZONTAL:
+  case NS_THEME_SCROLLBARTHUMB_VERTICAL:
+  case NS_THEME_NUMBER_INPUT:
+  case NS_THEME_TEXTFIELD:
+  case NS_THEME_TEXTFIELD_MULTILINE:
+  case NS_THEME_RANGE:
+  case NS_THEME_RANGE_THUMB:
+  case NS_THEME_SCALE_HORIZONTAL:
+  case NS_THEME_SCALETHUMB_HORIZONTAL:
+  case NS_THEME_SCALE_VERTICAL:
+  case NS_THEME_SCALETHUMB_VERTICAL:
+    // case NS_THEME_SCALETHUMBSTART:
+    // case NS_THEME_SCALETHUMBEND:
+    // case NS_THEME_SCALETHUMBTICK:
+  case NS_THEME_CHECKBOX_CONTAINER:
+  case NS_THEME_RADIO_CONTAINER:
+  case NS_THEME_CHECKBOX_LABEL:
+  case NS_THEME_RADIO_LABEL:
+  case NS_THEME_MENUBAR:
+  case NS_THEME_MENUPOPUP:
+  case NS_THEME_MENUITEM:
+  case NS_THEME_MENUARROW:
+  case NS_THEME_MENUSEPARATOR:
+  case NS_THEME_CHECKMENUITEM:
+  case NS_THEME_RADIOMENUITEM:
+  case NS_THEME_SPLITTER:
+  case NS_THEME_WINDOW:
+  case NS_THEME_DIALOG:
+#if (MOZ_WIDGET_GTK == 3)
+  case NS_THEME_GTK_INFO_BAR:
+#endif
+    return !IsWidgetStyled(aPresContext, aFrame, aWidgetType);
+
+  case NS_THEME_MENULIST_BUTTON:
+    if (aFrame && aFrame->GetWritingMode().IsVertical()) {
+      return false;
+    }
+    // "Native" dropdown buttons cause padding and margin problems, but only
+    // in HTML so allow them in XUL.
+    return (!aFrame || IsFrameContentNodeInNamespace(aFrame, kNameSpaceID_XUL)) &&
+           !IsWidgetStyled(aPresContext, aFrame, aWidgetType);
+
+  case NS_THEME_FOCUS_OUTLINE:
+    return true;
+  }
+
+  return false;
+}
+
+NS_IMETHODIMP_(bool)
+nsNativeThemeGTK::WidgetIsContainer(uint8_t aWidgetType)
+{
+  // XXXdwh At some point flesh all of this out.
+  if (aWidgetType == NS_THEME_MENULIST_BUTTON ||
+      aWidgetType == NS_THEME_RADIO ||
+      aWidgetType == NS_THEME_RANGE_THUMB ||
+      aWidgetType == NS_THEME_CHECKBOX ||
+      aWidgetType == NS_THEME_TAB_SCROLL_ARROW_BACK ||
+      aWidgetType == NS_THEME_TAB_SCROLL_ARROW_FORWARD ||
+      aWidgetType == NS_THEME_BUTTON_ARROW_UP ||
+      aWidgetType == NS_THEME_BUTTON_ARROW_DOWN ||
+      aWidgetType == NS_THEME_BUTTON_ARROW_NEXT ||
+      aWidgetType == NS_THEME_BUTTON_ARROW_PREVIOUS)
+    return false;
+  return true;
+}
+
+bool
+nsNativeThemeGTK::ThemeDrawsFocusForWidget(uint8_t aWidgetType)
+{
+   if (aWidgetType == NS_THEME_MENULIST ||
+      aWidgetType == NS_THEME_BUTTON || 
+      aWidgetType == NS_THEME_TREEHEADERCELL)
+    return true;
+  
+  return false;
+}
+
+bool
+nsNativeThemeGTK::ThemeNeedsComboboxDropmarker()
+{
+  return false;
+}
+
+nsITheme::Transparency
+nsNativeThemeGTK::GetWidgetTransparency(nsIFrame* aFrame, uint8_t aWidgetType)
+{
+  switch (aWidgetType) {
+  // These widgets always draw a default background.
+#if (MOZ_WIDGET_GTK == 2)
+  case NS_THEME_TOOLBAR:
+  case NS_THEME_MENUBAR:
+#endif
+  case NS_THEME_MENUPOPUP:
+  case NS_THEME_WINDOW:
+  case NS_THEME_DIALOG:
+    return eOpaque;
+  case NS_THEME_SCROLLBAR_VERTICAL:
+  case NS_THEME_SCROLLBAR_HORIZONTAL:
+#if (MOZ_WIDGET_GTK == 3)
+    // Make scrollbar tracks opaque on the window's scroll frame to prevent
+    // leaf layers from overlapping. See bug 1179780.
+    if (!(CheckBooleanAttr(aFrame, nsGkAtoms::root_) &&
+          aFrame->PresContext()->IsRootContentDocument() &&
+          IsFrameContentNodeInNamespace(aFrame, kNameSpaceID_XUL)))
+      return eTransparent;
+#endif
+    return eOpaque;
+  // Tooltips use gtk_paint_flat_box() on Gtk2
+  // but are shaped on Gtk3
+  case NS_THEME_TOOLTIP:
+#if (MOZ_WIDGET_GTK == 2)
+    return eOpaque;
+#else
+    return eTransparent;
+#endif
+  }
+
+  return eUnknownTransparency;
+}
diff -rupN a/widget/gtk/nsScreenGtk.cpp b/widget/gtk/nsScreenGtk.cpp
--- a/widget/gtk/nsScreenGtk.cpp	2016-11-14 11:12:28.000000000 -0500
+++ b/widget/gtk/nsScreenGtk.cpp	2017-03-07 23:40:34.292635643 -0500
@@ -50,7 +50,7 @@ nsScreenGtk :: GetRect(int32_t *outLeft,
   *outHeight = mRect.height;
 
   return NS_OK;
-  
+
 } // GetRect
 
 
@@ -63,7 +63,7 @@ nsScreenGtk :: GetAvailRect(int32_t *out
   *outHeight = mAvailRect.height;
 
   return NS_OK;
-  
+
 } // GetAvailRect
 
 gint
@@ -93,7 +93,7 @@ nsScreenGtk :: GetDPIScale()
   return dpiScale;
 }
 
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsScreenGtk :: GetPixelDepth(int32_t *aPixelDepth)
 {
   GdkVisual * visual = gdk_screen_get_system_visual(gdk_screen_get_default());
@@ -103,7 +103,7 @@ nsScreenGtk :: GetPixelDepth(int32_t *aP
 
 } // GetPixelDepth
 
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsScreenGtk :: GetColorDepth(int32_t *aColorDepth)
 {
   return GetPixelDepth ( aColorDepth );
@@ -130,6 +130,8 @@ nsScreenGtk :: Init (GdkWindow *aRootWin
   // versions of GDK predating the GdkScreen object.  See bug 256646.
   mAvailRect = mRect = nsIntRect(0, 0, width, height);
 
+  return;
+
 #ifdef MOZ_X11
   // We need to account for the taskbar, etc in the available rect.
   // See http://freedesktop.org/Standards/wm-spec/index.html#id2767771
diff -rupN a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
--- a/widget/gtk/nsWindow.cpp	2017-01-23 11:13:56.000000000 -0500
+++ b/widget/gtk/nsWindow.cpp	2017-03-07 23:43:12.282644105 -0500
@@ -5,6 +5,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include <assert.h>
 #include "nsWindow.h"
 
 #include "mozilla/ArrayUtils.h"
@@ -58,6 +59,10 @@
 #include <gtk/gtkprivate.h>
 #endif
 
+#if defined(GDK_WINDOWING_WAYLAND)
+#include <gdk/gdkwayland.h>
+#endif
+
 #include "nsGkAtoms.h"
 
 #ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
@@ -303,11 +308,14 @@ public:
 
     guint32 GetCurrentTime() const
     {
-        return gdk_x11_get_server_time(mWindow);
+        //return gdk_x11_get_server_time(mWindow);
+        return g_get_monotonic_time()/1000;
     }
 
     void GetTimeAsyncForPossibleBackwardsSkew(const TimeStamp& aNow)
     {
+        return;
+
         // Check for in-flight request
         if (!mAsyncUpdateStart.IsNull()) {
             return;
@@ -326,6 +334,8 @@ public:
     gboolean PropertyNotifyHandler(GtkWidget* aWidget,
                                    GdkEventProperty* aEvent)
     {
+        return FALSE;
+
         if (aEvent->atom !=
             gdk_x11_xatom_to_atom(TimeStampPropAtom())) {
             return FALSE;
@@ -457,6 +467,10 @@ nsWindow::nsWindow()
     mXVisual  = nullptr;
     mXDepth   = 0;
 #endif /* MOZ_X11 */
+#ifdef GDK_WINDOWING_WAYLAND
+    mWaylandSurface = nullptr;
+#endif
+
     mPluginType          = PluginType_NONE;
 
     if (!gGlobalsInitialized) {
@@ -1384,6 +1398,9 @@ SetUserTimeAndStartupIDForActivatedWindo
 /* static */ guint32
 nsWindow::GetLastUserInputTime()
 {
+    if (!GDK_IS_X11_DISPLAY(gdk_display_get_default()))
+        return sLastUserInputTime;
+
     // gdk_x11_display_get_user_time tracks button and key presses,
     // DESKTOP_STARTUP_ID used to start the app, drop events from external
     // drags, WM_DELETE_WINDOW delete events, but not usually mouse motion nor
@@ -1734,12 +1751,17 @@ nsWindow::GetNativeData(uint32_t aDataTy
         return (void*)mPluginNativeWindow->window;
 
     case NS_NATIVE_DISPLAY: {
-#ifdef MOZ_X11
         GdkDisplay* gdkDisplay = gdk_display_get_default();
+#if defined(MOZ_X11)
         if (GDK_IS_X11_DISPLAY(gdkDisplay)) {
           return GDK_DISPLAY_XDISPLAY(gdkDisplay);
         }
-#endif /* MOZ_X11 */
+#endif
+#if defined(GDK_WINDOWING_WAYLAND)
+        if (GDK_IS_WAYLAND_DISPLAY(gdkDisplay)) {
+          return gdk_wayland_display_get_wl_display(gdkDisplay);
+        }
+#endif
         return nullptr;
     }
     case NS_NATIVE_SHELLWIDGET:
@@ -1763,10 +1785,15 @@ nsWindow::GetNativeData(uint32_t aDataTy
     }
     case NS_NATIVE_OPENGL_CONTEXT:
       return nullptr;
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(GDK_WINDOWING_WAYLAND)
     case NS_NATIVE_COMPOSITOR_DISPLAY:
-        return gfxPlatformGtk::GetPlatform()->GetCompositorDisplay();
-#endif // MOZ_X11
+        if (mIsX11Display)
+          return gfxPlatformGtk::GetPlatform()->GetXCompositorDisplay();
+        else
+          return gfxPlatformGtk::GetPlatform()->GetWaylandCompositorDisplay();
+    case NS_NATIVE_COMPOSITOR_DISPLAY_X11:
+        return (void *)mIsX11Display;
+#endif
     default:
         NS_WARNING("nsWindow::GetNativeData called with bad value");
         return nullptr;
@@ -2117,6 +2144,8 @@ gboolean
 nsWindow::OnExposeEvent(cairo_t *cr)
 #endif
 {
+    fprintf(stderr, "*********** Expose start nsWindow %p\n", this);
+  
     // Send any pending resize events so that layout can update.
     // May run event loop.
     MaybeDispatchResized();
@@ -2133,6 +2162,12 @@ nsWindow::OnExposeEvent(cairo_t *cr)
     if (!listener)
         return FALSE;
 
+#ifdef GDK_WINDOWING_WAYLAND
+    // We don't have any Wayland surface to paint to
+    if (mContainer && !mIsX11Display && !moz_container_map_wl_surface(mContainer))
+        return FALSE;
+#endif
+
     LayoutDeviceIntRegion exposeRegion;
 #if (MOZ_WIDGET_GTK == 2)
     if (!ExtractExposeRegion(exposeRegion, aEvent)) {
@@ -3767,7 +3802,13 @@ nsWindow::Create(nsIWidget* aParent,
         // We can't draw directly to top-level window when client side
         // decorations are enabled. We use container with GdkWindow instead.
         GtkStyleContext* style = gtk_widget_get_style_context(mShell);
+
+        // Always draw to mozcontainer on Wayland
         shellHasCSD = gtk_style_context_has_class(style, "csd");
+        // We use mContainer to draw on Wayland
+        if (!mIsX11Display) {
+            shellHasCSD = true;
+        }
 #endif
         if (!shellHasCSD) {
             // Use mShell's window for drawing and events.
@@ -3775,13 +3816,14 @@ nsWindow::Create(nsIWidget* aParent,
             // Prevent GtkWindow from painting a background to flicker.
             gtk_widget_set_app_paintable(mShell, TRUE);
         }
+
         // Set up event widget
         eventWidget = shellHasCSD ? container : mShell;
         gtk_widget_add_events(eventWidget, kEvents);
 
         gtk_container_add(GTK_CONTAINER(mShell), container);
         gtk_widget_realize(container);
-
+        
         // make sure this is the focus widget in the container
         gtk_widget_show(container);
         gtk_widget_grab_focus(container);
@@ -4015,8 +4057,14 @@ nsWindow::Create(nsIWidget* aParent,
 
       mSurfaceProvider.Initialize(mXDisplay, mXWindow, mXVisual, mXDepth);
     }
+#ifdef GDK_WINDOWING_WAYLAND
+    else {
+      mWaylandDisplay = gdk_wayland_display_get_wl_display(gdk_display_get_default());
+      mWaylandSurface = moz_container_get_wl_surface(MOZ_CONTAINER(mContainer));
+      mSurfaceProvider.Initialize(this, mWaylandDisplay, mWaylandSurface);
+    }
+#endif
 #endif
-
     return NS_OK;
 }
 
@@ -4197,7 +4245,6 @@ nsWindow::NativeShow(bool aAction)
             if (mWindowType != eWindowType_invisible) {
                 SetUserTimeAndStartupIDForActivatedWindow(mShell);
             }
-
             gtk_widget_show(mShell);
         }
         else if (mContainer) {
@@ -4699,14 +4746,10 @@ nsWindow::GrabPointer(guint32 aTime)
     if (!mGdkWindow)
         return;
 
+    GdkSeat *gdkSeat = gdk_display_get_default_seat(gdk_display_get_default());
     gint retval;
-    retval = gdk_pointer_grab(mGdkWindow, TRUE,
-                              (GdkEventMask)(GDK_BUTTON_PRESS_MASK |
-                                             GDK_BUTTON_RELEASE_MASK |
-                                             GDK_ENTER_NOTIFY_MASK |
-                                             GDK_LEAVE_NOTIFY_MASK |
-                                             GDK_POINTER_MOTION_MASK),
-                              (GdkWindow *)nullptr, nullptr, aTime);
+    retval = gdk_seat_grab(gdkSeat, mGdkWindow, GDK_SEAT_CAPABILITY_ALL_POINTING, TRUE,
+                           nullptr, nullptr, nullptr, nullptr);
 
     if (retval == GDK_GRAB_NOT_VIEWABLE) {
         LOG(("GrabPointer: window not viewable; will retry\n"));
@@ -4730,7 +4773,8 @@ nsWindow::ReleaseGrabs(void)
     LOG(("ReleaseGrabs\n"));
 
     mRetryPointerGrab = false;
-    gdk_pointer_ungrab(GDK_CURRENT_TIME);
+    GdkSeat *gdkSeat = gdk_display_get_default_seat(gdk_display_get_default());
+    gdk_seat_ungrab(gdkSeat);
 }
 
 GtkWidget *
@@ -6681,8 +6725,7 @@ nsWindow::BeginResizeDrag(WidgetGUIEvent
             window_edge = GDK_WINDOW_EDGE_NORTH_WEST;
         } else if (aHorizontal == 0) {
             window_edge = GDK_WINDOW_EDGE_NORTH;
-        } else {
-            window_edge = GDK_WINDOW_EDGE_NORTH_EAST;
+        } else {            window_edge = GDK_WINDOW_EDGE_NORTH_EAST;
         }
     } else if (aVertical == 0) {
         if (aHorizontal < 0) {
@@ -7022,9 +7065,18 @@ nsWindow::RoundsWidgetCoordinatesTo()
 void nsWindow::GetCompositorWidgetInitData(mozilla::widget::CompositorWidgetInitData* aInitData)
 {
   #ifdef MOZ_X11
-  *aInitData = mozilla::widget::CompositorWidgetInitData(
+  if (mIsX11Display) {
+    *aInitData = mozilla::widget::CompositorWidgetInitData(
                                   mXWindow,
                                   nsCString(XDisplayString(mXDisplay)),
                                   GetClientSize());
+  #ifdef GDK_WINDOWING_WAYLAND
+  } else {
+    *aInitData = mozilla::widget::CompositorWidgetInitData(
+                                  (uintptr_t)mWaylandSurface,
+                                  nsCString(nullptr),
+                                  GetClientSize());
+  }
+  #endif
   #endif
 }
diff -rupN a/widget/gtk/nsWindow.cpp.orig b/widget/gtk/nsWindow.cpp.orig
--- a/widget/gtk/nsWindow.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/widget/gtk/nsWindow.cpp.orig	2017-03-07 23:42:38.658642304 -0500
@@ -0,0 +1,7091 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <assert.h>
+#include "nsWindow.h"
+
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/EventForwards.h"
+#include "mozilla/MiscEvents.h"
+#include "mozilla/MouseEvents.h"
+#include "mozilla/RefPtr.h"
+#include "mozilla/TextEventDispatcher.h"
+#include "mozilla/TextEvents.h"
+#include "mozilla/TimeStamp.h"
+#include "mozilla/TouchEvents.h"
+#include "mozilla/UniquePtrExtensions.h"
+#include <algorithm>
+
+#include "GeckoProfiler.h"
+
+#include "prlink.h"
+#include "nsGTKToolkit.h"
+#include "nsIRollupListener.h"
+#include "nsIDOMNode.h"
+
+#include "nsWidgetsCID.h"
+#include "nsDragService.h"
+#include "nsIWidgetListener.h"
+#include "nsIScreenManager.h"
+#include "SystemTimeConverter.h"
+
+#include "nsGtkKeyUtils.h"
+#include "nsGtkCursors.h"
+#include "nsScreenGtk.h"
+
+#include <gtk/gtk.h>
+#if (MOZ_WIDGET_GTK == 3)
+#include <gtk/gtkx.h>
+#endif
+#ifdef MOZ_X11
+#include <gdk/gdkx.h>
+#include <X11/Xatom.h>
+#include <X11/extensions/XShm.h>
+#include <X11/extensions/shape.h>
+#if (MOZ_WIDGET_GTK == 3)
+#include <gdk/gdkkeysyms-compat.h>
+#endif
+
+#if (MOZ_WIDGET_GTK == 2)
+#include "gtk2xtbin.h"
+#endif
+#endif /* MOZ_X11 */
+#include <gdk/gdkkeysyms.h>
+#if (MOZ_WIDGET_GTK == 2)
+#include <gtk/gtkprivate.h>
+#endif
+
+#if defined(GDK_WINDOWING_WAYLAND)
+#include <gdk/gdkwayland.h>
+#endif
+
+#include "nsGkAtoms.h"
+
+#ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
+#define SN_API_NOT_YET_FROZEN
+#include <startup-notification-1.0/libsn/sn.h>
+#endif
+
+#include "mozilla/Assertions.h"
+#include "mozilla/Likely.h"
+#include "mozilla/Preferences.h"
+#include "nsIPrefService.h"
+#include "nsIGConfService.h"
+#include "nsIServiceManager.h"
+#include "nsIStringBundle.h"
+#include "nsGfxCIID.h"
+#include "nsGtkUtils.h"
+#include "nsIObserverService.h"
+#include "mozilla/layers/LayersTypes.h"
+#include "nsIIdleServiceInternal.h"
+#include "nsIPropertyBag2.h"
+#include "GLContext.h"
+#include "gfx2DGlue.h"
+#include "nsPluginNativeWindowGtk.h"
+
+#ifdef ACCESSIBILITY
+#include "mozilla/a11y/Accessible.h"
+#include "mozilla/a11y/Platform.h"
+#include "nsAccessibilityService.h"
+
+using namespace mozilla;
+using namespace mozilla::widget;
+#endif
+
+/* For SetIcon */
+#include "nsAppDirectoryServiceDefs.h"
+#include "nsXPIDLString.h"
+#include "nsIFile.h"
+
+/* SetCursor(imgIContainer*) */
+#include <gdk/gdk.h>
+#include <wchar.h>
+#include "imgIContainer.h"
+#include "nsGfxCIID.h"
+#include "nsImageToPixbuf.h"
+#include "nsIInterfaceRequestorUtils.h"
+#include "ClientLayerManager.h"
+
+#include "gfxPlatformGtk.h"
+#include "gfxContext.h"
+#include "gfxImageSurface.h"
+#include "gfxUtils.h"
+#include "Layers.h"
+#include "GLContextProvider.h"
+#include "mozilla/gfx/2D.h"
+#include "mozilla/gfx/HelpersCairo.h"
+#include "mozilla/layers/CompositorBridgeParent.h"
+#include "mozilla/layers/CompositorThread.h"
+
+#ifdef MOZ_X11
+#include "X11CompositorWidget.h"
+#include "gfxXlibSurface.h"
+#include "WindowSurfaceX11Image.h"
+#include "WindowSurfaceX11SHM.h"
+#include "WindowSurfaceXRender.h"
+#endif // MOZ_X11
+
+#include "nsShmImage.h"
+
+#include "nsIDOMWheelEvent.h"
+
+#include "NativeKeyBindings.h"
+
+#include <dlfcn.h>
+
+#include "mozilla/layers/APZCTreeManager.h"
+
+using namespace mozilla;
+using namespace mozilla::gfx;
+using namespace mozilla::widget;
+using namespace mozilla::layers;
+using mozilla::gl::GLContext;
+
+// Don't put more than this many rects in the dirty region, just fluff
+// out to the bounding-box if there are more
+#define MAX_RECTS_IN_REGION 100
+
+const gint kEvents = GDK_EXPOSURE_MASK | GDK_STRUCTURE_MASK |
+                     GDK_VISIBILITY_NOTIFY_MASK |
+                     GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
+                     GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+#if GTK_CHECK_VERSION(3,4,0)
+                     GDK_SMOOTH_SCROLL_MASK |
+                     GDK_TOUCH_MASK |
+#endif
+                     GDK_SCROLL_MASK |
+                     GDK_POINTER_MOTION_MASK |
+                     GDK_PROPERTY_CHANGE_MASK;
+
+/* utility functions */
+static bool       is_mouse_in_window(GdkWindow* aWindow,
+                                     gdouble aMouseX, gdouble aMouseY);
+static nsWindow  *get_window_for_gtk_widget(GtkWidget *widget);
+static nsWindow  *get_window_for_gdk_window(GdkWindow *window);
+static GtkWidget *get_gtk_widget_for_gdk_window(GdkWindow *window);
+static GdkCursor *get_gtk_cursor(nsCursor aCursor);
+
+static GdkWindow *get_inner_gdk_window (GdkWindow *aWindow,
+                                        gint x, gint y,
+                                        gint *retx, gint *rety);
+
+static inline bool is_context_menu_key(const WidgetKeyboardEvent& inKeyEvent);
+
+static int    is_parent_ungrab_enter(GdkEventCrossing *aEvent);
+static int    is_parent_grab_leave(GdkEventCrossing *aEvent);
+
+static void GetBrandName(nsXPIDLString& brandName);
+
+/* callbacks from widgets */
+#if (MOZ_WIDGET_GTK == 2)
+static gboolean expose_event_cb           (GtkWidget *widget,
+                                           GdkEventExpose *event);
+#else
+static gboolean expose_event_cb           (GtkWidget *widget,
+                                           cairo_t *rect);
+#endif
+static gboolean configure_event_cb        (GtkWidget *widget,
+                                           GdkEventConfigure *event);
+static void     container_unrealize_cb    (GtkWidget *widget);
+static void     size_allocate_cb          (GtkWidget *widget,
+                                           GtkAllocation *allocation);
+static gboolean delete_event_cb           (GtkWidget *widget,
+                                           GdkEventAny *event);
+static gboolean enter_notify_event_cb     (GtkWidget *widget,
+                                           GdkEventCrossing *event);
+static gboolean leave_notify_event_cb     (GtkWidget *widget,
+                                           GdkEventCrossing *event);
+static gboolean motion_notify_event_cb    (GtkWidget *widget,
+                                           GdkEventMotion *event);
+static gboolean button_press_event_cb     (GtkWidget *widget,
+                                           GdkEventButton *event);
+static gboolean button_release_event_cb   (GtkWidget *widget,
+                                           GdkEventButton *event);
+static gboolean focus_in_event_cb         (GtkWidget *widget,
+                                           GdkEventFocus *event);
+static gboolean focus_out_event_cb        (GtkWidget *widget,
+                                           GdkEventFocus *event);
+static gboolean key_press_event_cb        (GtkWidget *widget,
+                                           GdkEventKey *event);
+static gboolean key_release_event_cb      (GtkWidget *widget,
+                                           GdkEventKey *event);
+static gboolean property_notify_event_cb  (GtkWidget *widget,
+                                           GdkEventProperty *event);
+static gboolean scroll_event_cb           (GtkWidget *widget,
+                                           GdkEventScroll *event);
+static gboolean visibility_notify_event_cb(GtkWidget *widget,
+                                           GdkEventVisibility *event);
+static void     hierarchy_changed_cb      (GtkWidget *widget,
+                                           GtkWidget *previous_toplevel);
+static gboolean window_state_event_cb     (GtkWidget *widget,
+                                           GdkEventWindowState *event);
+static void     theme_changed_cb          (GtkSettings *settings,
+                                           GParamSpec *pspec,
+                                           nsWindow *data);
+static void     check_resize_cb           (GtkContainer* container,
+                                           gpointer user_data);
+
+#if (MOZ_WIDGET_GTK == 3)
+static void     scale_changed_cb          (GtkWidget* widget,
+                                           GParamSpec* aPSpec,
+                                           gpointer aPointer);
+#endif
+#if GTK_CHECK_VERSION(3,4,0)
+static gboolean touch_event_cb            (GtkWidget* aWidget,
+                                           GdkEventTouch* aEvent);
+#endif
+static nsWindow* GetFirstNSWindowForGDKWindow (GdkWindow *aGdkWindow);
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#ifdef MOZ_X11
+static GdkFilterReturn popup_take_focus_filter (GdkXEvent *gdk_xevent,
+                                                GdkEvent *event,
+                                                gpointer data);
+static GdkFilterReturn plugin_window_filter_func (GdkXEvent *gdk_xevent,
+                                                  GdkEvent *event,
+                                                  gpointer data);
+static GdkFilterReturn plugin_client_message_filter (GdkXEvent *xevent,
+                                                     GdkEvent *event,
+                                                     gpointer data);
+#endif /* MOZ_X11 */
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+static gboolean drag_motion_event_cb      (GtkWidget *aWidget,
+                                           GdkDragContext *aDragContext,
+                                           gint aX,
+                                           gint aY,
+                                           guint aTime,
+                                           gpointer aData);
+static void     drag_leave_event_cb       (GtkWidget *aWidget,
+                                           GdkDragContext *aDragContext,
+                                           guint aTime,
+                                           gpointer aData);
+static gboolean drag_drop_event_cb        (GtkWidget *aWidget,
+                                           GdkDragContext *aDragContext,
+                                           gint aX,
+                                           gint aY,
+                                           guint aTime,
+                                           gpointer aData);
+static void    drag_data_received_event_cb(GtkWidget *aWidget,
+                                           GdkDragContext *aDragContext,
+                                           gint aX,
+                                           gint aY,
+                                           GtkSelectionData  *aSelectionData,
+                                           guint aInfo,
+                                           guint32 aTime,
+                                           gpointer aData);
+
+/* initialization static functions */
+static nsresult    initialize_prefs        (void);
+
+static guint32 sLastUserInputTime = GDK_CURRENT_TIME;
+static guint32 sRetryGrabTime;
+
+static SystemTimeConverter<guint32>&
+TimeConverter() {
+    static SystemTimeConverter<guint32> sTimeConverterSingleton;
+    return sTimeConverterSingleton;
+}
+
+namespace mozilla {
+
+class CurrentX11TimeGetter
+{
+public:
+    explicit CurrentX11TimeGetter(GdkWindow* aWindow)
+        : mWindow(aWindow)
+        , mAsyncUpdateStart()
+    {
+    }
+
+    guint32 GetCurrentTime() const
+    {
+        //return gdk_x11_get_server_time(mWindow);
+        return g_get_monotonic_time()/1000;
+    }
+
+    void GetTimeAsyncForPossibleBackwardsSkew(const TimeStamp& aNow)
+    {
+        return;
+
+        // Check for in-flight request
+        if (!mAsyncUpdateStart.IsNull()) {
+            return;
+        }
+        mAsyncUpdateStart = aNow;
+
+        Display* xDisplay = GDK_WINDOW_XDISPLAY(mWindow);
+        Window xWindow = GDK_WINDOW_XID(mWindow);
+        unsigned char c = 'a';
+        Atom timeStampPropAtom = TimeStampPropAtom();
+        XChangeProperty(xDisplay, xWindow, timeStampPropAtom,
+                        timeStampPropAtom, 8, PropModeReplace, &c, 1);
+        XFlush(xDisplay);
+    }
+
+    gboolean PropertyNotifyHandler(GtkWidget* aWidget,
+                                   GdkEventProperty* aEvent)
+    {
+        return FALSE;
+
+        if (aEvent->atom !=
+            gdk_x11_xatom_to_atom(TimeStampPropAtom())) {
+            return FALSE;
+        }
+
+        guint32 eventTime = aEvent->time;
+        TimeStamp lowerBound = mAsyncUpdateStart;
+
+        TimeConverter().CompensateForBackwardsSkew(eventTime, lowerBound);
+        mAsyncUpdateStart = TimeStamp();
+        return TRUE;
+    }
+
+private:
+    static Atom TimeStampPropAtom() {
+        return gdk_x11_get_xatom_by_name_for_display(
+            gdk_display_get_default(), "GDK_TIMESTAMP_PROP");
+    }
+
+    // This is safe because this class is stored as a member of mWindow and
+    // won't outlive it.
+    GdkWindow* mWindow;
+    TimeStamp  mAsyncUpdateStart;
+};
+
+} // namespace mozilla
+
+static NS_DEFINE_IID(kCDragServiceCID,  NS_DRAGSERVICE_CID);
+
+// The window from which the focus manager asks us to dispatch key events.
+static nsWindow         *gFocusWindow          = nullptr;
+static bool              gBlockActivateEvent   = false;
+static bool              gGlobalsInitialized   = false;
+static bool              gRaiseWindows         = true;
+static nsWindow         *gPluginFocusWindow    = nullptr;
+
+#if GTK_CHECK_VERSION(3,4,0)
+static uint32_t          gLastTouchID = 0;
+#endif
+
+#define NS_WINDOW_TITLE_MAX_LENGTH 4095
+
+// If after selecting profile window, the startup fail, please refer to
+// http://bugzilla.gnome.org/show_bug.cgi?id=88940
+
+// needed for imgIContainer cursors
+// GdkDisplay* was added in 2.2
+typedef struct _GdkDisplay GdkDisplay;
+
+#define kWindowPositionSlop 20
+
+// cursor cache
+static GdkCursor *gCursorCache[eCursorCount];
+
+static GtkWidget *gInvisibleContainer = nullptr;
+
+// Sometimes this actually also includes the state of the modifier keys, but
+// only the button state bits are used.
+static guint gButtonState;
+
+static inline int32_t
+GetBitmapStride(int32_t width)
+{
+#if defined(MOZ_X11) || (MOZ_WIDGET_GTK == 2)
+  return (width+7)/8;
+#else
+  return cairo_format_stride_for_width(CAIRO_FORMAT_A1, width);
+#endif
+}
+
+static inline bool TimestampIsNewerThan(guint32 a, guint32 b)
+{
+    // Timestamps are just the least significant bits of a monotonically
+    // increasing function, and so the use of unsigned overflow arithmetic.
+    return a - b <= G_MAXUINT32/2;
+}
+
+static void
+UpdateLastInputEventTime(void *aGdkEvent)
+{
+    nsCOMPtr<nsIIdleServiceInternal> idleService =
+        do_GetService("@mozilla.org/widget/idleservice;1");
+    if (idleService) {
+        idleService->ResetIdleTimeOut(0);
+    }
+
+    guint timestamp = gdk_event_get_time(static_cast<GdkEvent*>(aGdkEvent));
+    if (timestamp == GDK_CURRENT_TIME)
+        return;
+
+    sLastUserInputTime = timestamp;
+}
+
+NS_IMPL_ISUPPORTS_INHERITED0(nsWindow, nsBaseWidget)
+
+nsWindow::nsWindow()
+{
+    mIsTopLevel          = false;
+    mIsDestroyed         = false;
+    mListenForResizes    = false;
+    mNeedsDispatchResized = false;
+    mIsShown             = false;
+    mNeedsShow           = false;
+    mEnabled             = true;
+    mCreated             = false;
+#if GTK_CHECK_VERSION(3,4,0)
+    mHandleTouchEvent    = false;
+#endif
+    mIsDragPopup         = false;
+    mIsX11Display        = GDK_IS_X11_DISPLAY(gdk_display_get_default());
+
+    mContainer           = nullptr;
+    mGdkWindow           = nullptr;
+    mShell               = nullptr;
+    mPluginNativeWindow  = nullptr;
+    mHasMappedToplevel   = false;
+    mIsFullyObscured     = false;
+    mRetryPointerGrab    = false;
+    mWindowType          = eWindowType_child;
+    mSizeState           = nsSizeMode_Normal;
+    mLastSizeMode        = nsSizeMode_Normal;
+    mSizeConstraints.mMaxSize = GetSafeWindowSize(mSizeConstraints.mMaxSize);
+
+#ifdef MOZ_X11
+    mOldFocusWindow      = 0;
+
+    mXDisplay = nullptr;
+    mXWindow  = X11None;
+    mXVisual  = nullptr;
+    mXDepth   = 0;
+#endif /* MOZ_X11 */
+#ifdef GDK_WINDOWING_WAYLAND
+    mWaylandSurface = nullptr;
+#endif
+
+    mPluginType          = PluginType_NONE;
+
+    if (!gGlobalsInitialized) {
+        gGlobalsInitialized = true;
+
+        // It's OK if either of these fail, but it may not be one day.
+        initialize_prefs();
+    }
+
+    mLastMotionPressure = 0;
+
+#ifdef ACCESSIBILITY
+    mRootAccessible  = nullptr;
+#endif
+
+    mIsTransparent = false;
+    mTransparencyBitmap = nullptr;
+
+    mTransparencyBitmapWidth  = 0;
+    mTransparencyBitmapHeight = 0;
+
+#if GTK_CHECK_VERSION(3,4,0)
+    mLastScrollEventTime = GDK_CURRENT_TIME;
+#endif
+    mPendingConfigures = 0;
+}
+
+nsWindow::~nsWindow()
+{
+    LOG(("nsWindow::~nsWindow() [%p]\n", (void *)this));
+
+    delete[] mTransparencyBitmap;
+    mTransparencyBitmap = nullptr;
+
+    Destroy();
+}
+
+/* static */ void
+nsWindow::ReleaseGlobals()
+{
+  for (uint32_t i = 0; i < ArrayLength(gCursorCache); ++i) {
+    if (gCursorCache[i]) {
+#if (MOZ_WIDGET_GTK == 3)
+      g_object_unref(gCursorCache[i]);
+#else
+      gdk_cursor_unref(gCursorCache[i]);
+#endif
+      gCursorCache[i] = nullptr;
+    }
+  }
+}
+
+void
+nsWindow::CommonCreate(nsIWidget *aParent, bool aListenForResizes)
+{
+    mParent = aParent;
+    mListenForResizes = aListenForResizes;
+    mCreated = true;
+}
+
+void
+nsWindow::DispatchActivateEvent(void)
+{
+    NS_ASSERTION(mContainer || mIsDestroyed,
+                 "DispatchActivateEvent only intended for container windows");
+
+#ifdef ACCESSIBILITY
+    DispatchActivateEventAccessible();
+#endif //ACCESSIBILITY
+
+    if (mWidgetListener)
+      mWidgetListener->WindowActivated();
+}
+
+void
+nsWindow::DispatchDeactivateEvent(void)
+{
+    if (mWidgetListener)
+      mWidgetListener->WindowDeactivated();
+
+#ifdef ACCESSIBILITY
+    DispatchDeactivateEventAccessible();
+#endif //ACCESSIBILITY
+}
+
+void
+nsWindow::DispatchResized()
+{
+    mNeedsDispatchResized = false;
+    if (mWidgetListener) {
+        mWidgetListener->WindowResized(this, mBounds.width, mBounds.height);
+    }
+    if (mAttachedWidgetListener) {
+        mAttachedWidgetListener->WindowResized(this,
+                                               mBounds.width, mBounds.height);
+    }
+}
+
+void
+nsWindow::MaybeDispatchResized()
+{
+    if (mNeedsDispatchResized && !mIsDestroyed) {
+        DispatchResized();
+    }
+}
+
+nsIWidgetListener*
+nsWindow::GetListener()
+{
+    return mAttachedWidgetListener ? mAttachedWidgetListener : mWidgetListener;
+}
+
+nsresult
+nsWindow::DispatchEvent(WidgetGUIEvent* aEvent, nsEventStatus& aStatus)
+{
+#ifdef DEBUG
+    debug_DumpEvent(stdout, aEvent->mWidget, aEvent,
+                    "something", 0);
+#endif
+    aStatus = nsEventStatus_eIgnore;
+    nsIWidgetListener* listener = GetListener();
+    if (listener) {
+      aStatus = listener->HandleEvent(aEvent, mUseAttachedEvents);
+    }
+
+    return NS_OK;
+}
+
+void
+nsWindow::OnDestroy(void)
+{
+    if (mOnDestroyCalled)
+        return;
+
+    mOnDestroyCalled = true;
+
+    // Prevent deletion.
+    nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
+
+    // release references to children, device context, toolkit + app shell
+    nsBaseWidget::OnDestroy();
+
+    // Remove association between this object and its parent and siblings.
+    nsBaseWidget::Destroy();
+    mParent = nullptr;
+
+    NotifyWindowDestroyed();
+}
+
+bool
+nsWindow::AreBoundsSane(void)
+{
+    if (mBounds.width > 0 && mBounds.height > 0)
+        return true;
+
+    return false;
+}
+
+static GtkWidget*
+EnsureInvisibleContainer()
+{
+    if (!gInvisibleContainer) {
+        // GtkWidgets need to be anchored to a GtkWindow to be realized (to
+        // have a window).  Using GTK_WINDOW_POPUP rather than
+        // GTK_WINDOW_TOPLEVEL in the hope that POPUP results in less
+        // initialization and window manager interaction.
+        GtkWidget* window = gtk_window_new(GTK_WINDOW_POPUP);
+        gInvisibleContainer = moz_container_new();
+        gtk_container_add(GTK_CONTAINER(window), gInvisibleContainer);
+        gtk_widget_realize(gInvisibleContainer);
+
+    }
+    return gInvisibleContainer;
+}
+
+static void
+CheckDestroyInvisibleContainer()
+{
+    NS_PRECONDITION(gInvisibleContainer, "oh, no");
+
+    if (!gdk_window_peek_children(gtk_widget_get_window(gInvisibleContainer))) {
+        // No children, so not in use.
+        // Make sure to destroy the GtkWindow also.
+        gtk_widget_destroy(gtk_widget_get_parent(gInvisibleContainer));
+        gInvisibleContainer = nullptr;
+    }
+}
+
+// Change the containing GtkWidget on a sub-hierarchy of GdkWindows belonging
+// to aOldWidget and rooted at aWindow, and reparent any child GtkWidgets of
+// the GdkWindow hierarchy to aNewWidget.
+static void
+SetWidgetForHierarchy(GdkWindow *aWindow,
+                      GtkWidget *aOldWidget,
+                      GtkWidget *aNewWidget)
+{
+    gpointer data;
+    gdk_window_get_user_data(aWindow, &data);
+
+    if (data != aOldWidget) {
+        if (!GTK_IS_WIDGET(data))
+            return;
+
+        GtkWidget* widget = static_cast<GtkWidget*>(data);
+        if (gtk_widget_get_parent(widget) != aOldWidget)
+            return;
+
+        // This window belongs to a child widget, which will no longer be a
+        // child of aOldWidget.
+        gtk_widget_reparent(widget, aNewWidget);
+
+        return;
+    }
+
+    GList *children = gdk_window_get_children(aWindow);
+    for(GList *list = children; list; list = list->next) {
+        SetWidgetForHierarchy(GDK_WINDOW(list->data), aOldWidget, aNewWidget);
+    }
+    g_list_free(children);
+
+    gdk_window_set_user_data(aWindow, aNewWidget);
+}
+
+// Walk the list of child windows and call destroy on them.
+void
+nsWindow::DestroyChildWindows()
+{
+    if (!mGdkWindow)
+        return;
+
+    while (GList *children = gdk_window_peek_children(mGdkWindow)) {
+        GdkWindow *child = GDK_WINDOW(children->data);
+        nsWindow *kid = get_window_for_gdk_window(child);
+        if (kid) {
+            kid->Destroy();
+        } else {
+            // This child is not an nsWindow.
+            // Destroy the child GtkWidget.
+            gpointer data;
+            gdk_window_get_user_data(child, &data);
+            if (GTK_IS_WIDGET(data)) {
+                gtk_widget_destroy(static_cast<GtkWidget*>(data));
+            }
+        }
+    }
+}
+
+void
+nsWindow::Destroy()
+{
+    if (mIsDestroyed || !mCreated)
+        return;
+
+    LOG(("nsWindow::Destroy [%p]\n", (void *)this));
+    mIsDestroyed = true;
+    mCreated = false;
+
+    /** Need to clean our LayerManager up while still alive */
+    if (mLayerManager) {
+        mLayerManager->Destroy();
+    }
+    mLayerManager = nullptr;
+
+    // It is safe to call DestroyeCompositor several times (here and
+    // in the parent class) since it will take effect only once.
+    // The reason we call it here is because on gtk platforms we need
+    // to destroy the compositor before we destroy the gdk window (which
+    // destroys the the gl context attached to it).
+    DestroyCompositor();
+
+    ClearCachedResources();
+
+    g_signal_handlers_disconnect_by_func(gtk_settings_get_default(),
+                                         FuncToGpointer(theme_changed_cb),
+                                         this);
+
+    nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
+    if (rollupListener) {
+        nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
+        if (static_cast<nsIWidget *>(this) == rollupWidget) {
+            rollupListener->Rollup(0, false, nullptr, nullptr);
+        }
+    }
+
+    // dragService will be null after shutdown of the service manager.
+    nsDragService *dragService = nsDragService::GetInstance();
+    if (dragService && this == dragService->GetMostRecentDestWindow()) {
+        dragService->ScheduleLeaveEvent();
+    }
+
+    NativeShow(false);
+
+    if (mIMContext) {
+        mIMContext->OnDestroyWindow(this);
+    }
+
+    // make sure that we remove ourself as the focus window
+    if (gFocusWindow == this) {
+        LOGFOCUS(("automatically losing focus...\n"));
+        gFocusWindow = nullptr;
+    }
+
+#if (MOZ_WIDGET_GTK == 2) && defined(MOZ_X11)
+    // make sure that we remove ourself as the plugin focus window
+    if (gPluginFocusWindow == this) {
+        gPluginFocusWindow->LoseNonXEmbedPluginFocus();
+    }
+#endif /* MOZ_X11 && MOZ_WIDGET_GTK == 2 && defined(MOZ_X11) */
+
+    GtkWidget *owningWidget = GetMozContainerWidget();
+    if (mShell) {
+        gtk_widget_destroy(mShell);
+        mShell = nullptr;
+        mContainer = nullptr;
+        MOZ_ASSERT(!mGdkWindow,
+                   "mGdkWindow should be NULL when mContainer is destroyed");
+    }
+    else if (mContainer) {
+        gtk_widget_destroy(GTK_WIDGET(mContainer));
+        mContainer = nullptr;
+        MOZ_ASSERT(!mGdkWindow,
+                   "mGdkWindow should be NULL when mContainer is destroyed");
+    }
+    else if (mGdkWindow) {
+        // Destroy child windows to ensure that their mThebesSurfaces are
+        // released and to remove references from GdkWindows back to their
+        // container widget.  (OnContainerUnrealize() does this when the
+        // MozContainer widget is destroyed.)
+        DestroyChildWindows();
+
+        gdk_window_set_user_data(mGdkWindow, nullptr);
+        g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", nullptr);
+        gdk_window_destroy(mGdkWindow);
+        mGdkWindow = nullptr;
+    }
+
+    if (gInvisibleContainer && owningWidget == gInvisibleContainer) {
+        CheckDestroyInvisibleContainer();
+    }
+
+#ifdef ACCESSIBILITY
+     if (mRootAccessible) {
+         mRootAccessible = nullptr;
+     }
+#endif
+
+    // Save until last because OnDestroy() may cause us to be deleted.
+    OnDestroy();
+}
+
+nsIWidget *
+nsWindow::GetParent(void)
+{
+    return mParent;
+}
+
+float
+nsWindow::GetDPI()
+{
+    GdkScreen *screen = gdk_display_get_default_screen(gdk_display_get_default());
+    double heightInches = gdk_screen_get_height_mm(screen)/MM_PER_INCH_FLOAT;
+    if (heightInches < 0.25) {
+        // Something's broken, but we'd better not crash.
+        return 96.0f;
+    }
+    return float(gdk_screen_get_height(screen)/heightInches);
+}
+
+double
+nsWindow::GetDefaultScaleInternal()
+{
+    return GdkScaleFactor() * gfxPlatformGtk::GetDPIScale();
+}
+
+NS_IMETHODIMP
+nsWindow::SetParent(nsIWidget *aNewParent)
+{
+    if (mContainer || !mGdkWindow) {
+        NS_NOTREACHED("nsWindow::SetParent called illegally");
+        return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
+    if (mParent) {
+        mParent->RemoveChild(this);
+    }
+
+    mParent = aNewParent;
+
+    GtkWidget* oldContainer = GetMozContainerWidget();
+    if (!oldContainer) {
+        // The GdkWindows have been destroyed so there is nothing else to
+        // reparent.
+        MOZ_ASSERT(gdk_window_is_destroyed(mGdkWindow),
+                   "live GdkWindow with no widget");
+        return NS_OK;
+    }
+
+    if (aNewParent) {
+        aNewParent->AddChild(this);
+        ReparentNativeWidget(aNewParent);
+    } else {
+        // aNewParent is nullptr, but reparent to a hidden window to avoid
+        // destroying the GdkWindow and its descendants.
+        // An invisible container widget is needed to hold descendant
+        // GtkWidgets.
+        GtkWidget* newContainer = EnsureInvisibleContainer();
+        GdkWindow* newParentWindow = gtk_widget_get_window(newContainer);
+        ReparentNativeWidgetInternal(aNewParent, newContainer, newParentWindow,
+                                     oldContainer);
+    }
+    return NS_OK;
+}
+
+bool
+nsWindow::WidgetTypeSupportsAcceleration()
+{
+  return !IsSmallPopup();
+}
+
+void
+nsWindow::ReparentNativeWidget(nsIWidget* aNewParent)
+{
+    NS_PRECONDITION(aNewParent, "");
+    NS_ASSERTION(!mIsDestroyed, "");
+    NS_ASSERTION(!static_cast<nsWindow*>(aNewParent)->mIsDestroyed, "");
+
+    GtkWidget* oldContainer = GetMozContainerWidget();
+    if (!oldContainer) {
+        // The GdkWindows have been destroyed so there is nothing else to
+        // reparent.
+        MOZ_ASSERT(gdk_window_is_destroyed(mGdkWindow),
+                   "live GdkWindow with no widget");
+        return;
+    }
+    MOZ_ASSERT(!gdk_window_is_destroyed(mGdkWindow),
+               "destroyed GdkWindow with widget");
+
+    nsWindow* newParent = static_cast<nsWindow*>(aNewParent);
+    GdkWindow* newParentWindow = newParent->mGdkWindow;
+    GtkWidget* newContainer = newParent->GetMozContainerWidget();
+    GtkWindow* shell = GTK_WINDOW(mShell);
+
+    if (shell && gtk_window_get_transient_for(shell)) {
+      GtkWindow* topLevelParent =
+          GTK_WINDOW(gtk_widget_get_toplevel(newContainer));
+      gtk_window_set_transient_for(shell, topLevelParent);
+    }
+
+    ReparentNativeWidgetInternal(aNewParent, newContainer, newParentWindow,
+                                 oldContainer);
+}
+
+void
+nsWindow::ReparentNativeWidgetInternal(nsIWidget* aNewParent,
+                                       GtkWidget* aNewContainer,
+                                       GdkWindow* aNewParentWindow,
+                                       GtkWidget* aOldContainer)
+{
+    if (!aNewContainer) {
+        // The new parent GdkWindow has been destroyed.
+        MOZ_ASSERT(!aNewParentWindow ||
+                   gdk_window_is_destroyed(aNewParentWindow),
+                   "live GdkWindow with no widget");
+        Destroy();
+    } else {
+        if (aNewContainer != aOldContainer) {
+            MOZ_ASSERT(!gdk_window_is_destroyed(aNewParentWindow),
+                       "destroyed GdkWindow with widget");
+            SetWidgetForHierarchy(mGdkWindow, aOldContainer, aNewContainer);
+
+            if (aOldContainer == gInvisibleContainer) {
+                CheckDestroyInvisibleContainer();
+            }
+        }
+
+        if (!mIsTopLevel) {
+            gdk_window_reparent(mGdkWindow, aNewParentWindow,
+                                DevicePixelsToGdkCoordRoundDown(mBounds.x),
+                                DevicePixelsToGdkCoordRoundDown(mBounds.y));
+        }
+    }
+
+    nsWindow* newParent = static_cast<nsWindow*>(aNewParent);
+    bool parentHasMappedToplevel =
+        newParent && newParent->mHasMappedToplevel;
+    if (mHasMappedToplevel != parentHasMappedToplevel) {
+        SetHasMappedToplevel(parentHasMappedToplevel);
+    }
+}
+
+void
+nsWindow::SetModal(bool aModal)
+{
+    LOG(("nsWindow::SetModal [%p] %d\n", (void *)this, aModal));
+    if (mIsDestroyed)
+        return;
+    if (!mIsTopLevel || !mShell)
+        return;
+    gtk_window_set_modal(GTK_WINDOW(mShell), aModal ? TRUE : FALSE);
+}
+
+// nsIWidget method, which means IsShown.
+bool
+nsWindow::IsVisible() const
+{
+    return mIsShown;
+}
+
+void
+nsWindow::RegisterTouchWindow()
+{
+#if GTK_CHECK_VERSION(3,4,0)
+    mHandleTouchEvent = true;
+    mTouches.Clear();
+#endif
+}
+
+void
+nsWindow::ConstrainPosition(bool aAllowSlop, int32_t *aX, int32_t *aY)
+{
+    if (!mIsTopLevel || !mShell)
+      return;
+
+    double dpiScale = GetDefaultScale().scale;
+
+    // we need to use the window size in logical screen pixels
+    int32_t logWidth = std::max(NSToIntRound(mBounds.width / dpiScale), 1);
+    int32_t logHeight = std::max(NSToIntRound(mBounds.height / dpiScale), 1);
+
+    /* get our playing field. use the current screen, or failing that
+      for any reason, use device caps for the default screen. */
+    nsCOMPtr<nsIScreen> screen;
+    nsCOMPtr<nsIScreenManager> screenmgr = do_GetService("@mozilla.org/gfx/screenmanager;1");
+    if (screenmgr) {
+      screenmgr->ScreenForRect(*aX, *aY, logWidth, logHeight,
+                               getter_AddRefs(screen));
+    }
+
+    // We don't have any screen so leave the coordinates as is
+    if (!screen)
+      return;
+
+    nsIntRect screenRect;
+    if (mSizeMode != nsSizeMode_Fullscreen) {
+      // For normalized windows, use the desktop work area.
+      screen->GetAvailRectDisplayPix(&screenRect.x, &screenRect.y,
+                                     &screenRect.width, &screenRect.height);
+    } else {
+      // For full screen windows, use the desktop.
+      screen->GetRectDisplayPix(&screenRect.x, &screenRect.y,
+                                &screenRect.width, &screenRect.height);
+    }
+
+    if (aAllowSlop) {
+      if (*aX < screenRect.x - logWidth + kWindowPositionSlop)
+          *aX = screenRect.x - logWidth + kWindowPositionSlop;
+      else if (*aX >= screenRect.XMost() - kWindowPositionSlop)
+          *aX = screenRect.XMost() - kWindowPositionSlop;
+
+      if (*aY < screenRect.y - logHeight + kWindowPositionSlop)
+          *aY = screenRect.y - logHeight + kWindowPositionSlop;
+      else if (*aY >= screenRect.YMost() - kWindowPositionSlop)
+          *aY = screenRect.YMost() - kWindowPositionSlop;
+    } else {
+      if (*aX < screenRect.x)
+          *aX = screenRect.x;
+      else if (*aX >= screenRect.XMost() - logWidth)
+          *aX = screenRect.XMost() - logWidth;
+
+      if (*aY < screenRect.y)
+          *aY = screenRect.y;
+      else if (*aY >= screenRect.YMost() - logHeight)
+          *aY = screenRect.YMost() - logHeight;
+    }
+}
+
+void nsWindow::SetSizeConstraints(const SizeConstraints& aConstraints)
+{
+    mSizeConstraints.mMinSize = GetSafeWindowSize(aConstraints.mMinSize);
+    mSizeConstraints.mMaxSize = GetSafeWindowSize(aConstraints.mMaxSize);
+
+    if (mShell) {
+        GdkGeometry geometry;
+        geometry.min_width = DevicePixelsToGdkCoordRoundUp(
+                             mSizeConstraints.mMinSize.width);
+        geometry.min_height = DevicePixelsToGdkCoordRoundUp(
+                              mSizeConstraints.mMinSize.height);
+        geometry.max_width = DevicePixelsToGdkCoordRoundDown(
+                             mSizeConstraints.mMaxSize.width);
+        geometry.max_height = DevicePixelsToGdkCoordRoundDown(
+                              mSizeConstraints.mMaxSize.height);
+
+        uint32_t hints = 0;
+        if (aConstraints.mMinSize != LayoutDeviceIntSize(0, 0)) {
+            hints |= GDK_HINT_MIN_SIZE;
+        }
+        if (aConstraints.mMaxSize !=
+            LayoutDeviceIntSize(NS_MAXSIZE, NS_MAXSIZE)) {
+            hints |= GDK_HINT_MAX_SIZE;
+        }
+        gtk_window_set_geometry_hints(GTK_WINDOW(mShell), nullptr,
+                                      &geometry, GdkWindowHints(hints));
+    }
+}
+
+NS_IMETHODIMP
+nsWindow::Show(bool aState)
+{
+    if (aState == mIsShown)
+        return NS_OK;
+
+    // Clear our cached resources when the window is hidden.
+    if (mIsShown && !aState) {
+        ClearCachedResources();
+    }
+
+    mIsShown = aState;
+
+    LOG(("nsWindow::Show [%p] state %d\n", (void *)this, aState));
+
+    if (aState) {
+        // Now that this window is shown, mHasMappedToplevel needs to be
+        // tracked on viewable descendants.
+        SetHasMappedToplevel(mHasMappedToplevel);
+    }
+
+    // Ok, someone called show on a window that isn't sized to a sane
+    // value.  Mark this window as needing to have Show() called on it
+    // and return.
+    if ((aState && !AreBoundsSane()) || !mCreated) {
+        LOG(("\tbounds are insane or window hasn't been created yet\n"));
+        mNeedsShow = true;
+        return NS_OK;
+    }
+
+    // If someone is hiding this widget, clear any needing show flag.
+    if (!aState)
+        mNeedsShow = false;
+
+#ifdef ACCESSIBILITY
+    if (aState && a11y::ShouldA11yBeEnabled())
+        CreateRootAccessible();
+#endif
+
+    NativeShow(aState);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Resize(double aWidth, double aHeight, bool aRepaint)
+{
+    double scale = BoundsUseDesktopPixels() ? GetDesktopToDeviceScale().scale : 1.0;
+    int32_t width = NSToIntRound(scale * aWidth);
+    int32_t height = NSToIntRound(scale * aHeight);
+    ConstrainSize(&width, &height);
+
+    // For top-level windows, aWidth and aHeight should possibly be
+    // interpreted as frame bounds, but NativeResize treats these as window
+    // bounds (Bug 581866).
+
+    mBounds.SizeTo(width, height);
+
+    if (!mCreated)
+        return NS_OK;
+
+    NativeResize();
+
+    NotifyRollupGeometryChange();
+    ResizePluginSocketWidget();
+
+    // send a resize notification if this is a toplevel
+    if (mIsTopLevel || mListenForResizes) {
+        DispatchResized();
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::Resize(double aX, double aY, double aWidth, double aHeight,
+                 bool aRepaint)
+{
+    double scale = BoundsUseDesktopPixels() ? GetDesktopToDeviceScale().scale : 1.0;
+    int32_t width = NSToIntRound(scale * aWidth);
+    int32_t height = NSToIntRound(scale * aHeight);
+    ConstrainSize(&width, &height);
+
+    int32_t x = NSToIntRound(scale * aX);
+    int32_t y = NSToIntRound(scale * aY);
+    mBounds.x = x;
+    mBounds.y = y;
+    mBounds.SizeTo(width, height);
+
+    if (!mCreated)
+        return NS_OK;
+
+    NativeMoveResize();
+
+    NotifyRollupGeometryChange();
+    ResizePluginSocketWidget();
+
+    if (mIsTopLevel || mListenForResizes) {
+        DispatchResized();
+    }
+
+    return NS_OK;
+}
+
+void
+nsWindow::ResizePluginSocketWidget()
+{
+    // e10s specific, a eWindowType_plugin_ipc_chrome holds its own
+    // nsPluginNativeWindowGtk wrapper. We are responsible for resizing
+    // the embedded socket widget.
+    if (mWindowType == eWindowType_plugin_ipc_chrome) {
+        nsPluginNativeWindowGtk* wrapper = (nsPluginNativeWindowGtk*)
+          GetNativeData(NS_NATIVE_PLUGIN_OBJECT_PTR);
+        if (wrapper) {
+            wrapper->width = mBounds.width;
+            wrapper->height = mBounds.height;
+            wrapper->SetAllocation();
+        }
+    }
+}
+
+NS_IMETHODIMP
+nsWindow::Enable(bool aState)
+{
+    mEnabled = aState;
+
+    return NS_OK;
+}
+
+bool
+nsWindow::IsEnabled() const
+{
+    return mEnabled;
+}
+
+
+
+NS_IMETHODIMP
+nsWindow::Move(double aX, double aY)
+{
+    LOG(("nsWindow::Move [%p] %f %f\n", (void *)this,
+         aX, aY));
+
+    double scale = BoundsUseDesktopPixels() ? GetDesktopToDeviceScale().scale : 1.0;
+    int32_t x = NSToIntRound(aX * scale);
+    int32_t y = NSToIntRound(aY * scale);
+
+    if (mWindowType == eWindowType_toplevel ||
+        mWindowType == eWindowType_dialog) {
+        SetSizeMode(nsSizeMode_Normal);
+    }
+
+    // Since a popup window's x/y coordinates are in relation to to
+    // the parent, the parent might have moved so we always move a
+    // popup window.
+    if (x == mBounds.x && y == mBounds.y &&
+        mWindowType != eWindowType_popup)
+        return NS_OK;
+
+    // XXX Should we do some AreBoundsSane check here?
+
+    mBounds.x = x;
+    mBounds.y = y;
+
+    if (!mCreated)
+        return NS_OK;
+
+    NativeMove();
+
+    NotifyRollupGeometryChange();
+    return NS_OK;
+}
+
+
+void
+nsWindow::NativeMove()
+{
+    GdkPoint point = DevicePixelsToGdkPointRoundDown(mBounds.TopLeft());
+
+    if (mIsTopLevel) {
+        gtk_window_move(GTK_WINDOW(mShell), point.x, point.y);
+    }
+    else if (mGdkWindow) {
+        gdk_window_move(mGdkWindow, point.x, point.y);
+    }
+}
+
+void
+nsWindow::SetZIndex(int32_t aZIndex)
+{
+    nsIWidget* oldPrev = GetPrevSibling();
+
+    nsBaseWidget::SetZIndex(aZIndex);
+
+    if (GetPrevSibling() == oldPrev) {
+        return;
+    }
+
+    NS_ASSERTION(!mContainer, "Expected Mozilla child widget");
+
+    // We skip the nsWindows that don't have mGdkWindows.
+    // These are probably in the process of being destroyed.
+
+    if (!GetNextSibling()) {
+        // We're to be on top.
+        if (mGdkWindow)
+            gdk_window_raise(mGdkWindow);
+    } else {
+        // All the siblings before us need to be below our widget.
+        for (nsWindow* w = this; w;
+             w = static_cast<nsWindow*>(w->GetPrevSibling())) {
+            if (w->mGdkWindow)
+                gdk_window_lower(w->mGdkWindow);
+        }
+    }
+}
+
+void
+nsWindow::SetSizeMode(nsSizeMode aMode)
+{
+    LOG(("nsWindow::SetSizeMode [%p] %d\n", (void *)this, aMode));
+
+    // Save the requested state.
+    nsBaseWidget::SetSizeMode(aMode);
+
+    // return if there's no shell or our current state is the same as
+    // the mode we were just set to.
+    if (!mShell || mSizeState == mSizeMode) {
+        return;
+    }
+
+    switch (aMode) {
+    case nsSizeMode_Maximized:
+        gtk_window_maximize(GTK_WINDOW(mShell));
+        break;
+    case nsSizeMode_Minimized:
+        gtk_window_iconify(GTK_WINDOW(mShell));
+        break;
+    case nsSizeMode_Fullscreen:
+        MakeFullScreen(true);
+        break;
+
+    default:
+        // nsSizeMode_Normal, really.
+        if (mSizeState == nsSizeMode_Minimized)
+            gtk_window_deiconify(GTK_WINDOW(mShell));
+        else if (mSizeState == nsSizeMode_Maximized)
+            gtk_window_unmaximize(GTK_WINDOW(mShell));
+        break;
+    }
+
+    mSizeState = mSizeMode;
+}
+
+typedef void (* SetUserTimeFunc)(GdkWindow* aWindow, guint32 aTimestamp);
+
+// This will become obsolete when new GTK APIs are widely supported,
+// as described here: http://bugzilla.gnome.org/show_bug.cgi?id=347375
+static void
+SetUserTimeAndStartupIDForActivatedWindow(GtkWidget* aWindow)
+{
+    nsGTKToolkit* GTKToolkit = nsGTKToolkit::GetToolkit();
+    if (!GTKToolkit)
+        return;
+
+    nsAutoCString desktopStartupID;
+    GTKToolkit->GetDesktopStartupID(&desktopStartupID);
+    if (desktopStartupID.IsEmpty()) {
+        // We don't have the data we need. Fall back to an
+        // approximation ... using the timestamp of the remote command
+        // being received as a guess for the timestamp of the user event
+        // that triggered it.
+        uint32_t timestamp = GTKToolkit->GetFocusTimestamp();
+        if (timestamp) {
+            gdk_window_focus(gtk_widget_get_window(aWindow), timestamp);
+            GTKToolkit->SetFocusTimestamp(0);
+        }
+        return;
+    }
+
+#if defined(MOZ_ENABLE_STARTUP_NOTIFICATION)
+    // TODO - Implement for non-X11 Gtk backends (Bug 726479)
+    if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+        GdkWindow* gdkWindow = gtk_widget_get_window(aWindow);
+
+        GdkScreen* screen = gdk_window_get_screen(gdkWindow);
+        SnDisplay* snd =
+            sn_display_new(gdk_x11_display_get_xdisplay(gdk_window_get_display(gdkWindow)),
+                           nullptr, nullptr);
+        if (!snd)
+            return;
+        SnLauncheeContext* ctx =
+            sn_launchee_context_new(snd, gdk_screen_get_number(screen),
+                                    desktopStartupID.get());
+        if (!ctx) {
+            sn_display_unref(snd);
+            return;
+        }
+
+        if (sn_launchee_context_get_id_has_timestamp(ctx)) {
+            gdk_x11_window_set_user_time(gdkWindow,
+                sn_launchee_context_get_timestamp(ctx));
+        }
+
+        sn_launchee_context_setup_window(ctx, gdk_x11_window_get_xid(gdkWindow));
+        sn_launchee_context_complete(ctx);
+
+        sn_launchee_context_unref(ctx);
+        sn_display_unref(snd);
+    }
+#endif
+
+    // If we used the startup ID, that already contains the focus timestamp;
+    // we don't want to reuse the timestamp next time we raise the window
+    GTKToolkit->SetFocusTimestamp(0);
+    GTKToolkit->SetDesktopStartupID(EmptyCString());
+}
+
+/* static */ guint32
+nsWindow::GetLastUserInputTime()
+{
+    if (!GDK_IS_X11_DISPLAY(gdk_display_get_default()))
+        return sLastUserInputTime;
+
+    // gdk_x11_display_get_user_time tracks button and key presses,
+    // DESKTOP_STARTUP_ID used to start the app, drop events from external
+    // drags, WM_DELETE_WINDOW delete events, but not usually mouse motion nor
+    // button and key releases.  Therefore use the most recent of
+    // gdk_x11_display_get_user_time and the last time that we have seen.
+    guint32 timestamp =
+            gdk_x11_display_get_user_time(gdk_display_get_default());
+    if (sLastUserInputTime != GDK_CURRENT_TIME &&
+        TimestampIsNewerThan(sLastUserInputTime, timestamp)) {
+        return sLastUserInputTime;
+    }
+
+    return timestamp;
+}
+
+NS_IMETHODIMP
+nsWindow::SetFocus(bool aRaise)
+{
+    // Make sure that our owning widget has focus.  If it doesn't try to
+    // grab it.  Note that we don't set our focus flag in this case.
+
+    LOGFOCUS(("  SetFocus %d [%p]\n", aRaise, (void *)this));
+
+    GtkWidget *owningWidget = GetMozContainerWidget();
+    if (!owningWidget)
+        return NS_ERROR_FAILURE;
+
+    // Raise the window if someone passed in true and the prefs are
+    // set properly.
+    GtkWidget *toplevelWidget = gtk_widget_get_toplevel(owningWidget);
+
+    if (gRaiseWindows && aRaise && toplevelWidget &&
+        !gtk_widget_has_focus(owningWidget) &&
+        !gtk_widget_has_focus(toplevelWidget)) {
+        GtkWidget* top_window = GetToplevelWidget();
+        if (top_window && (gtk_widget_get_visible(top_window)))
+        {
+            gdk_window_show_unraised(gtk_widget_get_window(top_window));
+            // Unset the urgency hint if possible.
+            SetUrgencyHint(top_window, false);
+        }
+    }
+
+    RefPtr<nsWindow> owningWindow = get_window_for_gtk_widget(owningWidget);
+    if (!owningWindow)
+        return NS_ERROR_FAILURE;
+
+    if (aRaise) {
+        // aRaise == true means request toplevel activation.
+
+        // This is asynchronous.
+        // If and when the window manager accepts the request, then the focus
+        // widget will get a focus-in-event signal.
+        if (gRaiseWindows && owningWindow->mIsShown && owningWindow->mShell &&
+            !gtk_window_is_active(GTK_WINDOW(owningWindow->mShell))) {
+
+            uint32_t timestamp = GDK_CURRENT_TIME;
+
+            nsGTKToolkit* GTKToolkit = nsGTKToolkit::GetToolkit();
+            if (GTKToolkit)
+                timestamp = GTKToolkit->GetFocusTimestamp();
+
+            LOGFOCUS(("  requesting toplevel activation [%p]\n", (void *)this));
+            NS_ASSERTION(owningWindow->mWindowType != eWindowType_popup
+                         || mParent,
+                         "Presenting an override-redirect window");
+            gtk_window_present_with_time(GTK_WINDOW(owningWindow->mShell), timestamp);
+
+            if (GTKToolkit)
+                GTKToolkit->SetFocusTimestamp(0);
+        }
+
+        return NS_OK;
+    }
+
+    // aRaise == false means that keyboard events should be dispatched
+    // from this widget.
+
+    // Ensure owningWidget is the focused GtkWidget within its toplevel window.
+    //
+    // For eWindowType_popup, this GtkWidget may not actually be the one that
+    // receives the key events as it may be the parent window that is active.
+    if (!gtk_widget_is_focus(owningWidget)) {
+        // This is synchronous.  It takes focus from a plugin or from a widget
+        // in an embedder.  The focus manager already knows that this window
+        // is active so gBlockActivateEvent avoids another (unnecessary)
+        // activate notification.
+        gBlockActivateEvent = true;
+        gtk_widget_grab_focus(owningWidget);
+        gBlockActivateEvent = false;
+    }
+
+    // If this is the widget that already has focus, return.
+    if (gFocusWindow == this) {
+        LOGFOCUS(("  already have focus [%p]\n", (void *)this));
+        return NS_OK;
+    }
+
+    // Set this window to be the focused child window
+    gFocusWindow = this;
+
+    if (mIMContext) {
+        mIMContext->OnFocusWindow(this);
+    }
+
+    LOGFOCUS(("  widget now has focus in SetFocus() [%p]\n",
+              (void *)this));
+
+    return NS_OK;
+}
+
+LayoutDeviceIntRect
+nsWindow::GetScreenBounds()
+{
+    LayoutDeviceIntRect rect;
+    if (mIsTopLevel && mContainer) {
+        // use the point including window decorations
+        gint x, y;
+        gdk_window_get_root_origin(gtk_widget_get_window(GTK_WIDGET(mContainer)), &x, &y);
+        rect.MoveTo(GdkPointToDevicePixels({ x, y }));
+    } else {
+        rect.MoveTo(WidgetToScreenOffset());
+    }
+    // mBounds.Size() is the window bounds, not the window-manager frame
+    // bounds (bug 581863).  gdk_window_get_frame_extents would give the
+    // frame bounds, but mBounds.Size() is returned here for consistency
+    // with Resize.
+    rect.SizeTo(mBounds.Size());
+    LOG(("GetScreenBounds %d,%d | %dx%d\n",
+         rect.x, rect.y, rect.width, rect.height));
+    return rect;
+}
+
+LayoutDeviceIntSize
+nsWindow::GetClientSize()
+{
+  return LayoutDeviceIntSize(mBounds.width, mBounds.height);
+}
+
+LayoutDeviceIntRect
+nsWindow::GetClientBounds()
+{
+    // GetBounds returns a rect whose top left represents the top left of the
+    // outer bounds, but whose width/height represent the size of the inner
+    // bounds (which is messed up).
+    LayoutDeviceIntRect rect = GetBounds();
+    rect.MoveBy(GetClientOffset());
+    return rect;
+}
+
+void
+nsWindow::UpdateClientOffset()
+{
+    PROFILER_LABEL("nsWindow", "UpdateClientOffset", js::ProfileEntry::Category::GRAPHICS);
+
+    if (!mIsTopLevel || !mShell || !mGdkWindow || !mIsX11Display ||
+        gtk_window_get_window_type(GTK_WINDOW(mShell)) == GTK_WINDOW_POPUP) {
+        mClientOffset = nsIntPoint(0, 0);
+        return;
+    }
+
+    GdkAtom cardinal_atom = gdk_x11_xatom_to_atom(XA_CARDINAL);
+
+    GdkAtom type_returned;
+    int format_returned;
+    int length_returned;
+    long *frame_extents;
+
+    if (!gdk_property_get(mGdkWindow,
+                          gdk_atom_intern ("_NET_FRAME_EXTENTS", FALSE),
+                          cardinal_atom,
+                          0, // offset
+                          4*4, // length
+                          FALSE, // delete
+                          &type_returned,
+                          &format_returned,
+                          &length_returned,
+                          (guchar **) &frame_extents) ||
+        length_returned/sizeof(glong) != 4) {
+        mClientOffset = nsIntPoint(0, 0);
+        return;
+    }
+
+    // data returned is in the order left, right, top, bottom
+    int32_t left = int32_t(frame_extents[0]);
+    int32_t top = int32_t(frame_extents[2]);
+
+    g_free(frame_extents);
+
+    mClientOffset = nsIntPoint(left, top);
+}
+
+LayoutDeviceIntPoint
+nsWindow::GetClientOffset()
+{
+    return LayoutDeviceIntPoint::FromUnknownPoint(mClientOffset);
+}
+
+gboolean
+nsWindow::OnPropertyNotifyEvent(GtkWidget* aWidget, GdkEventProperty* aEvent)
+
+{
+  if (aEvent->atom == gdk_atom_intern("_NET_FRAME_EXTENTS", FALSE)) {
+    UpdateClientOffset();
+    return FALSE;
+  }
+
+  if (GetCurrentTimeGetter()->PropertyNotifyHandler(aWidget, aEvent)) {
+    return TRUE;
+  }
+
+  return FALSE;
+}
+
+NS_IMETHODIMP
+nsWindow::SetCursor(nsCursor aCursor)
+{
+    // if we're not the toplevel window pass up the cursor request to
+    // the toplevel window to handle it.
+    if (!mContainer && mGdkWindow) {
+        nsWindow *window = GetContainerWindow();
+        if (!window)
+            return NS_ERROR_FAILURE;
+
+        return window->SetCursor(aCursor);
+    }
+
+    // Only change cursor if it's actually been changed
+    if (aCursor != mCursor || mUpdateCursor) {
+        GdkCursor *newCursor = nullptr;
+        mUpdateCursor = false;
+
+        newCursor = get_gtk_cursor(aCursor);
+
+        if (nullptr != newCursor) {
+            mCursor = aCursor;
+
+            if (!mContainer)
+                return NS_OK;
+
+            gdk_window_set_cursor(gtk_widget_get_window(GTK_WIDGET(mContainer)), newCursor);
+        }
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::SetCursor(imgIContainer* aCursor,
+                    uint32_t aHotspotX, uint32_t aHotspotY)
+{
+    // if we're not the toplevel window pass up the cursor request to
+    // the toplevel window to handle it.
+    if (!mContainer && mGdkWindow) {
+        nsWindow *window = GetContainerWindow();
+        if (!window)
+            return NS_ERROR_FAILURE;
+
+        return window->SetCursor(aCursor, aHotspotX, aHotspotY);
+    }
+
+    mCursor = nsCursor(-1);
+
+    // Get the image's current frame
+    GdkPixbuf* pixbuf = nsImageToPixbuf::ImageToPixbuf(aCursor);
+    if (!pixbuf)
+        return NS_ERROR_NOT_AVAILABLE;
+
+    int width = gdk_pixbuf_get_width(pixbuf);
+    int height = gdk_pixbuf_get_height(pixbuf);
+    // Reject cursors greater than 128 pixels in some direction, to prevent
+    // spoofing.
+    // XXX ideally we should rescale. Also, we could modify the API to
+    // allow trusted content to set larger cursors.
+    if (width > 128 || height > 128) {
+        g_object_unref(pixbuf);
+        return NS_ERROR_NOT_AVAILABLE;
+    }
+
+    // Looks like all cursors need an alpha channel (tested on Gtk 2.4.4). This
+    // is of course not documented anywhere...
+    // So add one if there isn't one yet
+    if (!gdk_pixbuf_get_has_alpha(pixbuf)) {
+        GdkPixbuf* alphaBuf = gdk_pixbuf_add_alpha(pixbuf, FALSE, 0, 0, 0);
+        g_object_unref(pixbuf);
+        if (!alphaBuf) {
+            return NS_ERROR_OUT_OF_MEMORY;
+        }
+        pixbuf = alphaBuf;
+    }
+
+    GdkCursor* cursor = gdk_cursor_new_from_pixbuf(gdk_display_get_default(),
+                                                   pixbuf,
+                                                   aHotspotX, aHotspotY);
+    g_object_unref(pixbuf);
+    nsresult rv = NS_ERROR_OUT_OF_MEMORY;
+    if (cursor) {
+        if (mContainer) {
+            gdk_window_set_cursor(gtk_widget_get_window(GTK_WIDGET(mContainer)), cursor);
+            rv = NS_OK;
+        }
+#if (MOZ_WIDGET_GTK == 3)
+        g_object_unref(cursor);
+#else
+        gdk_cursor_unref(cursor);
+#endif
+    }
+
+    return rv;
+}
+
+NS_IMETHODIMP
+nsWindow::Invalidate(const LayoutDeviceIntRect& aRect)
+{
+    if (!mGdkWindow)
+        return NS_OK;
+
+    GdkRectangle rect = DevicePixelsToGdkRectRoundOut(aRect);
+    gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
+
+    LOGDRAW(("Invalidate (rect) [%p]: %d %d %d %d\n", (void *)this,
+             rect.x, rect.y, rect.width, rect.height));
+
+    return NS_OK;
+}
+
+void*
+nsWindow::GetNativeData(uint32_t aDataType)
+{
+    switch (aDataType) {
+    case NS_NATIVE_WINDOW:
+    case NS_NATIVE_WIDGET: {
+        if (!mGdkWindow)
+            return nullptr;
+
+        return mGdkWindow;
+    }
+
+    case NS_NATIVE_PLUGIN_PORT:
+        return SetupPluginPort();
+
+    case NS_NATIVE_PLUGIN_ID:
+        if (!mPluginNativeWindow) {
+          NS_WARNING("no native plugin instance!");
+          return nullptr;
+        }
+        // Return the socket widget XID
+        return (void*)mPluginNativeWindow->window;
+
+    case NS_NATIVE_DISPLAY: {
+        GdkDisplay* gdkDisplay = gdk_display_get_default();
+#if defined(MOZ_X11)
+        if (GDK_IS_X11_DISPLAY(gdkDisplay)) {
+          return GDK_DISPLAY_XDISPLAY(gdkDisplay);
+        }
+#endif
+#if defined(GDK_WINDOWING_WAYLAND)
+        if (GDK_IS_WAYLAND_DISPLAY(gdkDisplay)) {
+          return gdk_wayland_display_get_wl_display(gdkDisplay);
+        }
+#endif
+        return nullptr;
+    }
+    case NS_NATIVE_SHELLWIDGET:
+        return GetToplevelWidget();
+
+    case NS_NATIVE_SHAREABLE_WINDOW:
+        return (void *) GDK_WINDOW_XID(gdk_window_get_toplevel(mGdkWindow));
+    case NS_NATIVE_PLUGIN_OBJECT_PTR:
+        return (void *) mPluginNativeWindow;
+    case NS_RAW_NATIVE_IME_CONTEXT: {
+        void* pseudoIMEContext = GetPseudoIMEContext();
+        if (pseudoIMEContext) {
+            return pseudoIMEContext;
+        }
+        // If IME context isn't available on this widget, we should set |this|
+        // instead of nullptr.
+        if (!mIMContext) {
+            return this;
+        }
+        return mIMContext.get();
+    }
+    case NS_NATIVE_OPENGL_CONTEXT:
+      return nullptr;
+#if defined(MOZ_X11) || defined(GDK_WINDOWING_WAYLAND)
+    case NS_NATIVE_COMPOSITOR_DISPLAY:
+        if (mIsX11Display)
+          return gfxPlatformGtk::GetPlatform()->GetXCompositorDisplay();
+        else
+          return gfxPlatformGtk::GetPlatform()->GetWaylandCompositorDisplay();
+    case NS_NATIVE_COMPOSITOR_DISPLAY_X11:
+        return (void *)mIsX11Display;
+#endif
+    default:
+        NS_WARNING("nsWindow::GetNativeData called with bad value");
+        return nullptr;
+    }
+}
+
+void
+nsWindow::SetNativeData(uint32_t aDataType, uintptr_t aVal)
+{
+    if (aDataType != NS_NATIVE_PLUGIN_OBJECT_PTR) {
+        NS_WARNING("nsWindow::SetNativeData called with bad value");
+        return;
+    }
+    mPluginNativeWindow = (nsPluginNativeWindowGtk*)aVal;
+}
+
+NS_IMETHODIMP
+nsWindow::SetTitle(const nsAString& aTitle)
+{
+    if (!mShell)
+        return NS_OK;
+
+    // convert the string into utf8 and set the title.
+#define UTF8_FOLLOWBYTE(ch) (((ch) & 0xC0) == 0x80)
+    NS_ConvertUTF16toUTF8 titleUTF8(aTitle);
+    if (titleUTF8.Length() > NS_WINDOW_TITLE_MAX_LENGTH) {
+        // Truncate overlong titles (bug 167315). Make sure we chop after a
+        // complete sequence by making sure the next char isn't a follow-byte.
+        uint32_t len = NS_WINDOW_TITLE_MAX_LENGTH;
+        while(UTF8_FOLLOWBYTE(titleUTF8[len]))
+            --len;
+        titleUTF8.Truncate(len);
+    }
+    gtk_window_set_title(GTK_WINDOW(mShell), (const char *)titleUTF8.get());
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::SetIcon(const nsAString& aIconSpec)
+{
+    if (!mShell)
+        return NS_OK;
+
+    nsAutoCString iconName;
+
+    if (aIconSpec.EqualsLiteral("default")) {
+        nsXPIDLString brandName;
+        GetBrandName(brandName);
+        AppendUTF16toUTF8(brandName, iconName);
+        ToLowerCase(iconName);
+    } else {
+        AppendUTF16toUTF8(aIconSpec, iconName);
+    }
+
+    nsCOMPtr<nsIFile> iconFile;
+    nsAutoCString path;
+
+    gint *iconSizes =
+        gtk_icon_theme_get_icon_sizes(gtk_icon_theme_get_default(),
+                                      iconName.get());
+    bool foundIcon = (iconSizes[0] != 0);
+    g_free(iconSizes);
+
+    if (!foundIcon) {
+        // Look for icons with the following suffixes appended to the base name
+        // The last two entries (for the old XPM format) will be ignored unless
+        // no icons are found using other suffixes. XPM icons are deprecated.
+
+        const char extensions[6][7] = { ".png", "16.png", "32.png", "48.png",
+                                    ".xpm", "16.xpm" };
+
+        for (uint32_t i = 0; i < ArrayLength(extensions); i++) {
+            // Don't bother looking for XPM versions if we found a PNG.
+            if (i == ArrayLength(extensions) - 2 && foundIcon)
+                break;
+
+            nsAutoString extension;
+            extension.AppendASCII(extensions[i]);
+
+            ResolveIconName(aIconSpec, extension, getter_AddRefs(iconFile));
+            if (iconFile) {
+                iconFile->GetNativePath(path);
+                GdkPixbuf *icon = gdk_pixbuf_new_from_file(path.get(), nullptr);
+                if (icon) {
+                    gtk_icon_theme_add_builtin_icon(iconName.get(),
+                                                    gdk_pixbuf_get_height(icon),
+                                                    icon);
+                    g_object_unref(icon);
+                    foundIcon = true;
+                }
+            }
+        }
+    }
+
+    // leave the default icon intact if no matching icons were found
+    if (foundIcon) {
+        gtk_window_set_icon_name(GTK_WINDOW(mShell), iconName.get());
+    }
+
+    return NS_OK;
+}
+
+
+LayoutDeviceIntPoint
+nsWindow::WidgetToScreenOffset()
+{
+    gint x = 0, y = 0;
+
+    if (mGdkWindow) {
+        gdk_window_get_origin(mGdkWindow, &x, &y);
+    }
+
+    return GdkPointToDevicePixels({ x, y });
+}
+
+void
+nsWindow::CaptureMouse(bool aCapture)
+{
+    LOG(("CaptureMouse %p\n", (void *)this));
+
+    if (!mGdkWindow)
+        return;
+
+    if (!mContainer)
+        return;
+
+    if (aCapture) {
+        gtk_grab_add(GTK_WIDGET(mContainer));
+        GrabPointer(GetLastUserInputTime());
+    }
+    else {
+        ReleaseGrabs();
+        gtk_grab_remove(GTK_WIDGET(mContainer));
+    }
+}
+
+void
+nsWindow::CaptureRollupEvents(nsIRollupListener *aListener,
+                              bool               aDoCapture)
+{
+    if (!mGdkWindow)
+        return;
+
+    if (!mContainer)
+        return;
+
+    LOG(("CaptureRollupEvents %p %i\n", this, int(aDoCapture)));
+
+    if (aDoCapture) {
+        gRollupListener = aListener;
+        // Don't add a grab if a drag is in progress, or if the widget is a drag
+        // feedback popup. (panels with type="drag").
+        if (!mIsDragPopup && !nsWindow::DragInProgress()) {
+            gtk_grab_add(GTK_WIDGET(mContainer));
+            GrabPointer(GetLastUserInputTime());
+        }
+    }
+    else {
+        if (!nsWindow::DragInProgress()) {
+            ReleaseGrabs();
+        }
+        // There may not have been a drag in process when aDoCapture was set,
+        // so make sure to remove any added grab.  This is a no-op if the grab
+        // was not added to this widget.
+        gtk_grab_remove(GTK_WIDGET(mContainer));
+        gRollupListener = nullptr;
+    }
+}
+
+NS_IMETHODIMP
+nsWindow::GetAttention(int32_t aCycleCount)
+{
+    LOG(("nsWindow::GetAttention [%p]\n", (void *)this));
+
+    GtkWidget* top_window = GetToplevelWidget();
+    GtkWidget* top_focused_window =
+        gFocusWindow ? gFocusWindow->GetToplevelWidget() : nullptr;
+
+    // Don't get attention if the window is focused anyway.
+    if (top_window && (gtk_widget_get_visible(top_window)) &&
+        top_window != top_focused_window) {
+        SetUrgencyHint(top_window, true);
+    }
+
+    return NS_OK;
+}
+
+bool
+nsWindow::HasPendingInputEvent()
+{
+    // This sucks, but gtk/gdk has no way to answer the question we want while
+    // excluding paint events, and there's no X API that will let us peek
+    // without blocking or removing.  To prevent event reordering, peek
+    // anything except expose events.  Reordering expose and others should be
+    // ok, hopefully.
+    bool haveEvent = false;
+#ifdef MOZ_X11
+    XEvent ev;
+    if (mIsX11Display) {
+        Display *display = GDK_DISPLAY_XDISPLAY(gdk_display_get_default());
+        haveEvent =
+            XCheckMaskEvent(display,
+                            KeyPressMask | KeyReleaseMask | ButtonPressMask |
+                            ButtonReleaseMask | EnterWindowMask | LeaveWindowMask |
+                            PointerMotionMask | PointerMotionHintMask |
+                            Button1MotionMask | Button2MotionMask |
+                            Button3MotionMask | Button4MotionMask |
+                            Button5MotionMask | ButtonMotionMask | KeymapStateMask |
+                            VisibilityChangeMask | StructureNotifyMask |
+                            ResizeRedirectMask | SubstructureNotifyMask |
+                            SubstructureRedirectMask | FocusChangeMask |
+                            PropertyChangeMask | ColormapChangeMask |
+                            OwnerGrabButtonMask, &ev);
+        if (haveEvent) {
+            XPutBackEvent(display, &ev);
+        }
+    }
+#endif
+    return haveEvent;
+}
+
+#if 0
+#ifdef DEBUG
+// Paint flashing code (disabled for cairo - see below)
+
+#define CAPS_LOCK_IS_ON \
+(KeymapWrapper::AreModifiersCurrentlyActive(KeymapWrapper::CAPS_LOCK))
+
+#define WANT_PAINT_FLASHING \
+(debug_WantPaintFlashing() && CAPS_LOCK_IS_ON)
+
+#ifdef MOZ_X11
+static void
+gdk_window_flash(GdkWindow *    aGdkWindow,
+                 unsigned int   aTimes,
+                 unsigned int   aInterval,  // Milliseconds
+                 GdkRegion *    aRegion)
+{
+  gint         x;
+  gint         y;
+  gint         width;
+  gint         height;
+  guint        i;
+  GdkGC *      gc = 0;
+  GdkColor     white;
+
+#if (MOZ_WIDGET_GTK == 2)
+  gdk_window_get_geometry(aGdkWindow,nullptr,nullptr,&width,&height,nullptr);
+#else
+  gdk_window_get_geometry(aGdkWindow,nullptr,nullptr,&width,&height);
+#endif
+
+  gdk_window_get_origin (aGdkWindow,
+                         &x,
+                         &y);
+
+  gc = gdk_gc_new(gdk_get_default_root_window());
+
+  white.pixel = WhitePixel(gdk_display,DefaultScreen(gdk_display));
+
+  gdk_gc_set_foreground(gc,&white);
+  gdk_gc_set_function(gc,GDK_XOR);
+  gdk_gc_set_subwindow(gc,GDK_INCLUDE_INFERIORS);
+
+  gdk_region_offset(aRegion, x, y);
+  gdk_gc_set_clip_region(gc, aRegion);
+
+  /*
+   * Need to do this twice so that the XOR effect can replace
+   * the original window contents.
+   */
+  for (i = 0; i < aTimes * 2; i++)
+  {
+    gdk_draw_rectangle(gdk_get_default_root_window(),
+                       gc,
+                       TRUE,
+                       x,
+                       y,
+                       width,
+                       height);
+
+    gdk_flush();
+
+    PR_Sleep(PR_MillisecondsToInterval(aInterval));
+  }
+
+  gdk_gc_destroy(gc);
+
+  gdk_region_offset(aRegion, -x, -y);
+}
+#endif /* MOZ_X11 */
+#endif // DEBUG
+#endif
+
+#if (MOZ_WIDGET_GTK == 2)
+static bool
+ExtractExposeRegion(LayoutDeviceIntRegion& aRegion, GdkEventExpose* aEvent)
+{
+  GdkRectangle* rects;
+  gint nrects;
+  gdk_region_get_rectangles(aEvent->region, &rects, &nrects);
+
+  if (nrects > MAX_RECTS_IN_REGION) {
+      // Just use the bounding box
+      rects[0] = aEvent->area;
+      nrects = 1;
+  }
+
+  for (GdkRectangle* r = rects; r < rects + nrects; r++) {
+      aRegion.Or(aRegion, LayoutDeviceIntRect(r->x, r->y, r->width, r->height));
+      LOGDRAW(("\t%d %d %d %d\n", r->x, r->y, r->width, r->height));
+  }
+
+  g_free(rects);
+  return true;
+}
+
+#else
+# ifdef cairo_copy_clip_rectangle_list
+#  error "Looks like we're including Mozilla's cairo instead of system cairo"
+# endif
+static bool
+ExtractExposeRegion(LayoutDeviceIntRegion& aRegion, cairo_t* cr)
+{
+  cairo_rectangle_list_t* rects = cairo_copy_clip_rectangle_list(cr);
+  if (rects->status != CAIRO_STATUS_SUCCESS) {
+      NS_WARNING("Failed to obtain cairo rectangle list.");
+      return false;
+  }
+
+  for (int i = 0; i < rects->num_rectangles; i++)  {
+      const cairo_rectangle_t& r = rects->rectangles[i];
+      aRegion.Or(aRegion, LayoutDeviceIntRect::Truncate(r.x, r.y, r.width, r.height));
+      LOGDRAW(("\t%d %d %d %d\n", r.x, r.y, r.width, r.height));
+  }
+
+  cairo_rectangle_list_destroy(rects);
+  return true;
+}
+#endif
+
+#if (MOZ_WIDGET_GTK == 2)
+gboolean
+nsWindow::OnExposeEvent(GdkEventExpose *aEvent)
+#else
+gboolean
+nsWindow::OnExposeEvent(cairo_t *cr)
+#endif
+{
+    fprintf(stderr, "*********** Expose start nsWindow %p\n", this);
+  
+    // Send any pending resize events so that layout can update.
+    // May run event loop.
+    MaybeDispatchResized();
+
+    if (mIsDestroyed) {
+        return FALSE;
+    }
+
+    // Windows that are not visible will be painted after they become visible.
+    if (!mGdkWindow || mIsFullyObscured || !mHasMappedToplevel)
+        return FALSE;
+
+    nsIWidgetListener *listener = GetListener();
+    if (!listener)
+        return FALSE;
+
+#ifdef GDK_WINDOWING_WAYLAND
+    // We don't have any Wayland surface to paint to
+    if (mContainer && !mIsX11Display && !moz_container_map_wl_surface(mContainer))
+        return FALSE;
+#endif
+
+    LayoutDeviceIntRegion exposeRegion;
+#if (MOZ_WIDGET_GTK == 2)
+    if (!ExtractExposeRegion(exposeRegion, aEvent)) {
+#else
+    if (!ExtractExposeRegion(exposeRegion, cr)) {
+#endif
+        return FALSE;
+    }
+
+    gint scale = GdkScaleFactor();
+    LayoutDeviceIntRegion region = exposeRegion;
+    region.ScaleRoundOut(scale, scale);
+
+    ClientLayerManager *clientLayers = GetLayerManager()->AsClientLayerManager();
+
+    if (clientLayers && mCompositorSession) {
+        // We need to paint to the screen even if nothing changed, since if we
+        // don't have a compositing window manager, our pixels could be stale.
+        clientLayers->SetNeedsComposite(true);
+        clientLayers->SendInvalidRegion(region.ToUnknownRegion());
+    }
+
+    RefPtr<nsWindow> strongThis(this);
+
+    // Dispatch WillPaintWindow notification to allow scripts etc. to run
+    // before we paint
+    {
+        listener->WillPaintWindow(this);
+
+        // If the window has been destroyed during the will paint notification,
+        // there is nothing left to do.
+        if (!mGdkWindow)
+            return TRUE;
+
+        // Re-get the listener since the will paint notification might have
+        // killed it.
+        listener = GetListener();
+        if (!listener)
+            return FALSE;
+    }
+
+    if (clientLayers && clientLayers->NeedsComposite()) {
+      clientLayers->Composite();
+      clientLayers->SetNeedsComposite(false);
+    }
+
+    LOGDRAW(("sending expose event [%p] %p 0x%lx (rects follow):\n",
+             (void *)this, (void *)mGdkWindow,
+             gdk_x11_window_get_xid(mGdkWindow)));
+
+    // Our bounds may have changed after calling WillPaintWindow.  Clip
+    // to the new bounds here.  The region is relative to this
+    // window.
+    region.And(region, LayoutDeviceIntRect(0, 0, mBounds.width, mBounds.height));
+
+    bool shaped = false;
+    if (eTransparencyTransparent == GetTransparencyMode()) {
+        GdkScreen *screen = gdk_window_get_screen(mGdkWindow);
+        if (gdk_screen_is_composited(screen) &&
+            gdk_window_get_visual(mGdkWindow) ==
+            gdk_screen_get_rgba_visual(screen)) {
+            // Remove possible shape mask from when window manger was not
+            // previously compositing.
+            static_cast<nsWindow*>(GetTopLevelWidget())->
+                ClearTransparencyBitmap();
+        } else {
+            shaped = true;
+        }
+    }
+
+    if (!shaped) {
+        GList *children =
+            gdk_window_peek_children(mGdkWindow);
+        while (children) {
+            GdkWindow *gdkWin = GDK_WINDOW(children->data);
+            nsWindow *kid = get_window_for_gdk_window(gdkWin);
+            if (kid && gdk_window_is_visible(gdkWin)) {
+                AutoTArray<LayoutDeviceIntRect,1> clipRects;
+                kid->GetWindowClipRegion(&clipRects);
+                LayoutDeviceIntRect bounds = kid->GetBounds();
+                for (uint32_t i = 0; i < clipRects.Length(); ++i) {
+                    LayoutDeviceIntRect r = clipRects[i] + bounds.TopLeft();
+                    region.Sub(region, r);
+                }
+            }
+            children = children->next;
+        }
+    }
+
+    if (region.IsEmpty()) {
+        return TRUE;
+    }
+
+    // If this widget uses OMTC...
+    if (GetLayerManager()->GetBackendType() == LayersBackend::LAYERS_CLIENT) {
+        listener->PaintWindow(this, region);
+
+        // Re-get the listener since the will paint notification might have
+        // killed it.
+        listener = GetListener();
+        if (!listener)
+            return TRUE;
+
+        listener->DidPaintWindow();
+        return TRUE;
+    }
+
+    BufferMode layerBuffering = BufferMode::BUFFERED;
+    RefPtr<DrawTarget> dt = StartRemoteDrawingInRegion(region, &layerBuffering);
+    if (!dt || !dt->IsValid()) {
+        return FALSE;
+    }
+    RefPtr<gfxContext> ctx;
+    IntRect boundsRect = region.GetBounds().ToUnknownRect();
+    IntPoint offset(0, 0);
+    if (dt->GetSize() == boundsRect.Size()) {
+      offset = boundsRect.TopLeft();
+      dt->SetTransform(Matrix::Translation(-offset));
+    }
+
+#ifdef MOZ_X11
+    if (shaped) {
+        // Collapse update area to the bounding box. This is so we only have to
+        // call UpdateTranslucentWindowAlpha once. After we have dropped
+        // support for non-Thebes graphics, UpdateTranslucentWindowAlpha will be
+        // our private interface so we can rework things to avoid this.
+        dt->PushClipRect(Rect(boundsRect));
+
+        // The double buffering is done here to extract the shape mask.
+        // (The shape mask won't be necessary when a visual with an alpha
+        // channel is used on compositing window managers.)
+        layerBuffering = BufferMode::BUFFER_NONE;
+        RefPtr<DrawTarget> destDT = dt->CreateSimilarDrawTarget(boundsRect.Size(), SurfaceFormat::B8G8R8A8);
+        if (!destDT || !destDT->IsValid()) {
+            return FALSE;
+        }
+        destDT->SetTransform(Matrix::Translation(-boundsRect.TopLeft()));
+        ctx = gfxContext::CreatePreservingTransformOrNull(destDT);
+    } else {
+        gfxUtils::ClipToRegion(dt, region.ToUnknownRegion());
+        ctx = gfxContext::CreatePreservingTransformOrNull(dt);
+    }
+    MOZ_ASSERT(ctx); // checked both dt and destDT valid draw target above
+
+#if 0
+    // NOTE: Paint flashing region would be wrong for cairo, since
+    // cairo inflates the update region, etc.  So don't paint flash
+    // for cairo.
+#ifdef DEBUG
+    // XXX aEvent->region may refer to a newly-invalid area.  FIXME
+    if (0 && WANT_PAINT_FLASHING && gtk_widget_get_window(aEvent))
+        gdk_window_flash(mGdkWindow, 1, 100, aEvent->region);
+#endif
+#endif
+
+#endif // MOZ_X11
+
+    bool painted = false;
+    {
+      if (GetLayerManager()->GetBackendType() == LayersBackend::LAYERS_BASIC) {
+        GdkScreen *screen = gdk_window_get_screen(mGdkWindow);
+        if (GetTransparencyMode() == eTransparencyTransparent &&
+            layerBuffering == BufferMode::BUFFER_NONE &&
+            gdk_screen_is_composited(screen) &&
+            gdk_window_get_visual(mGdkWindow) ==
+            gdk_screen_get_rgba_visual(screen)) {
+          // If our draw target is unbuffered and we use an alpha channel,
+          // clear the image beforehand to ensure we don't get artifacts from a
+          // reused SHM image. See bug 1258086.
+          dt->ClearRect(Rect(boundsRect));
+        }
+        AutoLayerManagerSetup setupLayerManager(this, ctx, layerBuffering);
+        painted = listener->PaintWindow(this, region);
+
+        // Re-get the listener since the will paint notification might have
+        // killed it.
+        listener = GetListener();
+        if (!listener)
+            return TRUE;
+
+      }
+    }
+
+#ifdef MOZ_X11
+    // PaintWindow can Destroy us (bug 378273), avoid doing any paint
+    // operations below if that happened - it will lead to XError and exit().
+    if (shaped) {
+        if (MOZ_LIKELY(!mIsDestroyed)) {
+            if (painted) {
+                RefPtr<SourceSurface> surf = ctx->GetDrawTarget()->Snapshot();
+
+                UpdateAlpha(surf, boundsRect);
+
+                dt->DrawSurface(surf, Rect(boundsRect), Rect(0, 0, boundsRect.width, boundsRect.height),
+                                DrawSurfaceOptions(SamplingFilter::POINT),
+                                DrawOptions(1.0f, CompositionOp::OP_SOURCE));
+            }
+        }
+    }
+
+    ctx = nullptr;
+    dt->PopClip();
+
+#endif // MOZ_X11
+
+    EndRemoteDrawingInRegion(dt, region);
+
+    listener->DidPaintWindow();
+
+    // Synchronously flush any new dirty areas
+#if (MOZ_WIDGET_GTK == 2)
+    GdkRegion* dirtyArea = gdk_window_get_update_area(mGdkWindow);
+#else
+    cairo_region_t* dirtyArea = gdk_window_get_update_area(mGdkWindow);
+#endif
+
+    if (dirtyArea) {
+        gdk_window_invalidate_region(mGdkWindow, dirtyArea, false);
+#if (MOZ_WIDGET_GTK == 2)
+        gdk_region_destroy(dirtyArea);
+#else
+        cairo_region_destroy(dirtyArea);
+#endif
+        gdk_window_process_updates(mGdkWindow, false);
+    }
+
+    fprintf(stderr, "*************** Expose end nsWindow %p\n", this);
+
+    // check the return value!
+    return TRUE;
+}
+
+void
+nsWindow::UpdateAlpha(SourceSurface* aSourceSurface, nsIntRect aBoundsRect)
+{
+    // We need to create our own buffer to force the stride to match the
+    // expected stride.
+    int32_t stride = GetAlignedStride<4>(aBoundsRect.width,
+                                         BytesPerPixel(SurfaceFormat::A8));
+    if (stride == 0) {
+        return;
+    }
+    int32_t bufferSize = stride * aBoundsRect.height;
+    auto imageBuffer = MakeUniqueFallible<uint8_t[]>(bufferSize);
+    {
+        RefPtr<DrawTarget> drawTarget = gfxPlatform::CreateDrawTargetForData(
+                                              imageBuffer.get(),
+                                              aBoundsRect.Size(),
+                                              stride, SurfaceFormat::A8);
+
+        if (drawTarget) {
+            drawTarget->DrawSurface(aSourceSurface, Rect(0, 0, aBoundsRect.width, aBoundsRect.height),
+                                    Rect(0, 0, aSourceSurface->GetSize().width, aSourceSurface->GetSize().height),
+                                    DrawSurfaceOptions(SamplingFilter::POINT),
+                                    DrawOptions(1.0f, CompositionOp::OP_SOURCE));
+        }
+    }
+    UpdateTranslucentWindowAlphaInternal(aBoundsRect, imageBuffer.get(), stride);
+}
+
+gboolean
+nsWindow::OnConfigureEvent(GtkWidget *aWidget, GdkEventConfigure *aEvent)
+{
+    // These events are only received on toplevel windows.
+    //
+    // GDK ensures that the coordinates are the client window top-left wrt the
+    // root window.
+    //
+    //   GDK calculates the cordinates for real ConfigureNotify events on
+    //   managed windows (that would normally be relative to the parent
+    //   window).
+    //
+    //   Synthetic ConfigureNotify events are from the window manager and
+    //   already relative to the root window.  GDK creates all X windows with
+    //   border_width = 0, so synthetic events also indicate the top-left of
+    //   the client window.
+    //
+    //   Override-redirect windows are children of the root window so parent
+    //   coordinates are root coordinates.
+
+    LOG(("configure event [%p] %d %d %d %d\n", (void *)this,
+         aEvent->x, aEvent->y, aEvent->width, aEvent->height));
+
+    if (mPendingConfigures > 0) {
+        mPendingConfigures--;
+    }
+
+    LayoutDeviceIntRect screenBounds = GetScreenBounds();
+
+    if (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog) {
+        // This check avoids unwanted rollup on spurious configure events from
+        // Cygwin/X (bug 672103).
+        if (mBounds.x != screenBounds.x ||
+            mBounds.y != screenBounds.y) {
+            CheckForRollup(0, 0, false, true);
+        }
+    }
+
+    // This event indicates that the window position may have changed.
+    // mBounds.Size() is updated in OnSizeAllocate().
+
+    NS_ASSERTION(GTK_IS_WINDOW(aWidget),
+                 "Configure event on widget that is not a GtkWindow");
+    if (gtk_window_get_window_type(GTK_WINDOW(aWidget)) == GTK_WINDOW_POPUP) {
+        // Override-redirect window
+        //
+        // These windows should not be moved by the window manager, and so any
+        // change in position is a result of our direction.  mBounds has
+        // already been set in Move() or Resize(), and that is more
+        // up-to-date than the position in the ConfigureNotify event if the
+        // event is from an earlier window move.
+        //
+        // Skipping the WindowMoved call saves context menus from an infinite
+        // loop when nsXULPopupManager::PopupMoved moves the window to the new
+        // position and nsMenuPopupFrame::SetPopupPosition adds
+        // offsetForContextMenu on each iteration.
+        return FALSE;
+    }
+
+    mBounds.MoveTo(screenBounds.TopLeft());
+
+    // XXX mozilla will invalidate the entire window after this move
+    // complete.  wtf?
+    NotifyWindowMoved(mBounds.x, mBounds.y);
+
+    return FALSE;
+}
+
+void
+nsWindow::OnContainerUnrealize()
+{
+    // The GdkWindows are about to be destroyed (but not deleted), so remove
+    // their references back to their container widget while the GdkWindow
+    // hierarchy is still available.
+
+    if (mGdkWindow) {
+        DestroyChildWindows();
+
+        g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", nullptr);
+        mGdkWindow = nullptr;
+    }
+}
+
+void
+nsWindow::OnSizeAllocate(GtkAllocation *aAllocation)
+{
+    LOG(("size_allocate [%p] %d %d %d %d\n",
+         (void *)this, aAllocation->x, aAllocation->y,
+         aAllocation->width, aAllocation->height));
+
+    LayoutDeviceIntSize size = GdkRectToDevicePixels(*aAllocation).Size();
+
+    if (mBounds.Size() == size)
+        return;
+
+    // Invalidate the new part of the window now for the pending paint to
+    // minimize background flashes (GDK does not do this for external resizes
+    // of toplevels.)
+    if (mBounds.width < size.width) {
+        GdkRectangle rect = DevicePixelsToGdkRectRoundOut(
+            LayoutDeviceIntRect(mBounds.width, 0,
+                                size.width - mBounds.width, size.height));
+        gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
+    }
+    if (mBounds.height < size.height) {
+        GdkRectangle rect = DevicePixelsToGdkRectRoundOut(
+            LayoutDeviceIntRect(0, mBounds.height,
+                                size.width, size.height - mBounds.height));
+        gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
+    }
+
+    mBounds.SizeTo(size);
+
+#ifdef MOZ_X11
+    // Notify the X11CompositorWidget of a ClientSizeChange
+    if (mCompositorWidgetDelegate) {
+      mCompositorWidgetDelegate->NotifyClientSizeChanged(GetClientSize());
+    }
+#endif
+
+    // Gecko permits running nested event loops during processing of events,
+    // GtkWindow callers of gtk_widget_size_allocate expect the signal
+    // handlers to return sometime in the near future.
+    mNeedsDispatchResized = true;
+    NS_DispatchToCurrentThread(NewRunnableMethod(this, &nsWindow::MaybeDispatchResized));
+}
+
+void
+nsWindow::OnDeleteEvent()
+{
+    if (mWidgetListener)
+        mWidgetListener->RequestWindowClose(this);
+}
+
+void
+nsWindow::OnEnterNotifyEvent(GdkEventCrossing *aEvent)
+{
+    // This skips NotifyVirtual and NotifyNonlinearVirtual enter notify events
+    // when the pointer enters a child window.  If the destination window is a
+    // Gecko window then we'll catch the corresponding event on that window,
+    // but we won't notice when the pointer directly enters a foreign (plugin)
+    // child window without passing over a visible portion of a Gecko window.
+    if (aEvent->subwindow != nullptr)
+        return;
+
+    // Check before is_parent_ungrab_enter() as the button state may have
+    // changed while a non-Gecko ancestor window had a pointer grab.
+    DispatchMissedButtonReleases(aEvent);
+
+    if (is_parent_ungrab_enter(aEvent))
+        return;
+
+    WidgetMouseEvent event(true, eMouseEnterIntoWidget, this,
+                           WidgetMouseEvent::eReal);
+
+    event.mRefPoint = GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+    event.AssignEventTime(GetWidgetEventTime(aEvent->time));
+
+    LOG(("OnEnterNotify: %p\n", (void *)this));
+
+    DispatchInputEvent(&event);
+}
+
+// XXX Is this the right test for embedding cases?
+static bool
+is_top_level_mouse_exit(GdkWindow* aWindow, GdkEventCrossing *aEvent)
+{
+    gint x = gint(aEvent->x_root);
+    gint y = gint(aEvent->y_root);
+    GdkDisplay* display = gdk_window_get_display(aWindow);
+    GdkWindow* winAtPt = gdk_display_get_window_at_pointer(display, &x, &y);
+    if (!winAtPt)
+        return true;
+    GdkWindow* topLevelAtPt = gdk_window_get_toplevel(winAtPt);
+    GdkWindow* topLevelWidget = gdk_window_get_toplevel(aWindow);
+    return topLevelAtPt != topLevelWidget;
+}
+
+void
+nsWindow::OnLeaveNotifyEvent(GdkEventCrossing *aEvent)
+{
+    // This ignores NotifyVirtual and NotifyNonlinearVirtual leave notify
+    // events when the pointer leaves a child window.  If the destination
+    // window is a Gecko window then we'll catch the corresponding event on
+    // that window.
+    //
+    // XXXkt However, we will miss toplevel exits when the pointer directly
+    // leaves a foreign (plugin) child window without passing over a visible
+    // portion of a Gecko window.
+    if (aEvent->subwindow != nullptr)
+        return;
+
+    WidgetMouseEvent event(true, eMouseExitFromWidget, this,
+                           WidgetMouseEvent::eReal);
+
+    event.mRefPoint = GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+    event.AssignEventTime(GetWidgetEventTime(aEvent->time));
+
+    event.mExitFrom = is_top_level_mouse_exit(mGdkWindow, aEvent)
+        ? WidgetMouseEvent::eTopLevel : WidgetMouseEvent::eChild;
+
+    LOG(("OnLeaveNotify: %p\n", (void *)this));
+
+    DispatchInputEvent(&event);
+}
+
+template <typename Event> static LayoutDeviceIntPoint
+GetRefPoint(nsWindow* aWindow, Event* aEvent)
+{
+    if (aEvent->window == aWindow->GetGdkWindow()) {
+        // we are the window that the event happened on so no need for expensive WidgetToScreenOffset
+        return aWindow->GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+    }
+    // XXX we're never quite sure which GdkWindow the event came from due to our custom bubbling
+    // in scroll_event_cb(), so use ScreenToWidget to translate the screen root coordinates into
+    // coordinates relative to this widget.
+    return aWindow->GdkEventCoordsToDevicePixels(
+        aEvent->x_root, aEvent->y_root) - aWindow->WidgetToScreenOffset();
+}
+
+void
+nsWindow::OnMotionNotifyEvent(GdkEventMotion *aEvent)
+{
+    // see if we can compress this event
+    // XXXldb Why skip every other motion event when we have multiple,
+    // but not more than that?
+    bool synthEvent = false;
+#ifdef MOZ_X11
+    XEvent xevent;
+
+    if (mIsX11Display) {
+        while (XPending (GDK_WINDOW_XDISPLAY(aEvent->window))) {
+            XEvent peeked;
+            XPeekEvent (GDK_WINDOW_XDISPLAY(aEvent->window), &peeked);
+            if (peeked.xany.window != gdk_x11_window_get_xid(aEvent->window)
+                || peeked.type != MotionNotify)
+                break;
+
+            synthEvent = true;
+            XNextEvent (GDK_WINDOW_XDISPLAY(aEvent->window), &xevent);
+        }
+#if (MOZ_WIDGET_GTK == 2)
+        // if plugins still keeps the focus, get it back
+        if (gPluginFocusWindow && gPluginFocusWindow != this) {
+            RefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
+            gPluginFocusWindow->LoseNonXEmbedPluginFocus();
+        }
+#endif /* MOZ_WIDGET_GTK == 2 */
+    }
+#endif /* MOZ_X11 */
+
+    WidgetMouseEvent event(true, eMouseMove, this, WidgetMouseEvent::eReal);
+
+    gdouble pressure = 0;
+    gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+    // Sometime gdk generate 0 pressure value between normal values
+    // We have to ignore that and use last valid value
+    if (pressure)
+      mLastMotionPressure = pressure;
+    event.pressure = mLastMotionPressure;
+
+    guint modifierState;
+    if (synthEvent) {
+#ifdef MOZ_X11
+        event.mRefPoint.x = nscoord(xevent.xmotion.x);
+        event.mRefPoint.y = nscoord(xevent.xmotion.y);
+
+        modifierState = xevent.xmotion.state;
+
+        event.AssignEventTime(GetWidgetEventTime(xevent.xmotion.time));
+#else
+        event.mRefPoint = GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+
+        modifierState = aEvent->state;
+
+        event.AssignEventTime(GetWidgetEventTime(aEvent->time));
+#endif /* MOZ_X11 */
+    } else {
+        event.mRefPoint = GetRefPoint(this, aEvent);
+
+        modifierState = aEvent->state;
+
+        event.AssignEventTime(GetWidgetEventTime(aEvent->time));
+    }
+
+    KeymapWrapper::InitInputEvent(event, modifierState);
+
+    DispatchInputEvent(&event);
+}
+
+// If the automatic pointer grab on ButtonPress has deactivated before
+// ButtonRelease, and the mouse button is released while the pointer is not
+// over any a Gecko window, then the ButtonRelease event will not be received.
+// (A similar situation exists when the pointer is grabbed with owner_events
+// True as the ButtonRelease may be received on a foreign [plugin] window).
+// Use this method to check for released buttons when the pointer returns to a
+// Gecko window.
+void
+nsWindow::DispatchMissedButtonReleases(GdkEventCrossing *aGdkEvent)
+{
+    guint changed = aGdkEvent->state ^ gButtonState;
+    // Only consider button releases.
+    // (Ignore button presses that occurred outside Gecko.)
+    guint released = changed & gButtonState;
+    gButtonState = aGdkEvent->state;
+
+    // Loop over each button, excluding mouse wheel buttons 4 and 5 for which
+    // GDK ignores releases.
+    for (guint buttonMask = GDK_BUTTON1_MASK;
+         buttonMask <= GDK_BUTTON3_MASK;
+         buttonMask <<= 1) {
+
+        if (released & buttonMask) {
+            int16_t buttonType;
+            switch (buttonMask) {
+            case GDK_BUTTON1_MASK:
+                buttonType = WidgetMouseEvent::eLeftButton;
+                break;
+            case GDK_BUTTON2_MASK:
+                buttonType = WidgetMouseEvent::eMiddleButton;
+                break;
+            default:
+                NS_ASSERTION(buttonMask == GDK_BUTTON3_MASK,
+                             "Unexpected button mask");
+                buttonType = WidgetMouseEvent::eRightButton;
+            }
+
+            LOG(("Synthesized button %u release on %p\n",
+                 guint(buttonType + 1), (void *)this));
+
+            // Dispatch a synthesized button up event to tell Gecko about the
+            // change in state.  This event is marked as synthesized so that
+            // it is not dispatched as a DOM event, because we don't know the
+            // position, widget, modifiers, or time/order.
+            WidgetMouseEvent synthEvent(true, eMouseUp, this,
+                                        WidgetMouseEvent::eSynthesized);
+            synthEvent.button = buttonType;
+            DispatchInputEvent(&synthEvent);
+        }
+    }
+}
+
+void
+nsWindow::InitButtonEvent(WidgetMouseEvent& aEvent,
+                          GdkEventButton* aGdkEvent)
+{
+    aEvent.mRefPoint = GetRefPoint(this, aGdkEvent);
+
+    guint modifierState = aGdkEvent->state;
+    // aEvent's state includes the button state from immediately before this
+    // event.  If aEvent is a mousedown or mouseup event, we need to update
+    // the button state.
+    guint buttonMask = 0;
+    switch (aGdkEvent->button) {
+        case 1:
+            buttonMask = GDK_BUTTON1_MASK;
+            break;
+        case 2:
+            buttonMask = GDK_BUTTON2_MASK;
+            break;
+        case 3:
+            buttonMask = GDK_BUTTON3_MASK;
+            break;
+    }
+    if (aGdkEvent->type == GDK_BUTTON_RELEASE) {
+        modifierState &= ~buttonMask;
+    } else {
+        modifierState |= buttonMask;
+    }
+
+    KeymapWrapper::InitInputEvent(aEvent, modifierState);
+
+    aEvent.AssignEventTime(GetWidgetEventTime(aGdkEvent->time));
+
+    switch (aGdkEvent->type) {
+    case GDK_2BUTTON_PRESS:
+        aEvent.mClickCount = 2;
+        break;
+    case GDK_3BUTTON_PRESS:
+        aEvent.mClickCount = 3;
+        break;
+        // default is one click
+    default:
+        aEvent.mClickCount = 1;
+    }
+}
+
+static guint ButtonMaskFromGDKButton(guint button)
+{
+    return GDK_BUTTON1_MASK << (button - 1);
+}
+
+void
+nsWindow::OnButtonPressEvent(GdkEventButton *aEvent)
+{
+    LOG(("Button %u press on %p\n", aEvent->button, (void *)this));
+
+    // If you double click in GDK, it will actually generate a second
+    // GDK_BUTTON_PRESS before sending the GDK_2BUTTON_PRESS, and this is
+    // different than the DOM spec.  GDK puts this in the queue
+    // programatically, so it's safe to assume that if there's a
+    // double click in the queue, it was generated so we can just drop
+    // this click.
+    GdkEvent *peekedEvent = gdk_event_peek();
+    if (peekedEvent) {
+        GdkEventType type = peekedEvent->any.type;
+        gdk_event_free(peekedEvent);
+        if (type == GDK_2BUTTON_PRESS || type == GDK_3BUTTON_PRESS)
+            return;
+    }
+
+    nsWindow *containerWindow = GetContainerWindow();
+    if (!gFocusWindow && containerWindow) {
+        containerWindow->DispatchActivateEvent();
+    }
+
+    // check to see if we should rollup
+    if (CheckForRollup(aEvent->x_root, aEvent->y_root, false, false))
+        return;
+
+    gdouble pressure = 0;
+    gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+    mLastMotionPressure = pressure;
+
+    uint16_t domButton;
+    switch (aEvent->button) {
+    case 1:
+        domButton = WidgetMouseEvent::eLeftButton;
+        break;
+    case 2:
+        domButton = WidgetMouseEvent::eMiddleButton;
+        break;
+    case 3:
+        domButton = WidgetMouseEvent::eRightButton;
+        break;
+    // These are mapped to horizontal scroll
+    case 6:
+    case 7:
+        NS_WARNING("We're not supporting legacy horizontal scroll event");
+        return;
+    // Map buttons 8-9 to back/forward
+    case 8:
+        DispatchCommandEvent(nsGkAtoms::Back);
+        return;
+    case 9:
+        DispatchCommandEvent(nsGkAtoms::Forward);
+        return;
+    default:
+        return;
+    }
+
+    gButtonState |= ButtonMaskFromGDKButton(aEvent->button);
+
+    WidgetMouseEvent event(true, eMouseDown, this, WidgetMouseEvent::eReal);
+    event.button = domButton;
+    InitButtonEvent(event, aEvent);
+    event.pressure = mLastMotionPressure;
+
+    DispatchInputEvent(&event);
+
+    // right menu click on linux should also pop up a context menu
+    if (domButton == WidgetMouseEvent::eRightButton &&
+        MOZ_LIKELY(!mIsDestroyed)) {
+        WidgetMouseEvent contextMenuEvent(true, eContextMenu, this,
+                                          WidgetMouseEvent::eReal);
+        InitButtonEvent(contextMenuEvent, aEvent);
+        contextMenuEvent.pressure = mLastMotionPressure;
+        DispatchInputEvent(&contextMenuEvent);
+    }
+}
+
+void
+nsWindow::OnButtonReleaseEvent(GdkEventButton *aEvent)
+{
+    LOG(("Button %u release on %p\n", aEvent->button, (void *)this));
+
+    uint16_t domButton;
+    switch (aEvent->button) {
+    case 1:
+        domButton = WidgetMouseEvent::eLeftButton;
+        break;
+    case 2:
+        domButton = WidgetMouseEvent::eMiddleButton;
+        break;
+    case 3:
+        domButton = WidgetMouseEvent::eRightButton;
+        break;
+    default:
+        return;
+    }
+
+    gButtonState &= ~ButtonMaskFromGDKButton(aEvent->button);
+
+    WidgetMouseEvent event(true, eMouseUp, this,
+                           WidgetMouseEvent::eReal);
+    event.button = domButton;
+    InitButtonEvent(event, aEvent);
+    gdouble pressure = 0;
+    gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+    event.pressure = pressure ? pressure : mLastMotionPressure;
+
+    DispatchInputEvent(&event);
+    mLastMotionPressure = pressure;
+}
+
+void
+nsWindow::OnContainerFocusInEvent(GdkEventFocus *aEvent)
+{
+    LOGFOCUS(("OnContainerFocusInEvent [%p]\n", (void *)this));
+
+    // Unset the urgency hint, if possible
+    GtkWidget* top_window = GetToplevelWidget();
+    if (top_window && (gtk_widget_get_visible(top_window)))
+        SetUrgencyHint(top_window, false);
+
+    // Return if being called within SetFocus because the focus manager
+    // already knows that the window is active.
+    if (gBlockActivateEvent) {
+        LOGFOCUS(("activated notification is blocked [%p]\n", (void *)this));
+        return;
+    }
+
+    // If keyboard input will be accepted, the focus manager will call
+    // SetFocus to set the correct window.
+    gFocusWindow = nullptr;
+
+    DispatchActivateEvent();
+
+    if (!gFocusWindow) {
+        // We don't really have a window for dispatching key events, but
+        // setting a non-nullptr value here prevents OnButtonPressEvent() from
+        // dispatching an activation notification if the widget is already
+        // active.
+        gFocusWindow = this;
+    }
+
+    LOGFOCUS(("Events sent from focus in event [%p]\n", (void *)this));
+}
+
+void
+nsWindow::OnContainerFocusOutEvent(GdkEventFocus *aEvent)
+{
+    LOGFOCUS(("OnContainerFocusOutEvent [%p]\n", (void *)this));
+
+    if (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog) {
+        nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
+        nsCOMPtr<nsIDragSession> dragSession;
+        dragService->GetCurrentSession(getter_AddRefs(dragSession));
+
+        // Rollup popups when a window is focused out unless a drag is occurring.
+        // This check is because drags grab the keyboard and cause a focus out on
+        // versions of GTK before 2.18.
+        bool shouldRollup = !dragSession;
+        if (!shouldRollup) {
+            // we also roll up when a drag is from a different application
+            nsCOMPtr<nsIDOMNode> sourceNode;
+            dragSession->GetSourceNode(getter_AddRefs(sourceNode));
+            shouldRollup = (sourceNode == nullptr);
+        }
+
+        if (shouldRollup) {
+            CheckForRollup(0, 0, false, true);
+        }
+    }
+
+#if (MOZ_WIDGET_GTK == 2) && defined(MOZ_X11)
+    // plugin lose focus
+    if (gPluginFocusWindow) {
+        RefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
+        gPluginFocusWindow->LoseNonXEmbedPluginFocus();
+    }
+#endif /* MOZ_X11 && MOZ_WIDGET_GTK == 2 */
+
+    if (gFocusWindow) {
+        RefPtr<nsWindow> kungFuDeathGrip = gFocusWindow;
+        if (gFocusWindow->mIMContext) {
+            gFocusWindow->mIMContext->OnBlurWindow(gFocusWindow);
+        }
+        gFocusWindow = nullptr;
+    }
+
+    DispatchDeactivateEvent();
+
+    LOGFOCUS(("Done with container focus out [%p]\n", (void *)this));
+}
+
+bool
+nsWindow::DispatchCommandEvent(nsIAtom* aCommand)
+{
+    nsEventStatus status;
+    WidgetCommandEvent event(true, nsGkAtoms::onAppCommand, aCommand, this);
+    DispatchEvent(&event, status);
+    return TRUE;
+}
+
+bool
+nsWindow::DispatchContentCommandEvent(EventMessage aMsg)
+{
+  nsEventStatus status;
+  WidgetContentCommandEvent event(true, aMsg, this);
+  DispatchEvent(&event, status);
+  return TRUE;
+}
+
+static bool
+IsCtrlAltTab(GdkEventKey *aEvent)
+{
+    return aEvent->keyval == GDK_Tab &&
+        KeymapWrapper::AreModifiersActive(
+            KeymapWrapper::CTRL | KeymapWrapper::ALT, aEvent->state);
+}
+
+bool
+nsWindow::DispatchKeyDownEvent(GdkEventKey *aEvent, bool *aCancelled)
+{
+    NS_PRECONDITION(aCancelled, "aCancelled must not be null");
+
+    *aCancelled = false;
+
+    if (IsCtrlAltTab(aEvent)) {
+        return false;
+    }
+
+    RefPtr<TextEventDispatcher> dispatcher = GetTextEventDispatcher();
+    nsresult rv = dispatcher->BeginNativeInputTransaction();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+        return FALSE;
+    }
+
+    WidgetKeyboardEvent keydownEvent(true, eKeyDown, this);
+    KeymapWrapper::InitKeyEvent(keydownEvent, aEvent);
+    nsEventStatus status = nsEventStatus_eIgnore;
+    bool dispatched =
+        dispatcher->DispatchKeyboardEvent(eKeyDown, keydownEvent,
+                                          status, aEvent);
+    *aCancelled = (status == nsEventStatus_eConsumeNoDefault);
+    return dispatched ? TRUE : FALSE;
+}
+
+WidgetEventTime
+nsWindow::GetWidgetEventTime(guint32 aEventTime)
+{
+  return WidgetEventTime(aEventTime, GetEventTimeStamp(aEventTime));
+}
+
+TimeStamp
+nsWindow::GetEventTimeStamp(guint32 aEventTime)
+{
+    if (MOZ_UNLIKELY(!mGdkWindow)) {
+        // nsWindow has been Destroy()ed.
+        return TimeStamp::Now();
+    }
+    if (aEventTime == 0) {
+        // Some X11 and GDK events may be received with a time of 0 to indicate
+        // that they are synthetic events. Some input method editors do this.
+        // In this case too, just return the current timestamp.
+        return TimeStamp::Now();
+    }
+    CurrentX11TimeGetter* getCurrentTime = GetCurrentTimeGetter();
+    MOZ_ASSERT(getCurrentTime,
+               "Null current time getter despite having a window");
+    return TimeConverter().GetTimeStampFromSystemTime(aEventTime,
+                                                      *getCurrentTime);
+}
+
+mozilla::CurrentX11TimeGetter*
+nsWindow::GetCurrentTimeGetter() {
+    MOZ_ASSERT(mGdkWindow, "Expected mGdkWindow to be set");
+    if (MOZ_UNLIKELY(!mCurrentTimeGetter)) {
+        mCurrentTimeGetter = MakeUnique<CurrentX11TimeGetter>(mGdkWindow);
+    }
+    return mCurrentTimeGetter.get();
+}
+
+gboolean
+nsWindow::OnKeyPressEvent(GdkEventKey *aEvent)
+{
+    LOGFOCUS(("OnKeyPressEvent [%p]\n", (void *)this));
+
+    // if we are in the middle of composing text, XIM gets to see it
+    // before mozilla does.
+    // FYI: Don't dispatch keydown event before notifying IME of the event
+    //      because IME may send a key event synchronously and consume the
+    //      original event.
+    bool IMEWasEnabled = false;
+    if (mIMContext) {
+        IMEWasEnabled = mIMContext->IsEnabled();
+        if (mIMContext->OnKeyEvent(this, aEvent)) {
+            return TRUE;
+        }
+    }
+
+    // work around for annoying things.
+    if (IsCtrlAltTab(aEvent)) {
+        return TRUE;
+    }
+
+    nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
+
+    // Dispatch keydown event always.  At auto repeating, we should send
+    // KEYDOWN -> KEYPRESS -> KEYDOWN -> KEYPRESS ... -> KEYUP
+    // However, old distributions (e.g., Ubuntu 9.10) sent native key
+    // release event, so, on such platform, the DOM events will be:
+    // KEYDOWN -> KEYPRESS -> KEYUP -> KEYDOWN -> KEYPRESS -> KEYUP...
+
+    bool isKeyDownCancelled = false;
+    if (DispatchKeyDownEvent(aEvent, &isKeyDownCancelled) &&
+        (MOZ_UNLIKELY(mIsDestroyed) || isKeyDownCancelled)) {
+        return TRUE;
+    }
+
+    // If a keydown event handler causes to enable IME, i.e., it moves
+    // focus from IME unusable content to IME usable editor, we should
+    // send the native key event to IME for the first input on the editor.
+    if (!IMEWasEnabled && mIMContext && mIMContext->IsEnabled()) {
+        // Notice our keydown event was already dispatched.  This prevents
+        // unnecessary DOM keydown event in the editor.
+        if (mIMContext->OnKeyEvent(this, aEvent, true)) {
+            return TRUE;
+        }
+    }
+
+    // Look for specialized app-command keys
+    switch (aEvent->keyval) {
+        case GDK_Back:
+            return DispatchCommandEvent(nsGkAtoms::Back);
+        case GDK_Forward:
+            return DispatchCommandEvent(nsGkAtoms::Forward);
+        case GDK_Refresh:
+            return DispatchCommandEvent(nsGkAtoms::Reload);
+        case GDK_Stop:
+            return DispatchCommandEvent(nsGkAtoms::Stop);
+        case GDK_Search:
+            return DispatchCommandEvent(nsGkAtoms::Search);
+        case GDK_Favorites:
+            return DispatchCommandEvent(nsGkAtoms::Bookmarks);
+        case GDK_HomePage:
+            return DispatchCommandEvent(nsGkAtoms::Home);
+        case GDK_Copy:
+        case GDK_F16:  // F16, F20, F18, F14 are old keysyms for Copy Cut Paste Undo
+            return DispatchContentCommandEvent(eContentCommandCopy);
+        case GDK_Cut:
+        case GDK_F20:
+            return DispatchContentCommandEvent(eContentCommandCut);
+        case GDK_Paste:
+        case GDK_F18:
+            return DispatchContentCommandEvent(eContentCommandPaste);
+        case GDK_Redo:
+            return DispatchContentCommandEvent(eContentCommandRedo);
+        case GDK_Undo:
+        case GDK_F14:
+            return DispatchContentCommandEvent(eContentCommandUndo);
+    }
+
+    WidgetKeyboardEvent keypressEvent(true, eKeyPress, this);
+    KeymapWrapper::InitKeyEvent(keypressEvent, aEvent);
+
+    // before we dispatch a key, check if it's the context menu key.
+    // If so, send a context menu key event instead.
+    if (is_context_menu_key(keypressEvent)) {
+        WidgetMouseEvent contextMenuEvent(true, eContextMenu, this,
+                                          WidgetMouseEvent::eReal,
+                                          WidgetMouseEvent::eContextMenuKey);
+
+        contextMenuEvent.mRefPoint = LayoutDeviceIntPoint(0, 0);
+        contextMenuEvent.AssignEventTime(GetWidgetEventTime(aEvent->time));
+        contextMenuEvent.mClickCount = 1;
+        KeymapWrapper::InitInputEvent(contextMenuEvent, aEvent->state);
+        DispatchInputEvent(&contextMenuEvent);
+    } else {
+        RefPtr<TextEventDispatcher> dispatcher = GetTextEventDispatcher();
+        nsresult rv = dispatcher->BeginNativeInputTransaction();
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+            return TRUE;
+        }
+
+        // If the character code is in the BMP, send the key press event.
+        // Otherwise, send a compositionchange event with the equivalent UTF-16
+        // string.
+        // TODO: Investigate other browser's behavior in this case because
+        //       this hack is odd for UI Events.
+        nsEventStatus status = nsEventStatus_eIgnore;
+        if (keypressEvent.mKeyNameIndex != KEY_NAME_INDEX_USE_STRING ||
+            keypressEvent.mKeyValue.Length() == 1) {
+            dispatcher->MaybeDispatchKeypressEvents(keypressEvent,
+                                                    status, aEvent);
+        } else {
+            WidgetEventTime eventTime = GetWidgetEventTime(aEvent->time);
+            dispatcher->CommitComposition(status, &keypressEvent.mKeyValue,
+                                          &eventTime);
+        }
+    }
+
+    return TRUE;
+}
+
+gboolean
+nsWindow::OnKeyReleaseEvent(GdkEventKey *aEvent)
+{
+    LOGFOCUS(("OnKeyReleaseEvent [%p]\n", (void *)this));
+
+    if (mIMContext && mIMContext->OnKeyEvent(this, aEvent)) {
+        return TRUE;
+    }
+
+    RefPtr<TextEventDispatcher> dispatcher = GetTextEventDispatcher();
+    nsresult rv = dispatcher->BeginNativeInputTransaction();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+        return false;
+    }
+
+    WidgetKeyboardEvent keyupEvent(true, eKeyUp, this);
+    KeymapWrapper::InitKeyEvent(keyupEvent, aEvent);
+    nsEventStatus status = nsEventStatus_eIgnore;
+    dispatcher->DispatchKeyboardEvent(eKeyUp, keyupEvent, status, aEvent);
+
+    return TRUE;
+}
+
+void
+nsWindow::OnScrollEvent(GdkEventScroll *aEvent)
+{
+    // check to see if we should rollup
+    if (CheckForRollup(aEvent->x_root, aEvent->y_root, true, false))
+        return;
+#if GTK_CHECK_VERSION(3,4,0)
+    // check for duplicate legacy scroll event, see GNOME bug 726878
+    if (aEvent->direction != GDK_SCROLL_SMOOTH &&
+        mLastScrollEventTime == aEvent->time)
+        return;
+#endif
+    WidgetWheelEvent wheelEvent(true, eWheel, this);
+    wheelEvent.mDeltaMode = nsIDOMWheelEvent::DOM_DELTA_LINE;
+    switch (aEvent->direction) {
+#if GTK_CHECK_VERSION(3,4,0)
+    case GDK_SCROLL_SMOOTH:
+    {
+        // As of GTK 3.4, all directional scroll events are provided by
+        // the GDK_SCROLL_SMOOTH direction on XInput2 devices.
+        mLastScrollEventTime = aEvent->time;
+        // TODO - use a more appropriate scrolling unit than lines.
+        // Multiply event deltas by 3 to emulate legacy behaviour.
+        wheelEvent.mDeltaX = aEvent->delta_x * 3;
+        wheelEvent.mDeltaY = aEvent->delta_y * 3;
+        wheelEvent.mIsNoLineOrPageDelta = true;
+        // This next step manually unsets smooth scrolling for touch devices
+        // that trigger GDK_SCROLL_SMOOTH. We use the slave device, which
+        // represents the actual input.
+        GdkDevice *device = gdk_event_get_source_device((GdkEvent*)aEvent);
+        GdkInputSource source = gdk_device_get_source(device);
+        if (source == GDK_SOURCE_TOUCHSCREEN ||
+            source == GDK_SOURCE_TOUCHPAD) {
+            wheelEvent.mScrollType = WidgetWheelEvent::SCROLL_ASYNCHRONOUSELY;
+        }
+        break;
+    }
+#endif
+    case GDK_SCROLL_UP:
+        wheelEvent.mDeltaY = wheelEvent.mLineOrPageDeltaY = -3;
+        break;
+    case GDK_SCROLL_DOWN:
+        wheelEvent.mDeltaY = wheelEvent.mLineOrPageDeltaY = 3;
+        break;
+    case GDK_SCROLL_LEFT:
+        wheelEvent.mDeltaX = wheelEvent.mLineOrPageDeltaX = -1;
+        break;
+    case GDK_SCROLL_RIGHT:
+        wheelEvent.mDeltaX = wheelEvent.mLineOrPageDeltaX = 1;
+        break;
+    }
+
+    wheelEvent.mRefPoint = GetRefPoint(this, aEvent);
+
+    KeymapWrapper::InitInputEvent(wheelEvent, aEvent->state);
+
+    wheelEvent.AssignEventTime(GetWidgetEventTime(aEvent->time));
+
+    DispatchInputEvent(&wheelEvent);
+}
+
+void
+nsWindow::OnVisibilityNotifyEvent(GdkEventVisibility *aEvent)
+{
+    LOGDRAW(("Visibility event %i on [%p] %p\n",
+             aEvent->state, this, aEvent->window));
+
+    if (!mGdkWindow)
+        return;
+
+    switch (aEvent->state) {
+    case GDK_VISIBILITY_UNOBSCURED:
+    case GDK_VISIBILITY_PARTIAL:
+        if (mIsFullyObscured && mHasMappedToplevel) {
+            // GDK_EXPOSE events have been ignored, so make sure GDK
+            // doesn't think that the window has already been painted.
+            gdk_window_invalidate_rect(mGdkWindow, nullptr, FALSE);
+        }
+
+        mIsFullyObscured = false;
+
+        // if we have to retry the grab, retry it.
+        EnsureGrabs();
+        break;
+    default: // includes GDK_VISIBILITY_FULLY_OBSCURED
+        mIsFullyObscured = true;
+        break;
+    }
+}
+
+void
+nsWindow::OnWindowStateEvent(GtkWidget *aWidget, GdkEventWindowState *aEvent)
+{
+    LOG(("nsWindow::OnWindowStateEvent [%p] changed %d new_window_state %d\n",
+         (void *)this, aEvent->changed_mask, aEvent->new_window_state));
+
+    if (IS_MOZ_CONTAINER(aWidget)) {
+        // This event is notifying the container widget of changes to the
+        // toplevel window.  Just detect changes affecting whether windows are
+        // viewable.
+        //
+        // (A visibility notify event is sent to each window that becomes
+        // viewable when the toplevel is mapped, but we can't rely on that for
+        // setting mHasMappedToplevel because these toplevel window state
+        // events are asynchronous.  The windows in the hierarchy now may not
+        // be the same windows as when the toplevel was mapped, so they may
+        // not get VisibilityNotify events.)
+        bool mapped =
+            !(aEvent->new_window_state &
+              (GDK_WINDOW_STATE_ICONIFIED|GDK_WINDOW_STATE_WITHDRAWN));
+        if (mHasMappedToplevel != mapped) {
+            SetHasMappedToplevel(mapped);
+        }
+        return;
+    }
+    // else the widget is a shell widget.
+
+    // We don't care about anything but changes in the maximized/icon/fullscreen
+    // states
+    if ((aEvent->changed_mask
+         & (GDK_WINDOW_STATE_ICONIFIED |
+            GDK_WINDOW_STATE_MAXIMIZED |
+            GDK_WINDOW_STATE_FULLSCREEN)) == 0) {
+        return;
+    }
+
+    if (aEvent->new_window_state & GDK_WINDOW_STATE_ICONIFIED) {
+        LOG(("\tIconified\n"));
+        mSizeState = nsSizeMode_Minimized;
+#ifdef ACCESSIBILITY
+        DispatchMinimizeEventAccessible();
+#endif //ACCESSIBILITY
+    }
+    else if (aEvent->new_window_state & GDK_WINDOW_STATE_FULLSCREEN) {
+        LOG(("\tFullscreen\n"));
+        mSizeState = nsSizeMode_Fullscreen;
+    }
+    else if (aEvent->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) {
+        LOG(("\tMaximized\n"));
+        mSizeState = nsSizeMode_Maximized;
+#ifdef ACCESSIBILITY
+        DispatchMaximizeEventAccessible();
+#endif //ACCESSIBILITY
+    }
+    else {
+        LOG(("\tNormal\n"));
+        mSizeState = nsSizeMode_Normal;
+#ifdef ACCESSIBILITY
+        DispatchRestoreEventAccessible();
+#endif //ACCESSIBILITY
+    }
+
+    if (mWidgetListener) {
+      mWidgetListener->SizeModeChanged(mSizeState);
+      if (aEvent->changed_mask & GDK_WINDOW_STATE_FULLSCREEN) {
+        mWidgetListener->FullscreenChanged(
+          aEvent->new_window_state & GDK_WINDOW_STATE_FULLSCREEN);
+      }
+    }
+}
+
+void
+nsWindow::ThemeChanged()
+{
+    NotifyThemeChanged();
+
+    if (!mGdkWindow || MOZ_UNLIKELY(mIsDestroyed))
+        return;
+
+    // Dispatch theme change notification to all child windows
+    GList *children =
+        gdk_window_peek_children(mGdkWindow);
+    while (children) {
+        GdkWindow *gdkWin = GDK_WINDOW(children->data);
+
+        nsWindow *win = (nsWindow*) g_object_get_data(G_OBJECT(gdkWin),
+                                                      "nsWindow");
+
+        if (win && win != this) { // guard against infinite recursion
+            RefPtr<nsWindow> kungFuDeathGrip = win;
+            win->ThemeChanged();
+        }
+
+        children = children->next;
+    }
+}
+
+void
+nsWindow::OnDPIChanged()
+{
+  if (mWidgetListener) {
+    nsIPresShell* presShell = mWidgetListener->GetPresShell();
+    if (presShell) {
+      presShell->BackingScaleFactorChanged();
+      // Update menu's font size etc
+      presShell->ThemeChanged();
+    }
+  }
+}
+
+void
+nsWindow::OnCheckResize()
+{
+    mPendingConfigures++;
+}
+
+void
+nsWindow::DispatchDragEvent(EventMessage aMsg, const LayoutDeviceIntPoint& aRefPoint,
+                            guint aTime)
+{
+    WidgetDragEvent event(true, aMsg, this);
+
+    if (aMsg == eDragOver) {
+        InitDragEvent(event);
+    }
+
+    event.mRefPoint = aRefPoint;
+    event.AssignEventTime(GetWidgetEventTime(aTime));
+
+    DispatchInputEvent(&event);
+}
+
+void
+nsWindow::OnDragDataReceivedEvent(GtkWidget *aWidget,
+                                  GdkDragContext *aDragContext,
+                                  gint aX,
+                                  gint aY,
+                                  GtkSelectionData  *aSelectionData,
+                                  guint aInfo,
+                                  guint aTime,
+                                  gpointer aData)
+{
+    LOGDRAG(("nsWindow::OnDragDataReceived(%p)\n", (void*)this));
+
+    nsDragService::GetInstance()->
+        TargetDataReceived(aWidget, aDragContext, aX, aY,
+                           aSelectionData, aInfo, aTime);
+}
+
+#if GTK_CHECK_VERSION(3,4,0)
+gboolean
+nsWindow::OnTouchEvent(GdkEventTouch* aEvent)
+{
+    if (!mHandleTouchEvent) {
+        return FALSE;
+    }
+
+    EventMessage msg;
+    switch (aEvent->type) {
+    case GDK_TOUCH_BEGIN:
+        msg = eTouchStart;
+        break;
+    case GDK_TOUCH_UPDATE:
+        msg = eTouchMove;
+        break;
+    case GDK_TOUCH_END:
+        msg = eTouchEnd;
+        break;
+    case GDK_TOUCH_CANCEL:
+        msg = eTouchCancel;
+        break;
+    default:
+        return FALSE;
+    }
+
+    LayoutDeviceIntPoint touchPoint = GetRefPoint(this, aEvent);
+
+    int32_t id;
+    RefPtr<dom::Touch> touch;
+    if (mTouches.Remove(aEvent->sequence, getter_AddRefs(touch))) {
+        id = touch->mIdentifier;
+    } else {
+        id = ++gLastTouchID & 0x7FFFFFFF;
+    }
+
+    touch = new dom::Touch(id, touchPoint, LayoutDeviceIntPoint(1, 1),
+                           0.0f, 0.0f);
+
+    WidgetTouchEvent event(true, msg, this);
+    KeymapWrapper::InitInputEvent(event, aEvent->state);
+    event.mTime = aEvent->time;
+
+    if (aEvent->type == GDK_TOUCH_BEGIN || aEvent->type == GDK_TOUCH_UPDATE) {
+        mTouches.Put(aEvent->sequence, touch.forget());
+        // add all touch points to event object
+        for (auto iter = mTouches.Iter(); !iter.Done(); iter.Next()) {
+            event.mTouches.AppendElement(new dom::Touch(*iter.UserData()));
+        }
+    } else if (aEvent->type == GDK_TOUCH_END ||
+               aEvent->type == GDK_TOUCH_CANCEL) {
+        *event.mTouches.AppendElement() = touch.forget();
+    }
+
+    DispatchInputEvent(&event);
+    return TRUE;
+}
+#endif
+
+static void
+GetBrandName(nsXPIDLString& brandName)
+{
+    nsCOMPtr<nsIStringBundleService> bundleService =
+        do_GetService(NS_STRINGBUNDLE_CONTRACTID);
+
+    nsCOMPtr<nsIStringBundle> bundle;
+    if (bundleService)
+        bundleService->CreateBundle(
+            "chrome://branding/locale/brand.properties",
+            getter_AddRefs(bundle));
+
+    if (bundle)
+        bundle->GetStringFromName(
+            u"brandShortName",
+            getter_Copies(brandName));
+
+    if (brandName.IsEmpty())
+        brandName.AssignLiteral(u"Mozilla");
+}
+
+static GdkWindow *
+CreateGdkWindow(GdkWindow *parent, GtkWidget *widget)
+{
+    GdkWindowAttr attributes;
+    gint          attributes_mask = GDK_WA_VISUAL;
+
+    attributes.event_mask = kEvents;
+
+    attributes.width = 1;
+    attributes.height = 1;
+    attributes.wclass = GDK_INPUT_OUTPUT;
+    attributes.visual = gtk_widget_get_visual(widget);
+    attributes.window_type = GDK_WINDOW_CHILD;
+
+#if (MOZ_WIDGET_GTK == 2)
+    attributes_mask |= GDK_WA_COLORMAP;
+    attributes.colormap = gtk_widget_get_colormap(widget);
+#endif
+
+    GdkWindow *window = gdk_window_new(parent, &attributes, attributes_mask);
+    gdk_window_set_user_data(window, widget);
+
+// GTK3 TODO?
+#if (MOZ_WIDGET_GTK == 2)
+    /* set the default pixmap to None so that you don't end up with the
+       gtk default which is BlackPixel. */
+    gdk_window_set_back_pixmap(window, nullptr, FALSE);
+#endif
+
+    return window;
+}
+
+nsresult
+nsWindow::Create(nsIWidget* aParent,
+                 nsNativeWidget aNativeParent,
+                 const LayoutDeviceIntRect& aRect,
+                 nsWidgetInitData* aInitData)
+{
+    // only set the base parent if we're going to be a dialog or a
+    // toplevel
+    nsIWidget *baseParent = aInitData &&
+        (aInitData->mWindowType == eWindowType_dialog ||
+         aInitData->mWindowType == eWindowType_toplevel ||
+         aInitData->mWindowType == eWindowType_invisible) ?
+        nullptr : aParent;
+
+#ifdef ACCESSIBILITY
+    // Send a DBus message to check whether a11y is enabled
+    a11y::PreInit();
+#endif
+
+    // Ensure that the toolkit is created.
+    nsGTKToolkit::GetToolkit();
+
+    // initialize all the common bits of this class
+    BaseCreate(baseParent, aInitData);
+
+    // Do we need to listen for resizes?
+    bool listenForResizes = false;;
+    if (aNativeParent || (aInitData && aInitData->mListenForResizes))
+        listenForResizes = true;
+
+    // and do our common creation
+    CommonCreate(aParent, listenForResizes);
+
+    // save our bounds
+    mBounds = aRect;
+    ConstrainSize(&mBounds.width, &mBounds.height);
+
+    // figure out our parent window
+    GtkWidget      *parentMozContainer = nullptr;
+    GtkContainer   *parentGtkContainer = nullptr;
+    GdkWindow      *parentGdkWindow = nullptr;
+    GtkWindow      *topLevelParent = nullptr;
+    nsWindow       *parentnsWindow = nullptr;
+    GtkWidget      *eventWidget = nullptr;
+    bool            shellHasCSD = false;
+
+    if (aParent) {
+        parentnsWindow = static_cast<nsWindow*>(aParent);
+        parentGdkWindow = parentnsWindow->mGdkWindow;
+    } else if (aNativeParent && GDK_IS_WINDOW(aNativeParent)) {
+        parentGdkWindow = GDK_WINDOW(aNativeParent);
+        parentnsWindow = get_window_for_gdk_window(parentGdkWindow);
+        if (!parentnsWindow)
+            return NS_ERROR_FAILURE;
+
+    } else if (aNativeParent && GTK_IS_CONTAINER(aNativeParent)) {
+        parentGtkContainer = GTK_CONTAINER(aNativeParent);
+    }
+
+    if (parentGdkWindow) {
+        // get the widget for the window - it should be a moz container
+        parentMozContainer = parentnsWindow->GetMozContainerWidget();
+        if (!parentMozContainer)
+            return NS_ERROR_FAILURE;
+
+        // get the toplevel window just in case someone needs to use it
+        // for setting transients or whatever.
+        topLevelParent =
+            GTK_WINDOW(gtk_widget_get_toplevel(parentMozContainer));
+    }
+
+    // ok, create our windows
+    switch (mWindowType) {
+    case eWindowType_dialog:
+    case eWindowType_popup:
+    case eWindowType_toplevel:
+    case eWindowType_invisible: {
+        mIsTopLevel = true;
+
+        // Popups that are not noautohide are only temporary. The are used
+        // for menus and the like and disappear when another window is used.
+        // For most popups, use the standard GtkWindowType GTK_WINDOW_POPUP,
+        // which will use a Window with the override-redirect attribute
+        // (for temporary windows).
+        // For long-lived windows, their stacking order is managed by the
+        // window manager, as indicated by GTK_WINDOW_TOPLEVEL ...
+        GtkWindowType type =
+            mWindowType != eWindowType_popup || aInitData->mNoAutoHide ?
+              GTK_WINDOW_TOPLEVEL : GTK_WINDOW_POPUP;
+        mShell = gtk_window_new(type);
+
+        // We only move a general managed toplevel window if someone has
+        // actually placed the window somewhere.  If no placement has taken
+        // place, we just let the window manager Do The Right Thing.
+        NativeResize();
+
+        if (mWindowType == eWindowType_dialog) {
+            SetDefaultIcon();
+            gtk_window_set_wmclass(GTK_WINDOW(mShell), "Dialog",
+                                   gdk_get_program_class());
+            gtk_window_set_type_hint(GTK_WINDOW(mShell),
+                                     GDK_WINDOW_TYPE_HINT_DIALOG);
+            gtk_window_set_transient_for(GTK_WINDOW(mShell),
+                                         topLevelParent);
+        }
+        else if (mWindowType == eWindowType_popup) {
+            // With popup windows, we want to control their position, so don't
+            // wait for the window manager to place them (which wouldn't
+            // happen with override-redirect windows anyway).
+            NativeMove();
+
+            gtk_window_set_wmclass(GTK_WINDOW(mShell), "Popup",
+                                   gdk_get_program_class());
+
+            if (aInitData->mSupportTranslucency) {
+                // We need to select an ARGB visual here instead of in
+                // SetTransparencyMode() because it has to be done before the
+                // widget is realized.  An ARGB visual is only useful if we
+                // are on a compositing window manager.
+                GdkScreen *screen = gtk_widget_get_screen(mShell);
+                if (gdk_screen_is_composited(screen)) {
+#if (MOZ_WIDGET_GTK == 2)
+                    GdkColormap *colormap =
+                        gdk_screen_get_rgba_colormap(screen);
+                    gtk_widget_set_colormap(mShell, colormap);
+#else
+                    GdkVisual *visual = gdk_screen_get_rgba_visual(screen);
+                    gtk_widget_set_visual(mShell, visual);
+#endif
+                }
+            }
+            if (aInitData->mNoAutoHide) {
+                // ... but the window manager does not decorate this window,
+                // nor provide a separate taskbar icon.
+                if (mBorderStyle == eBorderStyle_default) {
+                  gtk_window_set_decorated(GTK_WINDOW(mShell), FALSE);
+                }
+                else {
+                  bool decorate = mBorderStyle & eBorderStyle_title;
+                  gtk_window_set_decorated(GTK_WINDOW(mShell), decorate);
+                  if (decorate) {
+                    gtk_window_set_deletable(GTK_WINDOW(mShell), mBorderStyle & eBorderStyle_close);
+                  }
+                }
+                gtk_window_set_skip_taskbar_hint(GTK_WINDOW(mShell), TRUE);
+                // Element focus is managed by the parent window so the
+                // WM_HINTS input field is set to False to tell the window
+                // manager not to set input focus to this window ...
+                gtk_window_set_accept_focus(GTK_WINDOW(mShell), FALSE);
+#ifdef MOZ_X11
+                // ... but when the window manager offers focus through
+                // WM_TAKE_FOCUS, focus is requested on the parent window.
+                gtk_widget_realize(mShell);
+                gdk_window_add_filter(gtk_widget_get_window(mShell),
+                                      popup_take_focus_filter, nullptr);
+#endif
+            }
+
+            GdkWindowTypeHint gtkTypeHint;
+            if (aInitData->mIsDragPopup) {
+                gtkTypeHint = GDK_WINDOW_TYPE_HINT_DND;
+                mIsDragPopup = true;
+            }
+            else {
+                switch (aInitData->mPopupHint) {
+                    case ePopupTypeMenu:
+                        gtkTypeHint = GDK_WINDOW_TYPE_HINT_POPUP_MENU;
+                        break;
+                    case ePopupTypeTooltip:
+                        gtkTypeHint = GDK_WINDOW_TYPE_HINT_TOOLTIP;
+                        break;
+                    default:
+                        gtkTypeHint = GDK_WINDOW_TYPE_HINT_UTILITY;
+                        break;
+                }
+            }
+            gtk_window_set_type_hint(GTK_WINDOW(mShell), gtkTypeHint);
+
+            if (topLevelParent) {
+                gtk_window_set_transient_for(GTK_WINDOW(mShell),
+                                            topLevelParent);
+            }
+        }
+        else { // must be eWindowType_toplevel
+            SetDefaultIcon();
+            gtk_window_set_wmclass(GTK_WINDOW(mShell), "Toplevel",
+                                   gdk_get_program_class());
+
+            // each toplevel window gets its own window group
+            GtkWindowGroup *group = gtk_window_group_new();
+            gtk_window_group_add_window(group, GTK_WINDOW(mShell));
+            g_object_unref(group);
+        }
+
+        // Create a container to hold child windows and child GtkWidgets.
+        GtkWidget *container = moz_container_new();
+        mContainer = MOZ_CONTAINER(container);
+
+#if (MOZ_WIDGET_GTK == 3)
+        // "csd" style is set when widget is realized so we need to call
+        // it explicitly now.
+        gtk_widget_realize(mShell);
+
+        // We can't draw directly to top-level window when client side
+        // decorations are enabled. We use container with GdkWindow instead.
+        GtkStyleContext* style = gtk_widget_get_style_context(mShell);
+
+        // Always draw to mozcontainer on Wayland
+        shellHasCSD = gtk_style_context_has_class(style, "csd");
+        // We use mContainer to draw on Wayland
+        if (!mIsX11Display) {
+            shellHasCSD = true;
+        }
+#endif
+        if (!shellHasCSD) {
+            // Use mShell's window for drawing and events.
+            gtk_widget_set_has_window(container, FALSE);
+            // Prevent GtkWindow from painting a background to flicker.
+            gtk_widget_set_app_paintable(mShell, TRUE);
+        }
+
+        // Set up event widget
+        eventWidget = shellHasCSD ? container : mShell;
+        gtk_widget_add_events(eventWidget, kEvents);
+
+        gtk_container_add(GTK_CONTAINER(mShell), container);
+        gtk_widget_realize(container);
+        
+        // make sure this is the focus widget in the container
+        gtk_widget_show(container);
+        gtk_widget_grab_focus(container);
+
+        // the drawing window
+        mGdkWindow = gtk_widget_get_window(eventWidget);
+#if defined(GDK_WINDOWING_WAYLAND)
+        wl_surface *waylandSurface = moz_container_get_wl_surface(
+                                          MOZ_CONTAINER(container));
+        g_object_set_data(G_OBJECT(mGdkWindow), "WAYLAND_SURFACE",
+                          waylandSurface);
+#endif
+        if (mWindowType == eWindowType_popup) {
+            // gdk does not automatically set the cursor for "temporary"
+            // windows, which are what gtk uses for popups.
+
+            mCursor = eCursor_wait; // force SetCursor to actually set the
+                                    // cursor, even though our internal state
+                                    // indicates that we already have the
+                                    // standard cursor.
+            SetCursor(eCursor_standard);
+
+            if (aInitData->mNoAutoHide) {
+                gint wmd = ConvertBorderStyles(mBorderStyle);
+                if (wmd != -1)
+                  gdk_window_set_decorations(mGdkWindow, (GdkWMDecoration) wmd);
+            }
+
+            // If the popup ignores mouse events, set an empty input shape.
+            if (aInitData->mMouseTransparent) {
+#if (MOZ_WIDGET_GTK == 2)
+              GdkRectangle rect = { 0, 0, 0, 0 };
+              GdkRegion *region = gdk_region_rectangle(&rect);
+
+              gdk_window_input_shape_combine_region(mGdkWindow, region, 0, 0);
+              gdk_region_destroy(region);
+#else
+              cairo_rectangle_int_t rect = { 0, 0, 0, 0 };
+              cairo_region_t *region = cairo_region_create_rectangle(&rect);
+
+              gdk_window_input_shape_combine_region(mGdkWindow, region, 0, 0);
+              cairo_region_destroy(region);
+#endif
+            }
+        }
+    }
+        break;
+    case eWindowType_plugin:
+    case eWindowType_plugin_ipc_chrome:
+    case eWindowType_plugin_ipc_content:
+    case eWindowType_child: {
+        assert(0);
+        if (parentMozContainer) {
+            mGdkWindow = CreateGdkWindow(parentGdkWindow, parentMozContainer);
+            mHasMappedToplevel = parentnsWindow->mHasMappedToplevel;
+        }
+        else if (parentGtkContainer) {
+            // This MozContainer has its own window for drawing and receives
+            // events because there is no mShell widget (corresponding to this
+            // nsWindow).
+            GtkWidget *container = moz_container_new();
+            mContainer = MOZ_CONTAINER(container);
+            eventWidget = container;
+            gtk_widget_add_events(eventWidget, kEvents);
+            gtk_container_add(parentGtkContainer, container);
+            gtk_widget_realize(container);
+
+            mGdkWindow = gtk_widget_get_window(container);
+        }
+        else {
+            NS_WARNING("Warning: tried to create a new child widget with no parent!");
+            return NS_ERROR_FAILURE;
+        }
+    }
+        break;
+    default:
+        break;
+    }
+
+    // label the drawing window with this object so we can find our way home
+    g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", this);
+
+    if (mContainer)
+        g_object_set_data(G_OBJECT(mContainer), "nsWindow", this);
+
+    if (mShell)
+        g_object_set_data(G_OBJECT(mShell), "nsWindow", this);
+
+    // attach listeners for events
+    if (mShell) {
+        g_signal_connect(mShell, "configure_event",
+                         G_CALLBACK(configure_event_cb), nullptr);
+        g_signal_connect(mShell, "delete_event",
+                         G_CALLBACK(delete_event_cb), nullptr);
+        g_signal_connect(mShell, "window_state_event",
+                         G_CALLBACK(window_state_event_cb), nullptr);
+        g_signal_connect(mShell, "check-resize",
+                         G_CALLBACK(check_resize_cb), nullptr);
+
+        GtkSettings* default_settings = gtk_settings_get_default();
+        g_signal_connect_after(default_settings,
+                               "notify::gtk-theme-name",
+                               G_CALLBACK(theme_changed_cb), this);
+        g_signal_connect_after(default_settings,
+                               "notify::gtk-font-name",
+                               G_CALLBACK(theme_changed_cb), this);
+    }
+
+    if (mContainer) {
+        // Widget signals
+        g_signal_connect(mContainer, "unrealize",
+                         G_CALLBACK(container_unrealize_cb), nullptr);
+        g_signal_connect_after(mContainer, "size_allocate",
+                               G_CALLBACK(size_allocate_cb), nullptr);
+        g_signal_connect(mContainer, "hierarchy-changed",
+                         G_CALLBACK(hierarchy_changed_cb), nullptr);
+#if (MOZ_WIDGET_GTK == 3)
+        g_signal_connect(mContainer, "notify::scale-factor",
+                         G_CALLBACK(scale_changed_cb), nullptr);
+#endif
+        // Initialize mHasMappedToplevel.
+        hierarchy_changed_cb(GTK_WIDGET(mContainer), nullptr);
+        // Expose, focus, key, and drag events are sent even to GTK_NO_WINDOW
+        // widgets.
+#if (MOZ_WIDGET_GTK == 2)
+        g_signal_connect(mContainer, "expose_event",
+                         G_CALLBACK(expose_event_cb), nullptr);
+#else
+        g_signal_connect(G_OBJECT(mContainer), "draw",
+                         G_CALLBACK(expose_event_cb), nullptr);
+#endif
+        g_signal_connect(mContainer, "focus_in_event",
+                         G_CALLBACK(focus_in_event_cb), nullptr);
+        g_signal_connect(mContainer, "focus_out_event",
+                         G_CALLBACK(focus_out_event_cb), nullptr);
+        g_signal_connect(mContainer, "key_press_event",
+                         G_CALLBACK(key_press_event_cb), nullptr);
+        g_signal_connect(mContainer, "key_release_event",
+                         G_CALLBACK(key_release_event_cb), nullptr);
+
+        gtk_drag_dest_set((GtkWidget *)mContainer,
+                          (GtkDestDefaults)0,
+                          nullptr,
+                          0,
+                          (GdkDragAction)0);
+
+        g_signal_connect(mContainer, "drag_motion",
+                         G_CALLBACK(drag_motion_event_cb), nullptr);
+        g_signal_connect(mContainer, "drag_leave",
+                         G_CALLBACK(drag_leave_event_cb), nullptr);
+        g_signal_connect(mContainer, "drag_drop",
+                         G_CALLBACK(drag_drop_event_cb), nullptr);
+        g_signal_connect(mContainer, "drag_data_received",
+                         G_CALLBACK(drag_data_received_event_cb), nullptr);
+
+        GtkWidget *widgets[] = { GTK_WIDGET(mContainer),
+                                 !shellHasCSD ? mShell : nullptr };
+        for (size_t i = 0; i < ArrayLength(widgets) && widgets[i]; ++i) {
+            // Visibility events are sent to the owning widget of the relevant
+            // window but do not propagate to parent widgets so connect on
+            // mShell (if it exists) as well as mContainer.
+            g_signal_connect(widgets[i], "visibility-notify-event",
+                             G_CALLBACK(visibility_notify_event_cb), nullptr);
+            // Similarly double buffering is controlled by the window's owning
+            // widget.  Disable double buffering for painting directly to the
+            // X Window.
+            gtk_widget_set_double_buffered(widgets[i], FALSE);
+        }
+
+        // We create input contexts for all containers, except for
+        // toplevel popup windows
+        if (mWindowType != eWindowType_popup) {
+            mIMContext = new IMContextWrapper(this);
+        }
+    } else if (!mIMContext) {
+        nsWindow *container = GetContainerWindow();
+        if (container) {
+            mIMContext = container->mIMContext;
+        }
+    }
+
+    if (eventWidget) {
+#if (MOZ_WIDGET_GTK == 2)
+        // Don't let GTK mess with the shapes of our GdkWindows
+        GTK_PRIVATE_SET_FLAG(eventWidget, GTK_HAS_SHAPE_MASK);
+#endif
+
+        // These events are sent to the owning widget of the relevant window
+        // and propagate up to the first widget that handles the events, so we
+        // need only connect on mShell, if it exists, to catch events on its
+        // window and windows of mContainer.
+        g_signal_connect(eventWidget, "enter-notify-event",
+                         G_CALLBACK(enter_notify_event_cb), nullptr);
+        g_signal_connect(eventWidget, "leave-notify-event",
+                         G_CALLBACK(leave_notify_event_cb), nullptr);
+        g_signal_connect(eventWidget, "motion-notify-event",
+                         G_CALLBACK(motion_notify_event_cb), nullptr);
+        g_signal_connect(eventWidget, "button-press-event",
+                         G_CALLBACK(button_press_event_cb), nullptr);
+        g_signal_connect(eventWidget, "button-release-event",
+                         G_CALLBACK(button_release_event_cb), nullptr);
+        g_signal_connect(eventWidget, "property-notify-event",
+                         G_CALLBACK(property_notify_event_cb), nullptr);
+        g_signal_connect(eventWidget, "scroll-event",
+                         G_CALLBACK(scroll_event_cb), nullptr);
+#if GTK_CHECK_VERSION(3,4,0)
+        g_signal_connect(eventWidget, "touch-event",
+                         G_CALLBACK(touch_event_cb), nullptr);
+#endif
+    }
+
+    LOG(("nsWindow [%p]\n", (void *)this));
+    if (mShell) {
+        LOG(("\tmShell %p mContainer %p mGdkWindow %p 0x%lx\n",
+             mShell, mContainer, mGdkWindow,
+             gdk_x11_window_get_xid(mGdkWindow)));
+    } else if (mContainer) {
+        LOG(("\tmContainer %p mGdkWindow %p\n", mContainer, mGdkWindow));
+    }
+    else if (mGdkWindow) {
+        LOG(("\tmGdkWindow %p parent %p\n",
+             mGdkWindow, gdk_window_get_parent(mGdkWindow)));
+    }
+
+    // resize so that everything is set to the right dimensions
+    if (!mIsTopLevel)
+        Resize(mBounds.x, mBounds.y, mBounds.width, mBounds.height, false);
+
+#ifdef MOZ_X11
+    if (mIsX11Display && mGdkWindow) {
+      mXDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
+      mXWindow = gdk_x11_window_get_xid(mGdkWindow);
+
+      GdkVisual* gdkVisual = gdk_window_get_visual(mGdkWindow);
+      mXVisual = gdk_x11_visual_get_xvisual(gdkVisual);
+      mXDepth = gdk_visual_get_depth(gdkVisual);
+
+      mSurfaceProvider.Initialize(mXDisplay, mXWindow, mXVisual, mXDepth);
+    }
+#ifdef GDK_WINDOWING_WAYLAND
+    else {
+      mWaylandDisplay = gdk_wayland_display_get_wl_display(gdk_display_get_default());
+      mWaylandSurface = moz_container_get_wl_surface(MOZ_CONTAINER(mContainer));
+      mSurfaceProvider.Initialize(this, mWaylandDisplay, mWaylandSurface);
+    }
+#endif
+#endif
+    return NS_OK;
+}
+
+void
+nsWindow::SetWindowClass(const nsAString &xulWinType)
+{
+  if (!mShell)
+    return;
+
+  const char *res_class = gdk_get_program_class();
+  if (!res_class)
+    return;
+
+  char *res_name = ToNewCString(xulWinType);
+  if (!res_name)
+    return;
+
+  const char *role = nullptr;
+
+  // Parse res_name into a name and role. Characters other than
+  // [A-Za-z0-9_-] are converted to '_'. Anything after the first
+  // colon is assigned to role; if there's no colon, assign the
+  // whole thing to both role and res_name.
+  for (char *c = res_name; *c; c++) {
+    if (':' == *c) {
+      *c = 0;
+      role = c + 1;
+    }
+    else if (!isascii(*c) || (!isalnum(*c) && ('_' != *c) && ('-' != *c)))
+      *c = '_';
+  }
+  res_name[0] = toupper(res_name[0]);
+  if (!role) role = res_name;
+
+  gdk_window_set_role(mGdkWindow, role);
+
+#ifdef MOZ_X11
+  if (mIsX11Display) {
+      XClassHint *class_hint = XAllocClassHint();
+      if (!class_hint) {
+        free(res_name);
+        return;
+      }
+      class_hint->res_name = res_name;
+      class_hint->res_class = const_cast<char*>(res_class);
+
+      // Can't use gtk_window_set_wmclass() for this; it prints
+      // a warning & refuses to make the change.
+      GdkDisplay *display = gdk_display_get_default();
+      XSetClassHint(GDK_DISPLAY_XDISPLAY(display),
+                    gdk_x11_window_get_xid(mGdkWindow),
+                    class_hint);
+      XFree(class_hint);
+  }
+#endif /* MOZ_X11 */
+
+  free(res_name);
+}
+
+void
+nsWindow::NativeResize()
+{
+    if (!AreBoundsSane()) {
+        // If someone has set this so that the needs show flag is false
+        // and it needs to be hidden, update the flag and hide the
+        // window.  This flag will be cleared the next time someone
+        // hides the window or shows it.  It also prevents us from
+        // calling NativeShow(false) excessively on the window which
+        // causes unneeded X traffic.
+        if (!mNeedsShow && mIsShown) {
+            mNeedsShow = true;
+            NativeShow(false);
+        }
+        return;
+    }
+
+    GdkRectangle size = DevicePixelsToGdkSizeRoundUp(mBounds.Size());
+
+    LOG(("nsWindow::NativeResize [%p] %d %d\n", (void *)this,
+         size.width, size.height));
+
+    if (mIsTopLevel) {
+        gtk_window_resize(GTK_WINDOW(mShell), size.width, size.height);
+    }
+    else if (mContainer) {
+        GtkWidget *widget = GTK_WIDGET(mContainer);
+        GtkAllocation allocation, prev_allocation;
+        gtk_widget_get_allocation(widget, &prev_allocation);
+        allocation.x = prev_allocation.x;
+        allocation.y = prev_allocation.y;
+        allocation.width = size.width;
+        allocation.height = size.height;
+        gtk_widget_size_allocate(widget, &allocation);
+    }
+    else if (mGdkWindow) {
+        gdk_window_resize(mGdkWindow, size.width, size.height);
+    }
+
+#ifdef MOZ_X11
+    // Notify the X11CompositorWidget of a ClientSizeChange
+    // This is different than OnSizeAllocate to catch initial sizing
+    if (mCompositorWidgetDelegate) {
+      mCompositorWidgetDelegate->NotifyClientSizeChanged(GetClientSize());
+    }
+#endif
+
+    // Does it need to be shown because bounds were previously insane?
+    if (mNeedsShow && mIsShown) {
+        NativeShow(true);
+    }
+}
+
+void
+nsWindow::NativeMoveResize()
+{
+    if (!AreBoundsSane()) {
+        // If someone has set this so that the needs show flag is false
+        // and it needs to be hidden, update the flag and hide the
+        // window.  This flag will be cleared the next time someone
+        // hides the window or shows it.  It also prevents us from
+        // calling NativeShow(false) excessively on the window which
+        // causes unneeded X traffic.
+        if (!mNeedsShow && mIsShown) {
+            mNeedsShow = true;
+            NativeShow(false);
+        }
+        NativeMove();
+    }
+
+    GdkRectangle size = DevicePixelsToGdkSizeRoundUp(mBounds.Size());
+    GdkPoint topLeft = DevicePixelsToGdkPointRoundDown(mBounds.TopLeft());
+
+    LOG(("nsWindow::NativeMoveResize [%p] %d %d %d %d\n", (void *)this,
+         topLeft.x, topLeft.y, size.width, size.height));
+
+    if (mIsTopLevel) {
+        // x and y give the position of the window manager frame top-left.
+        gtk_window_move(GTK_WINDOW(mShell), topLeft.x, topLeft.y);
+        // This sets the client window size.
+        gtk_window_resize(GTK_WINDOW(mShell), size.width, size.height);
+    }
+    else if (mContainer) {
+        GtkAllocation allocation;
+        allocation.x = topLeft.x;
+        allocation.y = topLeft.y;
+        allocation.width = size.width;
+        allocation.height = size.height;
+        gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
+    }
+    else if (mGdkWindow) {
+        gdk_window_move_resize(mGdkWindow,
+                               topLeft.x, topLeft.y, size.width, size.height);
+    }
+
+#ifdef MOZ_X11
+    // Notify the X11CompositorWidget of a ClientSizeChange
+    // This is different than OnSizeAllocate to catch initial sizing
+    if (mCompositorWidgetDelegate) {
+      mCompositorWidgetDelegate->NotifyClientSizeChanged(GetClientSize());
+    }
+#endif
+
+    // Does it need to be shown because bounds were previously insane?
+    if (mNeedsShow && mIsShown) {
+        NativeShow(true);
+    }
+}
+
+void
+nsWindow::NativeShow(bool aAction)
+{
+    if (aAction) {
+        // unset our flag now that our window has been shown
+        mNeedsShow = false;
+
+        if (mIsTopLevel) {
+            // Set up usertime/startupID metadata for the created window.
+            if (mWindowType != eWindowType_invisible) {
+                SetUserTimeAndStartupIDForActivatedWindow(mShell);
+            }
+            gtk_widget_show(mShell);
+        }
+        else if (mContainer) {
+            gtk_widget_show(GTK_WIDGET(mContainer));
+        }
+        else if (mGdkWindow) {
+            gdk_window_show_unraised(mGdkWindow);
+        }
+    }
+    else {
+        if (mIsTopLevel) {
+            // Workaround window freezes on GTK versions before 3.21.2 by
+            // ensuring that configure events get dispatched to windows before
+            // they are unmapped. See bug 1225044.
+            if (gtk_check_version(3, 21, 2) != nullptr && mPendingConfigures > 0) {
+                GtkAllocation allocation;
+                gtk_widget_get_allocation(GTK_WIDGET(mShell), &allocation);
+
+                GdkEventConfigure event;
+                PodZero(&event);
+                event.type = GDK_CONFIGURE;
+                event.window = mGdkWindow;
+                event.send_event = TRUE;
+                event.x = allocation.x;
+                event.y = allocation.y;
+                event.width = allocation.width;
+                event.height = allocation.height;
+
+                auto shellClass = GTK_WIDGET_GET_CLASS(mShell);
+                for (unsigned int i = 0; i < mPendingConfigures; i++) {
+                    Unused << shellClass->configure_event(mShell, &event);
+                }
+                mPendingConfigures = 0;
+            }
+
+            gtk_widget_hide(mShell);
+
+            ClearTransparencyBitmap(); // Release some resources
+        }
+        else if (mContainer) {
+            gtk_widget_hide(GTK_WIDGET(mContainer));
+        }
+        else if (mGdkWindow) {
+            gdk_window_hide(mGdkWindow);
+        }
+    }
+}
+
+void
+nsWindow::SetHasMappedToplevel(bool aState)
+{
+    // Even when aState == mHasMappedToplevel (as when this method is called
+    // from Show()), child windows need to have their state checked, so don't
+    // return early.
+    bool oldState = mHasMappedToplevel;
+    mHasMappedToplevel = aState;
+
+    // mHasMappedToplevel is not updated for children of windows that are
+    // hidden; GDK knows not to send expose events for these windows.  The
+    // state is recorded on the hidden window itself, but, for child trees of
+    // hidden windows, their state essentially becomes disconnected from their
+    // hidden parent.  When the hidden parent gets shown, the child trees are
+    // reconnected, and the state of the window being shown can be easily
+    // propagated.
+    if (!mIsShown || !mGdkWindow)
+        return;
+
+    if (aState && !oldState && !mIsFullyObscured) {
+        // GDK_EXPOSE events have been ignored but the window is now visible,
+        // so make sure GDK doesn't think that the window has already been
+        // painted.
+        gdk_window_invalidate_rect(mGdkWindow, nullptr, FALSE);
+
+        // Check that a grab didn't fail due to the window not being
+        // viewable.
+        EnsureGrabs();
+    }
+
+    for (GList *children = gdk_window_peek_children(mGdkWindow);
+         children;
+         children = children->next) {
+        GdkWindow *gdkWin = GDK_WINDOW(children->data);
+        nsWindow *child = get_window_for_gdk_window(gdkWin);
+
+        if (child && child->mHasMappedToplevel != aState) {
+            child->SetHasMappedToplevel(aState);
+        }
+    }
+}
+
+LayoutDeviceIntSize
+nsWindow::GetSafeWindowSize(LayoutDeviceIntSize aSize)
+{
+    // The X protocol uses CARD32 for window sizes, but the server (1.11.3)
+    // reads it as CARD16.  Sizes of pixmaps, used for drawing, are (unsigned)
+    // CARD16 in the protocol, but the server's ProcCreatePixmap returns
+    // BadAlloc if dimensions cannot be represented by signed shorts.
+    LayoutDeviceIntSize result = aSize;
+    const int32_t kInt16Max = 32767;
+    if (result.width > kInt16Max) {
+        result.width = kInt16Max;
+    }
+    if (result.height > kInt16Max) {
+        result.height = kInt16Max;
+    }
+    return result;
+}
+
+void
+nsWindow::EnsureGrabs(void)
+{
+    if (mRetryPointerGrab)
+        GrabPointer(sRetryGrabTime);
+}
+
+void
+nsWindow::CleanLayerManagerRecursive(void) {
+    if (mLayerManager) {
+        mLayerManager->Destroy();
+        mLayerManager = nullptr;
+    }
+
+    DestroyCompositor();
+
+    GList* children = gdk_window_peek_children(mGdkWindow);
+    for (GList* list = children; list; list = list->next) {
+        nsWindow* window = get_window_for_gdk_window(GDK_WINDOW(list->data));
+        if (window) {
+            window->CleanLayerManagerRecursive();
+        }
+    }
+}
+
+void
+nsWindow::SetTransparencyMode(nsTransparencyMode aMode)
+{
+    if (!mShell) {
+        // Pass the request to the toplevel window
+        GtkWidget *topWidget = GetToplevelWidget();
+        if (!topWidget)
+            return;
+
+        nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
+        if (!topWindow)
+            return;
+
+        topWindow->SetTransparencyMode(aMode);
+        return;
+    }
+    bool isTransparent = aMode == eTransparencyTransparent;
+
+    if (mIsTransparent == isTransparent)
+        return;
+
+    if (!isTransparent) {
+        ClearTransparencyBitmap();
+    } // else the new default alpha values are "all 1", so we don't
+    // need to change anything yet
+
+    mIsTransparent = isTransparent;
+
+    // Need to clean our LayerManager up while still alive because
+    // we don't want to use layers acceleration on shaped windows
+    CleanLayerManagerRecursive();
+}
+
+nsTransparencyMode
+nsWindow::GetTransparencyMode()
+{
+    if (!mShell) {
+        // Pass the request to the toplevel window
+        GtkWidget *topWidget = GetToplevelWidget();
+        if (!topWidget) {
+            return eTransparencyOpaque;
+        }
+
+        nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
+        if (!topWindow) {
+            return eTransparencyOpaque;
+        }
+
+        return topWindow->GetTransparencyMode();
+    }
+
+    return mIsTransparent ? eTransparencyTransparent : eTransparencyOpaque;
+}
+
+nsresult
+nsWindow::ConfigureChildren(const nsTArray<Configuration>& aConfigurations)
+{
+    // If this is a remotely updated widget we receive clipping, position, and
+    // size information from a source other than our owner. Don't let our parent
+    // update this information.
+    if (mWindowType == eWindowType_plugin_ipc_chrome) {
+      return NS_OK;
+    }
+
+    for (uint32_t i = 0; i < aConfigurations.Length(); ++i) {
+        const Configuration& configuration = aConfigurations[i];
+        nsWindow* w = static_cast<nsWindow*>(configuration.mChild.get());
+        NS_ASSERTION(w->GetParent() == this,
+                     "Configured widget is not a child");
+        w->SetWindowClipRegion(configuration.mClipRegion, true);
+        if (w->mBounds.Size() != configuration.mBounds.Size()) {
+            w->Resize(configuration.mBounds.x, configuration.mBounds.y,
+                      configuration.mBounds.width, configuration.mBounds.height,
+                      true);
+        } else if (w->mBounds.TopLeft() != configuration.mBounds.TopLeft()) {
+            w->Move(configuration.mBounds.x, configuration.mBounds.y);
+        }
+        w->SetWindowClipRegion(configuration.mClipRegion, false);
+    }
+    return NS_OK;
+}
+
+nsresult
+nsWindow::SetWindowClipRegion(const nsTArray<LayoutDeviceIntRect>& aRects,
+                              bool aIntersectWithExisting)
+{
+    const nsTArray<LayoutDeviceIntRect>* newRects = &aRects;
+
+    AutoTArray<LayoutDeviceIntRect,1> intersectRects;
+    if (aIntersectWithExisting) {
+        AutoTArray<LayoutDeviceIntRect,1> existingRects;
+        GetWindowClipRegion(&existingRects);
+
+        LayoutDeviceIntRegion existingRegion = RegionFromArray(existingRects);
+        LayoutDeviceIntRegion newRegion = RegionFromArray(aRects);
+        LayoutDeviceIntRegion intersectRegion;
+        intersectRegion.And(newRegion, existingRegion);
+
+        // If mClipRects is null we haven't set a clip rect yet, so we
+        // need to set the clip even if it is equal.
+        if (mClipRects && intersectRegion.IsEqual(existingRegion)) {
+            return NS_OK;
+        }
+
+        if (!intersectRegion.IsEqual(newRegion)) {
+            ArrayFromRegion(intersectRegion, intersectRects);
+            newRects = &intersectRects;
+        }
+    }
+
+    if (IsWindowClipRegionEqual(*newRects))
+        return NS_OK;
+
+    StoreWindowClipRegion(*newRects);
+
+    if (!mGdkWindow)
+        return NS_OK;
+
+#if (MOZ_WIDGET_GTK == 2)
+    GdkRegion *region = gdk_region_new(); // aborts on OOM
+    for (uint32_t i = 0; i < newRects->Length(); ++i) {
+        const LayoutDeviceIntRect& r = newRects->ElementAt(i);
+        GdkRectangle rect = { r.x, r.y, r.width, r.height };
+        gdk_region_union_with_rect(region, &rect);
+    }
+
+    gdk_window_shape_combine_region(mGdkWindow, region, 0, 0);
+    gdk_region_destroy(region);
+#else
+    cairo_region_t *region = cairo_region_create();
+    for (uint32_t i = 0; i < newRects->Length(); ++i) {
+        const LayoutDeviceIntRect& r = newRects->ElementAt(i);
+        cairo_rectangle_int_t rect = { r.x, r.y, r.width, r.height };
+        cairo_region_union_rectangle(region, &rect);
+    }
+
+    gdk_window_shape_combine_region(mGdkWindow, region, 0, 0);
+    cairo_region_destroy(region);
+#endif
+
+    return NS_OK;
+}
+
+void
+nsWindow::ResizeTransparencyBitmap()
+{
+    if (!mTransparencyBitmap)
+        return;
+
+    if (mBounds.width == mTransparencyBitmapWidth &&
+        mBounds.height == mTransparencyBitmapHeight)
+        return;
+
+    int32_t newRowBytes = GetBitmapStride(mBounds.width);
+    int32_t newSize = newRowBytes * mBounds.height;
+    gchar* newBits = new gchar[newSize];
+    // fill new mask with "transparent", first
+    memset(newBits, 0, newSize);
+
+    // Now copy the intersection of the old and new areas into the new mask
+    int32_t copyWidth = std::min(mBounds.width, mTransparencyBitmapWidth);
+    int32_t copyHeight = std::min(mBounds.height, mTransparencyBitmapHeight);
+    int32_t oldRowBytes = GetBitmapStride(mTransparencyBitmapWidth);
+    int32_t copyBytes = GetBitmapStride(copyWidth);
+
+    int32_t i;
+    gchar* fromPtr = mTransparencyBitmap;
+    gchar* toPtr = newBits;
+    for (i = 0; i < copyHeight; i++) {
+        memcpy(toPtr, fromPtr, copyBytes);
+        fromPtr += oldRowBytes;
+        toPtr += newRowBytes;
+    }
+
+    delete[] mTransparencyBitmap;
+    mTransparencyBitmap = newBits;
+    mTransparencyBitmapWidth = mBounds.width;
+    mTransparencyBitmapHeight = mBounds.height;
+}
+
+static bool
+ChangedMaskBits(gchar* aMaskBits, int32_t aMaskWidth, int32_t aMaskHeight,
+        const nsIntRect& aRect, uint8_t* aAlphas, int32_t aStride)
+{
+    int32_t x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
+    int32_t maskBytesPerRow = GetBitmapStride(aMaskWidth);
+    for (y = aRect.y; y < yMax; y++) {
+        gchar* maskBytes = aMaskBits + y*maskBytesPerRow;
+        uint8_t* alphas = aAlphas;
+        for (x = aRect.x; x < xMax; x++) {
+            bool newBit = *alphas > 0x7f;
+            alphas++;
+
+            gchar maskByte = maskBytes[x >> 3];
+            bool maskBit = (maskByte & (1 << (x & 7))) != 0;
+
+            if (maskBit != newBit) {
+                return true;
+            }
+        }
+        aAlphas += aStride;
+    }
+
+    return false;
+}
+
+static
+void UpdateMaskBits(gchar* aMaskBits, int32_t aMaskWidth, int32_t aMaskHeight,
+        const nsIntRect& aRect, uint8_t* aAlphas, int32_t aStride)
+{
+    int32_t x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
+    int32_t maskBytesPerRow = GetBitmapStride(aMaskWidth);
+    for (y = aRect.y; y < yMax; y++) {
+        gchar* maskBytes = aMaskBits + y*maskBytesPerRow;
+        uint8_t* alphas = aAlphas;
+        for (x = aRect.x; x < xMax; x++) {
+            bool newBit = *alphas > 0x7f;
+            alphas++;
+
+            gchar mask = 1 << (x & 7);
+            gchar maskByte = maskBytes[x >> 3];
+            // Note: '-newBit' turns 0 into 00...00 and 1 into 11...11
+            maskBytes[x >> 3] = (maskByte & ~mask) | (-newBit & mask);
+        }
+        aAlphas += aStride;
+    }
+}
+
+void
+nsWindow::ApplyTransparencyBitmap()
+{
+#ifdef MOZ_X11
+    // We use X11 calls where possible, because GDK handles expose events
+    // for shaped windows in a way that's incompatible with us (Bug 635903).
+    // It doesn't occur when the shapes are set through X.
+    Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
+    Window xDrawable = GDK_WINDOW_XID(mGdkWindow);
+    Pixmap maskPixmap = XCreateBitmapFromData(xDisplay,
+                                              xDrawable,
+                                              mTransparencyBitmap,
+                                              mTransparencyBitmapWidth,
+                                              mTransparencyBitmapHeight);
+    XShapeCombineMask(xDisplay, xDrawable,
+                      ShapeBounding, 0, 0,
+                      maskPixmap, ShapeSet);
+    XFreePixmap(xDisplay, maskPixmap);
+#else
+#if (MOZ_WIDGET_GTK == 2)
+    gtk_widget_reset_shapes(mShell);
+    GdkBitmap* maskBitmap = gdk_bitmap_create_from_data(mGdkWindow,
+            mTransparencyBitmap,
+            mTransparencyBitmapWidth, mTransparencyBitmapHeight);
+    if (!maskBitmap)
+        return;
+
+    gtk_widget_shape_combine_mask(mShell, maskBitmap, 0, 0);
+    g_object_unref(maskBitmap);
+#else
+    cairo_surface_t *maskBitmap;
+    maskBitmap = cairo_image_surface_create_for_data((unsigned char*)mTransparencyBitmap,
+                                                     CAIRO_FORMAT_A1,
+                                                     mTransparencyBitmapWidth,
+                                                     mTransparencyBitmapHeight,
+                                                     GetBitmapStride(mTransparencyBitmapWidth));
+    if (!maskBitmap)
+        return;
+
+    cairo_region_t * maskRegion = gdk_cairo_region_create_from_surface(maskBitmap);
+    gtk_widget_shape_combine_region(mShell, maskRegion);
+    cairo_region_destroy(maskRegion);
+    cairo_surface_destroy(maskBitmap);
+#endif // MOZ_WIDGET_GTK == 2
+#endif // MOZ_X11
+}
+
+void
+nsWindow::ClearTransparencyBitmap()
+{
+    if (!mTransparencyBitmap)
+        return;
+
+    delete[] mTransparencyBitmap;
+    mTransparencyBitmap = nullptr;
+    mTransparencyBitmapWidth = 0;
+    mTransparencyBitmapHeight = 0;
+
+    if (!mShell)
+        return;
+
+#ifdef MOZ_X11
+    if (!mGdkWindow)
+        return;
+
+    Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
+    Window xWindow = gdk_x11_window_get_xid(mGdkWindow);
+
+    XShapeCombineMask(xDisplay, xWindow, ShapeBounding, 0, 0, X11None, ShapeSet);
+#endif
+}
+
+nsresult
+nsWindow::UpdateTranslucentWindowAlphaInternal(const nsIntRect& aRect,
+                                               uint8_t* aAlphas, int32_t aStride)
+{
+    if (!mShell) {
+        // Pass the request to the toplevel window
+        GtkWidget *topWidget = GetToplevelWidget();
+        if (!topWidget)
+            return NS_ERROR_FAILURE;
+
+        nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
+        if (!topWindow)
+            return NS_ERROR_FAILURE;
+
+        return topWindow->UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aStride);
+    }
+
+    NS_ASSERTION(mIsTransparent, "Window is not transparent");
+
+    if (mTransparencyBitmap == nullptr) {
+        int32_t size = GetBitmapStride(mBounds.width)*mBounds.height;
+        mTransparencyBitmap = new gchar[size];
+        memset(mTransparencyBitmap, 255, size);
+        mTransparencyBitmapWidth = mBounds.width;
+        mTransparencyBitmapHeight = mBounds.height;
+    } else {
+        ResizeTransparencyBitmap();
+    }
+
+    nsIntRect rect;
+    rect.IntersectRect(aRect, nsIntRect(0, 0, mBounds.width, mBounds.height));
+
+    if (!ChangedMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height,
+                         rect, aAlphas, aStride))
+        // skip the expensive stuff if the mask bits haven't changed; hopefully
+        // this is the common case
+        return NS_OK;
+
+    UpdateMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height,
+                   rect, aAlphas, aStride);
+
+    if (!mNeedsShow) {
+        ApplyTransparencyBitmap();
+    }
+    return NS_OK;
+}
+
+void
+nsWindow::GrabPointer(guint32 aTime)
+{
+    LOG(("GrabPointer time=0x%08x retry=%d\n",
+         (unsigned int)aTime, mRetryPointerGrab));
+
+    mRetryPointerGrab = false;
+    sRetryGrabTime = aTime;
+
+    // If the window isn't visible, just set the flag to retry the
+    // grab.  When this window becomes visible, the grab will be
+    // retried.
+    if (!mHasMappedToplevel || mIsFullyObscured) {
+        LOG(("GrabPointer: window not visible\n"));
+        mRetryPointerGrab = true;
+        return;
+    }
+
+    if (!mGdkWindow)
+        return;
+
+    GdkSeat *gdkSeat = gdk_display_get_default_seat(gdk_display_get_default());
+    gint retval;
+    retval = gdk_seat_grab(gdkSeat, mGdkWindow, GDK_SEAT_CAPABILITY_ALL_POINTING, TRUE,
+                           nullptr, nullptr, nullptr, nullptr);
+
+    if (retval == GDK_GRAB_NOT_VIEWABLE) {
+        LOG(("GrabPointer: window not viewable; will retry\n"));
+        mRetryPointerGrab = true;
+    } else if (retval != GDK_GRAB_SUCCESS) {
+        LOG(("GrabPointer: pointer grab failed: %i\n", retval));
+        // A failed grab indicates that another app has grabbed the pointer.
+        // Check for rollup now, because, without the grab, we likely won't
+        // get subsequent button press events. Do this with an event so that
+        // popups don't rollup while potentially adjusting the grab for
+        // this popup.
+        nsCOMPtr<nsIRunnable> event =
+            NewRunnableMethod(this, &nsWindow::CheckForRollupDuringGrab);
+        NS_DispatchToCurrentThread(event.forget());
+    }
+}
+
+void
+nsWindow::ReleaseGrabs(void)
+{
+    LOG(("ReleaseGrabs\n"));
+
+    mRetryPointerGrab = false;
+    GdkSeat *gdkSeat = gdk_display_get_default_seat(gdk_display_get_default());
+    gdk_seat_ungrab(gdkSeat);
+}
+
+GtkWidget *
+nsWindow::GetToplevelWidget()
+{
+    if (mShell) {
+        return mShell;
+    }
+
+    GtkWidget *widget = GetMozContainerWidget();
+    if (!widget)
+        return nullptr;
+
+    return gtk_widget_get_toplevel(widget);
+}
+
+GtkWidget *
+nsWindow::GetMozContainerWidget()
+{
+    if (!mGdkWindow)
+        return nullptr;
+
+    if (mContainer)
+        return GTK_WIDGET(mContainer);
+
+    GtkWidget *owningWidget =
+        get_gtk_widget_for_gdk_window(mGdkWindow);
+    return owningWidget;
+}
+
+nsWindow *
+nsWindow::GetContainerWindow()
+{
+    GtkWidget *owningWidget = GetMozContainerWidget();
+    if (!owningWidget)
+        return nullptr;
+
+    nsWindow *window = get_window_for_gtk_widget(owningWidget);
+    NS_ASSERTION(window, "No nsWindow for container widget");
+    return window;
+}
+
+void
+nsWindow::SetUrgencyHint(GtkWidget *top_window, bool state)
+{
+    if (!top_window)
+        return;
+
+    gdk_window_set_urgency_hint(gtk_widget_get_window(top_window), state);
+}
+
+void *
+nsWindow::SetupPluginPort(void)
+{
+    if (!mGdkWindow)
+        return nullptr;
+
+    if (gdk_window_is_destroyed(mGdkWindow) == TRUE)
+        return nullptr;
+
+    Window window = gdk_x11_window_get_xid(mGdkWindow);
+
+    // we have to flush the X queue here so that any plugins that
+    // might be running on separate X connections will be able to use
+    // this window in case it was just created
+#ifdef MOZ_X11
+    XWindowAttributes xattrs;
+    Display *display = GDK_DISPLAY_XDISPLAY(gdk_display_get_default());
+    XGetWindowAttributes(display, window, &xattrs);
+    XSelectInput (display, window,
+                  xattrs.your_event_mask |
+                  SubstructureNotifyMask);
+
+    gdk_window_add_filter(mGdkWindow, plugin_window_filter_func, this);
+
+    XSync(display, False);
+#endif /* MOZ_X11 */
+
+    return (void *)window;
+}
+
+void
+nsWindow::SetDefaultIcon(void)
+{
+    SetIcon(NS_LITERAL_STRING("default"));
+}
+
+void
+nsWindow::SetPluginType(PluginType aPluginType)
+{
+    mPluginType = aPluginType;
+}
+
+#ifdef MOZ_X11
+void
+nsWindow::SetNonXEmbedPluginFocus()
+{
+    if (gPluginFocusWindow == this || mPluginType!=PluginType_NONXEMBED) {
+        return;
+    }
+
+    if (gPluginFocusWindow) {
+        RefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
+        gPluginFocusWindow->LoseNonXEmbedPluginFocus();
+    }
+
+    LOGFOCUS(("nsWindow::SetNonXEmbedPluginFocus\n"));
+
+    Window curFocusWindow;
+    int focusState;
+
+    GdkDisplay *gdkDisplay = gdk_window_get_display(mGdkWindow);
+    XGetInputFocus(gdk_x11_display_get_xdisplay(gdkDisplay),
+                   &curFocusWindow,
+                   &focusState);
+
+    LOGFOCUS(("\t curFocusWindow=%p\n", curFocusWindow));
+
+    GdkWindow* toplevel = gdk_window_get_toplevel(mGdkWindow);
+#if (MOZ_WIDGET_GTK == 2)
+    GdkWindow *gdkfocuswin = gdk_window_lookup(curFocusWindow);
+#else
+    GdkWindow *gdkfocuswin = gdk_x11_window_lookup_for_display(gdkDisplay,
+                                                               curFocusWindow);
+#endif
+
+    // lookup with the focus proxy window is supposed to get the
+    // same GdkWindow as toplevel. If the current focused window
+    // is not the focus proxy, we return without any change.
+    if (gdkfocuswin != toplevel) {
+        return;
+    }
+
+    // switch the focus from the focus proxy to the plugin window
+    mOldFocusWindow = curFocusWindow;
+    XRaiseWindow(GDK_WINDOW_XDISPLAY(mGdkWindow),
+                 gdk_x11_window_get_xid(mGdkWindow));
+    gdk_error_trap_push();
+    XSetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
+                   gdk_x11_window_get_xid(mGdkWindow),
+                   RevertToNone,
+                   CurrentTime);
+    gdk_flush();
+#if (MOZ_WIDGET_GTK == 3)
+    gdk_error_trap_pop_ignored();
+#else
+    gdk_error_trap_pop();
+#endif
+    gPluginFocusWindow = this;
+    gdk_window_add_filter(nullptr, plugin_client_message_filter, this);
+
+    LOGFOCUS(("nsWindow::SetNonXEmbedPluginFocus oldfocus=%p new=%p\n",
+              mOldFocusWindow, gdk_x11_window_get_xid(mGdkWindow)));
+}
+
+void
+nsWindow::LoseNonXEmbedPluginFocus()
+{
+    LOGFOCUS(("nsWindow::LoseNonXEmbedPluginFocus\n"));
+
+    // This method is only for the nsWindow which contains a
+    // Non-XEmbed plugin, for example, JAVA plugin.
+    if (gPluginFocusWindow != this || mPluginType!=PluginType_NONXEMBED) {
+        return;
+    }
+
+    Window curFocusWindow;
+    int focusState;
+
+    XGetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
+                   &curFocusWindow,
+                   &focusState);
+
+    // we only switch focus between plugin window and focus proxy. If the
+    // current focused window is not the plugin window, just removing the
+    // event filter that blocks the WM_TAKE_FOCUS is enough. WM and gtk2
+    // will take care of the focus later.
+    if (!curFocusWindow ||
+        curFocusWindow == gdk_x11_window_get_xid(mGdkWindow)) {
+
+        gdk_error_trap_push();
+        XRaiseWindow(GDK_WINDOW_XDISPLAY(mGdkWindow),
+                     mOldFocusWindow);
+        XSetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
+                       mOldFocusWindow,
+                       RevertToParent,
+                       CurrentTime);
+        gdk_flush();
+#if (MOZ_WIDGET_GTK == 3)
+        gdk_error_trap_pop_ignored();
+#else
+        gdk_error_trap_pop();
+#endif
+    }
+    gPluginFocusWindow = nullptr;
+    mOldFocusWindow = 0;
+    gdk_window_remove_filter(nullptr, plugin_client_message_filter, this);
+
+    LOGFOCUS(("nsWindow::LoseNonXEmbedPluginFocus end\n"));
+}
+#endif /* MOZ_X11 */
+
+gint
+nsWindow::ConvertBorderStyles(nsBorderStyle aStyle)
+{
+    gint w = 0;
+
+    if (aStyle == eBorderStyle_default)
+        return -1;
+
+    // note that we don't handle eBorderStyle_close yet
+    if (aStyle & eBorderStyle_all)
+        w |= GDK_DECOR_ALL;
+    if (aStyle & eBorderStyle_border)
+        w |= GDK_DECOR_BORDER;
+    if (aStyle & eBorderStyle_resizeh)
+        w |= GDK_DECOR_RESIZEH;
+    if (aStyle & eBorderStyle_title)
+        w |= GDK_DECOR_TITLE;
+    if (aStyle & eBorderStyle_menu)
+        w |= GDK_DECOR_MENU;
+    if (aStyle & eBorderStyle_minimize)
+        w |= GDK_DECOR_MINIMIZE;
+    if (aStyle & eBorderStyle_maximize)
+        w |= GDK_DECOR_MAXIMIZE;
+
+    return w;
+}
+
+class FullscreenTransitionWindow final : public nsISupports
+{
+public:
+    NS_DECL_ISUPPORTS
+
+    explicit FullscreenTransitionWindow(GtkWidget* aWidget);
+
+    GtkWidget* mWindow;
+
+private:
+    ~FullscreenTransitionWindow();
+};
+
+NS_IMPL_ISUPPORTS0(FullscreenTransitionWindow)
+
+FullscreenTransitionWindow::FullscreenTransitionWindow(GtkWidget* aWidget)
+{
+    mWindow = gtk_window_new(GTK_WINDOW_POPUP);
+    GtkWindow* gtkWin = GTK_WINDOW(mWindow);
+
+    gtk_window_set_type_hint(gtkWin, GDK_WINDOW_TYPE_HINT_SPLASHSCREEN);
+    gtk_window_set_transient_for(gtkWin, GTK_WINDOW(aWidget));
+    gtk_window_set_decorated(gtkWin, false);
+
+    GdkWindow* gdkWin = gtk_widget_get_window(aWidget);
+    GdkScreen* screen = gtk_widget_get_screen(aWidget);
+    gint monitorNum = gdk_screen_get_monitor_at_window(screen, gdkWin);
+    GdkRectangle monitorRect;
+    gdk_screen_get_monitor_geometry(screen, monitorNum, &monitorRect);
+    gtk_window_set_screen(gtkWin, screen);
+    gtk_window_move(gtkWin, monitorRect.x, monitorRect.y);
+    gtk_window_resize(gtkWin, monitorRect.width, monitorRect.height);
+
+    GdkColor bgColor;
+    bgColor.red = bgColor.green = bgColor.blue = 0;
+    gtk_widget_modify_bg(mWindow, GTK_STATE_NORMAL, &bgColor);
+
+    gtk_window_set_opacity(gtkWin, 0.0);
+    gtk_widget_show(mWindow);
+}
+
+FullscreenTransitionWindow::~FullscreenTransitionWindow()
+{
+    gtk_widget_destroy(mWindow);
+}
+
+class FullscreenTransitionData
+{
+public:
+    FullscreenTransitionData(nsIWidget::FullscreenTransitionStage aStage,
+                             uint16_t aDuration, nsIRunnable* aCallback,
+                             FullscreenTransitionWindow* aWindow)
+        : mStage(aStage)
+        , mStartTime(TimeStamp::Now())
+        , mDuration(TimeDuration::FromMilliseconds(aDuration))
+        , mCallback(aCallback)
+        , mWindow(aWindow) { }
+
+    static const guint sInterval = 1000 / 30; // 30fps
+    static gboolean TimeoutCallback(gpointer aData);
+
+private:
+    nsIWidget::FullscreenTransitionStage mStage;
+    TimeStamp mStartTime;
+    TimeDuration mDuration;
+    nsCOMPtr<nsIRunnable> mCallback;
+    RefPtr<FullscreenTransitionWindow> mWindow;
+};
+
+/* static */ gboolean
+FullscreenTransitionData::TimeoutCallback(gpointer aData)
+{
+    bool finishing = false;
+    auto data = static_cast<FullscreenTransitionData*>(aData);
+    gdouble opacity = (TimeStamp::Now() - data->mStartTime) / data->mDuration;
+    if (opacity >= 1.0) {
+        opacity = 1.0;
+        finishing = true;
+    }
+    if (data->mStage == nsIWidget::eAfterFullscreenToggle) {
+        opacity = 1.0 - opacity;
+    }
+    gtk_window_set_opacity(GTK_WINDOW(data->mWindow->mWindow), opacity);
+
+    if (!finishing) {
+        return TRUE;
+    }
+    NS_DispatchToMainThread(data->mCallback.forget());
+    delete data;
+    return FALSE;
+}
+
+/* virtual */ bool
+nsWindow::PrepareForFullscreenTransition(nsISupports** aData)
+{
+    GdkScreen* screen = gtk_widget_get_screen(mShell);
+    if (!gdk_screen_is_composited(screen)) {
+        return false;
+    }
+    *aData = do_AddRef(new FullscreenTransitionWindow(mShell)).take();
+    return true;
+}
+
+/* virtual */ void
+nsWindow::PerformFullscreenTransition(FullscreenTransitionStage aStage,
+                                      uint16_t aDuration, nsISupports* aData,
+                                      nsIRunnable* aCallback)
+{
+    auto data = static_cast<FullscreenTransitionWindow*>(aData);
+    // This will be released at the end of the last timeout callback for it.
+    auto transitionData = new FullscreenTransitionData(aStage, aDuration,
+                                                       aCallback, data);
+    g_timeout_add_full(G_PRIORITY_HIGH,
+                       FullscreenTransitionData::sInterval,
+                       FullscreenTransitionData::TimeoutCallback,
+                       transitionData, nullptr);
+}
+
+static bool
+IsFullscreenSupported(GtkWidget* aShell)
+{
+#ifdef MOZ_X11
+    GdkScreen* screen = gtk_widget_get_screen(aShell);
+    GdkAtom atom = gdk_atom_intern("_NET_WM_STATE_FULLSCREEN", FALSE);
+    if (!gdk_x11_screen_supports_net_wm_hint(screen, atom)) {
+        return false;
+    }
+#endif
+    return true;
+}
+
+nsresult
+nsWindow::MakeFullScreen(bool aFullScreen, nsIScreen* aTargetScreen)
+{
+    LOG(("nsWindow::MakeFullScreen [%p] aFullScreen %d\n",
+         (void *)this, aFullScreen));
+
+    if (!IsFullscreenSupported(mShell)) {
+        return NS_ERROR_NOT_AVAILABLE;
+    }
+
+    if (aFullScreen) {
+        if (mSizeMode != nsSizeMode_Fullscreen)
+            mLastSizeMode = mSizeMode;
+
+        mSizeMode = nsSizeMode_Fullscreen;
+        gtk_window_fullscreen(GTK_WINDOW(mShell));
+    }
+    else {
+        mSizeMode = mLastSizeMode;
+        gtk_window_unfullscreen(GTK_WINDOW(mShell));
+    }
+
+    NS_ASSERTION(mLastSizeMode != nsSizeMode_Fullscreen,
+                 "mLastSizeMode should never be fullscreen");
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::HideWindowChrome(bool aShouldHide)
+{
+    if (!mShell) {
+        // Pass the request to the toplevel window
+        GtkWidget *topWidget = GetToplevelWidget();
+        if (!topWidget)
+            return NS_ERROR_FAILURE;
+
+        nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
+        if (!topWindow)
+            return NS_ERROR_FAILURE;
+
+        return topWindow->HideWindowChrome(aShouldHide);
+    }
+
+    // Sawfish, metacity, and presumably other window managers get
+    // confused if we change the window decorations while the window
+    // is visible.
+    bool wasVisible = false;
+    if (gdk_window_is_visible(mGdkWindow)) {
+        gdk_window_hide(mGdkWindow);
+        wasVisible = true;
+    }
+
+    gint wmd;
+    if (aShouldHide)
+        wmd = 0;
+    else
+        wmd = ConvertBorderStyles(mBorderStyle);
+
+    if (wmd != -1)
+      gdk_window_set_decorations(mGdkWindow, (GdkWMDecoration) wmd);
+
+    if (wasVisible)
+        gdk_window_show(mGdkWindow);
+
+    // For some window managers, adding or removing window decorations
+    // requires unmapping and remapping our toplevel window.  Go ahead
+    // and flush the queue here so that we don't end up with a BadWindow
+    // error later when this happens (when the persistence timer fires
+    // and GetWindowPos is called)
+#ifdef MOZ_X11
+    XSync(GDK_DISPLAY_XDISPLAY(gdk_display_get_default()) , False);
+#else
+    gdk_flush ();
+#endif /* MOZ_X11 */
+
+    return NS_OK;
+}
+
+bool
+nsWindow::CheckForRollup(gdouble aMouseX, gdouble aMouseY,
+                         bool aIsWheel, bool aAlwaysRollup)
+{
+    nsIRollupListener* rollupListener = GetActiveRollupListener();
+    nsCOMPtr<nsIWidget> rollupWidget;
+    if (rollupListener) {
+        rollupWidget = rollupListener->GetRollupWidget();
+    }
+    if (!rollupWidget) {
+        nsBaseWidget::gRollupListener = nullptr;
+        return false;
+    }
+
+    bool retVal = false;
+    GdkWindow *currentPopup =
+        (GdkWindow *)rollupWidget->GetNativeData(NS_NATIVE_WINDOW);
+    if (aAlwaysRollup || !is_mouse_in_window(currentPopup, aMouseX, aMouseY)) {
+        bool rollup = true;
+        if (aIsWheel) {
+            rollup = rollupListener->ShouldRollupOnMouseWheelEvent();
+            retVal = rollupListener->ShouldConsumeOnMouseWheelEvent();
+        }
+        // if we're dealing with menus, we probably have submenus and
+        // we don't want to rollup if the click is in a parent menu of
+        // the current submenu
+        uint32_t popupsToRollup = UINT32_MAX;
+        if (!aAlwaysRollup) {
+            AutoTArray<nsIWidget*, 5> widgetChain;
+            uint32_t sameTypeCount = rollupListener->GetSubmenuWidgetChain(&widgetChain);
+            for (uint32_t i=0; i<widgetChain.Length(); ++i) {
+                nsIWidget* widget = widgetChain[i];
+                GdkWindow* currWindow =
+                    (GdkWindow*) widget->GetNativeData(NS_NATIVE_WINDOW);
+                if (is_mouse_in_window(currWindow, aMouseX, aMouseY)) {
+                  // don't roll up if the mouse event occurred within a
+                  // menu of the same type. If the mouse event occurred
+                  // in a menu higher than that, roll up, but pass the
+                  // number of popups to Rollup so that only those of the
+                  // same type close up.
+                  if (i < sameTypeCount) {
+                    rollup = false;
+                  }
+                  else {
+                    popupsToRollup = sameTypeCount;
+                  }
+                  break;
+                }
+            } // foreach parent menu widget
+        } // if rollup listener knows about menus
+
+        // if we've determined that we should still rollup, do it.
+        bool usePoint = !aIsWheel && !aAlwaysRollup;
+        IntPoint point = IntPoint::Truncate(aMouseX, aMouseY);
+        if (rollup && rollupListener->Rollup(popupsToRollup, true, usePoint ? &point : nullptr, nullptr)) {
+            retVal = true;
+        }
+    }
+    return retVal;
+}
+
+/* static */
+bool
+nsWindow::DragInProgress(void)
+{
+    nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
+
+    if (!dragService)
+        return false;
+
+    nsCOMPtr<nsIDragSession> currentDragSession;
+    dragService->GetCurrentSession(getter_AddRefs(currentDragSession));
+
+    return currentDragSession != nullptr;
+}
+
+static bool
+is_mouse_in_window (GdkWindow* aWindow, gdouble aMouseX, gdouble aMouseY)
+{
+    gint x = 0;
+    gint y = 0;
+    gint w, h;
+
+    gint offsetX = 0;
+    gint offsetY = 0;
+
+    GdkWindow *window = aWindow;
+
+    while (window) {
+        gint tmpX = 0;
+        gint tmpY = 0;
+
+        gdk_window_get_position(window, &tmpX, &tmpY);
+        GtkWidget *widget = get_gtk_widget_for_gdk_window(window);
+
+        // if this is a window, compute x and y given its origin and our
+        // offset
+        if (GTK_IS_WINDOW(widget)) {
+            x = tmpX + offsetX;
+            y = tmpY + offsetY;
+            break;
+        }
+
+        offsetX += tmpX;
+        offsetY += tmpY;
+        window = gdk_window_get_parent(window);
+    }
+
+#if (MOZ_WIDGET_GTK == 2)
+    gdk_drawable_get_size(aWindow, &w, &h);
+#else
+    w = gdk_window_get_width(aWindow);
+    h = gdk_window_get_height(aWindow);
+#endif
+
+    if (aMouseX > x && aMouseX < x + w &&
+        aMouseY > y && aMouseY < y + h)
+        return true;
+
+    return false;
+}
+
+static nsWindow *
+get_window_for_gtk_widget(GtkWidget *widget)
+{
+    gpointer user_data = g_object_get_data(G_OBJECT(widget), "nsWindow");
+
+    return static_cast<nsWindow *>(user_data);
+}
+
+static nsWindow *
+get_window_for_gdk_window(GdkWindow *window)
+{
+    gpointer user_data = g_object_get_data(G_OBJECT(window), "nsWindow");
+
+    return static_cast<nsWindow *>(user_data);
+}
+
+static GtkWidget *
+get_gtk_widget_for_gdk_window(GdkWindow *window)
+{
+    gpointer user_data = nullptr;
+    gdk_window_get_user_data(window, &user_data);
+
+    return GTK_WIDGET(user_data);
+}
+
+static GdkCursor *
+get_gtk_cursor(nsCursor aCursor)
+{
+    GdkCursor *gdkcursor = nullptr;
+    uint8_t newType = 0xff;
+
+    if ((gdkcursor = gCursorCache[aCursor])) {
+        return gdkcursor;
+    }
+
+    GdkDisplay *defaultDisplay = gdk_display_get_default();
+
+    // The strategy here is to use standard GDK cursors, and, if not available,
+    // load by standard name with gdk_cursor_new_from_name.
+    // Spec is here: http://www.freedesktop.org/wiki/Specifications/cursor-spec/
+    switch (aCursor) {
+    case eCursor_standard:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_LEFT_PTR);
+        break;
+    case eCursor_wait:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_WATCH);
+        break;
+    case eCursor_select:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_XTERM);
+        break;
+    case eCursor_hyperlink:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_HAND2);
+        break;
+    case eCursor_n_resize:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_TOP_SIDE);
+        break;
+    case eCursor_s_resize:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_BOTTOM_SIDE);
+        break;
+    case eCursor_w_resize:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_LEFT_SIDE);
+        break;
+    case eCursor_e_resize:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_RIGHT_SIDE);
+        break;
+    case eCursor_nw_resize:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay,
+                                               GDK_TOP_LEFT_CORNER);
+        break;
+    case eCursor_se_resize:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay,
+                                               GDK_BOTTOM_RIGHT_CORNER);
+        break;
+    case eCursor_ne_resize:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay,
+                                               GDK_TOP_RIGHT_CORNER);
+        break;
+    case eCursor_sw_resize:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay,
+                                               GDK_BOTTOM_LEFT_CORNER);
+        break;
+    case eCursor_crosshair:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_CROSSHAIR);
+        break;
+    case eCursor_move:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_FLEUR);
+        break;
+    case eCursor_help:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay,
+                                               GDK_QUESTION_ARROW);
+        break;
+    case eCursor_copy: // CSS3
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "copy");
+        if (!gdkcursor)
+            newType = MOZ_CURSOR_COPY;
+        break;
+    case eCursor_alias:
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "alias");
+        if (!gdkcursor)
+            newType = MOZ_CURSOR_ALIAS;
+        break;
+    case eCursor_context_menu:
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "context-menu");
+        if (!gdkcursor)
+            newType = MOZ_CURSOR_CONTEXT_MENU;
+        break;
+    case eCursor_cell:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_PLUS);
+        break;
+    // Those two arent standardized. Trying both KDEs and GNOMEs names
+    case eCursor_grab:
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "openhand");
+        if (!gdkcursor)
+            newType = MOZ_CURSOR_HAND_GRAB;
+        break;
+    case eCursor_grabbing:
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "closedhand");
+        if (!gdkcursor)
+            gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "grabbing");
+        if (!gdkcursor)
+            newType = MOZ_CURSOR_HAND_GRABBING;
+        break;
+    case eCursor_spinning:
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "progress");
+        if (!gdkcursor)
+            newType = MOZ_CURSOR_SPINNING;
+        break;
+    case eCursor_zoom_in:
+        newType = MOZ_CURSOR_ZOOM_IN;
+        break;
+    case eCursor_zoom_out:
+        newType = MOZ_CURSOR_ZOOM_OUT;
+        break;
+    case eCursor_not_allowed:
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "not-allowed");
+        if (!gdkcursor) // nonstandard, yet common
+            gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "crossed_circle");
+        if (!gdkcursor)
+            newType = MOZ_CURSOR_NOT_ALLOWED;
+        break;
+    case eCursor_no_drop:
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "no-drop");
+        if (!gdkcursor) // this nonstandard sequence makes it work on KDE and GNOME
+            gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "forbidden");
+        if (!gdkcursor)
+            gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "circle");
+        if (!gdkcursor)
+            newType = MOZ_CURSOR_NOT_ALLOWED;
+        break;
+    case eCursor_vertical_text:
+        newType = MOZ_CURSOR_VERTICAL_TEXT;
+        break;
+    case eCursor_all_scroll:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_FLEUR);
+        break;
+    case eCursor_nesw_resize:
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "size_bdiag");
+        if (!gdkcursor)
+            newType = MOZ_CURSOR_NESW_RESIZE;
+        break;
+    case eCursor_nwse_resize:
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "size_fdiag");
+        if (!gdkcursor)
+            newType = MOZ_CURSOR_NWSE_RESIZE;
+        break;
+    case eCursor_ns_resize:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay,
+                                               GDK_SB_V_DOUBLE_ARROW);
+        break;
+    case eCursor_ew_resize:
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay,
+                                               GDK_SB_H_DOUBLE_ARROW);
+        break;
+    // Here, two better fitting cursors exist in some cursor themes. Try those first
+    case eCursor_row_resize:
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "split_v");
+        if (!gdkcursor)
+            gdkcursor = gdk_cursor_new_for_display(defaultDisplay,
+                                                   GDK_SB_V_DOUBLE_ARROW);
+        break;
+    case eCursor_col_resize:
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "split_h");
+        if (!gdkcursor)
+            gdkcursor = gdk_cursor_new_for_display(defaultDisplay,
+                                                   GDK_SB_H_DOUBLE_ARROW);
+        break;
+    case eCursor_none:
+        newType = MOZ_CURSOR_NONE;
+        break;
+    default:
+        NS_ASSERTION(aCursor, "Invalid cursor type");
+        gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_LEFT_PTR);
+        break;
+    }
+
+    // If by now we don't have a xcursor, this means we have to make a custom
+    // one. First, we try creating a named cursor based on the hash of our
+    // custom bitmap, as libXcursor has some magic to convert bitmapped cursors
+    // to themed cursors
+    if (newType != 0xFF && GtkCursors[newType].hash) {
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, GtkCursors[newType].hash);
+    }
+
+    // If we still don't have a xcursor, we now really create a bitmap cursor
+    if (newType != 0xff && !gdkcursor) {
+        GdkPixbuf * cursor_pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8, 32, 32);
+        if (!cursor_pixbuf)
+            return nullptr;
+
+        guchar *data = gdk_pixbuf_get_pixels(cursor_pixbuf);
+
+        // Read data from GtkCursors and compose RGBA surface from 1bit bitmap and mask
+        // GtkCursors bits and mask are 32x32 monochrome bitmaps (1 bit for each pixel)
+        // so it's 128 byte array (4 bytes for are one bitmap row and there are 32 rows here).
+        const unsigned char *bits = GtkCursors[newType].bits;
+        const unsigned char *mask_bits = GtkCursors[newType].mask_bits;
+
+        for (int i = 0; i < 128; i++) {
+            char bit = *bits++;
+            char mask = *mask_bits++;
+            for (int j = 0; j < 8; j++) {
+                unsigned char pix = ~(((bit >> j) & 0x01) * 0xff);
+                *data++ = pix;
+                *data++ = pix;
+                *data++ = pix;
+                *data++ = (((mask >> j) & 0x01) * 0xff);
+            }
+        }
+
+        gdkcursor = gdk_cursor_new_from_pixbuf(gdk_display_get_default(), cursor_pixbuf,
+                                               GtkCursors[newType].hot_x,
+                                               GtkCursors[newType].hot_y);
+
+        g_object_unref(cursor_pixbuf);
+    }
+
+    gCursorCache[aCursor] = gdkcursor;
+
+    return gdkcursor;
+}
+
+// gtk callbacks
+
+#if (MOZ_WIDGET_GTK == 2)
+static gboolean
+expose_event_cb(GtkWidget *widget, GdkEventExpose *event)
+{
+    RefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
+    if (!window)
+        return FALSE;
+
+    window->OnExposeEvent(event);
+    return FALSE;
+}
+#else
+void
+draw_window_of_widget(GtkWidget *widget, GdkWindow *aWindow, cairo_t *cr)
+{
+    if (gtk_cairo_should_draw_window(cr, aWindow)) {
+        RefPtr<nsWindow> window = get_window_for_gdk_window(aWindow);
+        if (!window) {
+            NS_WARNING("Cannot get nsWindow from GtkWidget");
+        }
+        else {
+            cairo_save(cr);
+            gtk_cairo_transform_to_window(cr, widget, aWindow);
+            // TODO - window->OnExposeEvent() can destroy this or other windows,
+            // do we need to handle it somehow?
+            window->OnExposeEvent(cr);
+            cairo_restore(cr);
+        }
+    }
+
+    GList *children = gdk_window_get_children(aWindow);
+    GList *child = children;
+    while (child) {
+        GdkWindow *window = GDK_WINDOW(child->data);
+        gpointer windowWidget;
+        gdk_window_get_user_data(window, &windowWidget);
+        if (windowWidget == widget) {
+            draw_window_of_widget(widget, window, cr);
+        }
+        child = g_list_next(child);
+    }
+    g_list_free(children);
+}
+
+/* static */
+gboolean
+expose_event_cb(GtkWidget *widget, cairo_t *cr)
+{
+    draw_window_of_widget(widget, gtk_widget_get_window(widget), cr);
+
+    // A strong reference is already held during "draw" signal emission,
+    // but GTK+ 3.4 wants the object to live a little longer than that
+    // (bug 1225970).
+    g_object_ref(widget);
+    g_idle_add(
+        [](gpointer data) -> gboolean {
+            g_object_unref(data);
+            return G_SOURCE_REMOVE;
+        },
+        widget);
+
+    return FALSE;
+}
+#endif //MOZ_WIDGET_GTK == 2
+
+static gboolean
+configure_event_cb(GtkWidget *widget,
+                   GdkEventConfigure *event)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+    if (!window)
+        return FALSE;
+
+    return window->OnConfigureEvent(widget, event);
+}
+
+static void
+container_unrealize_cb (GtkWidget *widget)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+    if (!window)
+        return;
+
+    window->OnContainerUnrealize();
+}
+
+static void
+size_allocate_cb (GtkWidget *widget, GtkAllocation *allocation)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+    if (!window)
+        return;
+
+    window->OnSizeAllocate(allocation);
+}
+
+static gboolean
+delete_event_cb(GtkWidget *widget, GdkEventAny *event)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+    if (!window)
+        return FALSE;
+
+    window->OnDeleteEvent();
+
+    return TRUE;
+}
+
+static gboolean
+enter_notify_event_cb(GtkWidget *widget,
+                      GdkEventCrossing *event)
+{
+    RefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
+    if (!window)
+        return TRUE;
+
+    window->OnEnterNotifyEvent(event);
+
+    return TRUE;
+}
+
+static gboolean
+leave_notify_event_cb(GtkWidget *widget,
+                      GdkEventCrossing *event)
+{
+    if (is_parent_grab_leave(event)) {
+        return TRUE;
+    }
+
+    // bug 369599: Suppress LeaveNotify events caused by pointer grabs to
+    // avoid generating spurious mouse exit events.
+    gint x = gint(event->x_root);
+    gint y = gint(event->y_root);
+    GdkDisplay* display = gtk_widget_get_display(widget);
+    GdkWindow* winAtPt = gdk_display_get_window_at_pointer(display, &x, &y);
+    if (winAtPt == event->window) {
+        return TRUE;
+    }
+
+    RefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
+    if (!window)
+        return TRUE;
+
+    window->OnLeaveNotifyEvent(event);
+
+    return TRUE;
+}
+
+static nsWindow*
+GetFirstNSWindowForGDKWindow(GdkWindow *aGdkWindow)
+{
+    nsWindow* window;
+    while (!(window = get_window_for_gdk_window(aGdkWindow))) {
+        // The event has bubbled to the moz_container widget as passed into each caller's *widget parameter,
+        // but its corresponding nsWindow is an ancestor of the window that we need.  Instead, look at
+        // event->window and find the first ancestor nsWindow of it because event->window may be in a plugin.
+        aGdkWindow = gdk_window_get_parent(aGdkWindow);
+        if (!aGdkWindow) {
+            window = nullptr;
+            break;
+        }
+    }
+    return window;
+}
+
+static gboolean
+motion_notify_event_cb(GtkWidget *widget, GdkEventMotion *event)
+{
+    UpdateLastInputEventTime(event);
+
+    nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
+    if (!window)
+        return FALSE;
+
+    window->OnMotionNotifyEvent(event);
+
+    return TRUE;
+}
+
+static gboolean
+button_press_event_cb(GtkWidget *widget, GdkEventButton *event)
+{
+    UpdateLastInputEventTime(event);
+
+    nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
+    if (!window)
+        return FALSE;
+
+    window->OnButtonPressEvent(event);
+
+    return TRUE;
+}
+
+static gboolean
+button_release_event_cb(GtkWidget *widget, GdkEventButton *event)
+{
+    UpdateLastInputEventTime(event);
+
+    nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
+    if (!window)
+        return FALSE;
+
+    window->OnButtonReleaseEvent(event);
+
+    return TRUE;
+}
+
+static gboolean
+focus_in_event_cb(GtkWidget *widget, GdkEventFocus *event)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+    if (!window)
+        return FALSE;
+
+    window->OnContainerFocusInEvent(event);
+
+    return FALSE;
+}
+
+static gboolean
+focus_out_event_cb(GtkWidget *widget, GdkEventFocus *event)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+    if (!window)
+        return FALSE;
+
+    window->OnContainerFocusOutEvent(event);
+
+    return FALSE;
+}
+
+#ifdef MOZ_X11
+// For long-lived popup windows that don't really take focus themselves but
+// may have elements that accept keyboard input when the parent window is
+// active, focus is handled specially.  These windows include noautohide
+// panels.  (This special handling is not necessary for temporary popups where
+// the keyboard is grabbed.)
+//
+// Mousing over or clicking on these windows should not cause them to steal
+// focus from their parent windows, so, the input field of WM_HINTS is set to
+// False to request that the window manager not set the input focus to this
+// window.  http://tronche.com/gui/x/icccm/sec-4.html#s-4.1.7
+//
+// However, these windows can still receive WM_TAKE_FOCUS messages from the
+// window manager, so they can still detect when the user has indicated that
+// they wish to direct keyboard input at these windows.  When the window
+// manager offers focus to these windows (after a mouse over or click, for
+// example), a request to make the parent window active is issued.  When the
+// parent window becomes active, keyboard events will be received.
+
+static GdkFilterReturn
+popup_take_focus_filter(GdkXEvent *gdk_xevent,
+                        GdkEvent *event,
+                        gpointer data)
+{
+    XEvent* xevent = static_cast<XEvent*>(gdk_xevent);
+    if (xevent->type != ClientMessage)
+        return GDK_FILTER_CONTINUE;
+
+    XClientMessageEvent& xclient = xevent->xclient;
+    if (xclient.message_type != gdk_x11_get_xatom_by_name("WM_PROTOCOLS"))
+        return GDK_FILTER_CONTINUE;
+
+    Atom atom = xclient.data.l[0];
+    if (atom != gdk_x11_get_xatom_by_name("WM_TAKE_FOCUS"))
+        return GDK_FILTER_CONTINUE;
+
+    guint32 timestamp = xclient.data.l[1];
+
+    GtkWidget* widget = get_gtk_widget_for_gdk_window(event->any.window);
+    if (!widget)
+        return GDK_FILTER_CONTINUE;
+
+    GtkWindow* parent = gtk_window_get_transient_for(GTK_WINDOW(widget));
+    if (!parent)
+        return GDK_FILTER_CONTINUE;
+
+    if (gtk_window_is_active(parent))
+        return GDK_FILTER_REMOVE; // leave input focus on the parent
+
+    GdkWindow* parent_window = gtk_widget_get_window(GTK_WIDGET(parent));
+    if (!parent_window)
+        return GDK_FILTER_CONTINUE;
+
+    // In case the parent has not been deconified.
+    gdk_window_show_unraised(parent_window);
+
+    // Request focus on the parent window.
+    // Use gdk_window_focus rather than gtk_window_present to avoid
+    // raising the parent window.
+    gdk_window_focus(parent_window, timestamp);
+    return GDK_FILTER_REMOVE;
+}
+
+static GdkFilterReturn
+plugin_window_filter_func(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
+{
+    GdkWindow  *plugin_window;
+    XEvent     *xevent;
+    Window      xeventWindow;
+
+    RefPtr<nsWindow> nswindow = (nsWindow*)data;
+    GdkFilterReturn return_val;
+
+    xevent = (XEvent *)gdk_xevent;
+    return_val = GDK_FILTER_CONTINUE;
+
+    switch (xevent->type)
+    {
+        case CreateNotify:
+        case ReparentNotify:
+            if (xevent->type==CreateNotify) {
+                xeventWindow = xevent->xcreatewindow.window;
+            }
+            else {
+                if (xevent->xreparent.event != xevent->xreparent.parent)
+                    break;
+                xeventWindow = xevent->xreparent.window;
+            }
+#if (MOZ_WIDGET_GTK == 2)
+            plugin_window = gdk_window_lookup(xeventWindow);
+#else
+            plugin_window = gdk_x11_window_lookup_for_display(
+                                  gdk_x11_lookup_xdisplay(xevent->xcreatewindow.display), xeventWindow);
+#endif
+            if (plugin_window) {
+                GtkWidget *widget =
+                    get_gtk_widget_for_gdk_window(plugin_window);
+
+// TODO GTK3
+#if (MOZ_WIDGET_GTK == 2)
+                if (GTK_IS_XTBIN(widget)) {
+                    nswindow->SetPluginType(nsWindow::PluginType_NONXEMBED);
+                    break;
+                }
+                else
+#endif
+                if(GTK_IS_SOCKET(widget)) {
+                    if (!g_object_get_data(G_OBJECT(widget), "enable-xt-focus")) {
+                        nswindow->SetPluginType(nsWindow::PluginType_XEMBED);
+                        break;
+                    }
+                }
+            }
+            nswindow->SetPluginType(nsWindow::PluginType_NONXEMBED);
+            return_val = GDK_FILTER_REMOVE;
+            break;
+        case EnterNotify:
+            nswindow->SetNonXEmbedPluginFocus();
+            break;
+        case DestroyNotify:
+            gdk_window_remove_filter
+                ((GdkWindow*)(nswindow->GetNativeData(NS_NATIVE_WINDOW)),
+                 plugin_window_filter_func,
+                 nswindow);
+            // Currently we consider all plugins are non-xembed and calls
+            // LoseNonXEmbedPluginFocus without any checking.
+            nswindow->LoseNonXEmbedPluginFocus();
+            break;
+        default:
+            break;
+    }
+    return return_val;
+}
+
+static GdkFilterReturn
+plugin_client_message_filter(GdkXEvent *gdk_xevent,
+                             GdkEvent *event,
+                             gpointer data)
+{
+    XEvent    *xevent;
+    xevent = (XEvent *)gdk_xevent;
+
+    GdkFilterReturn return_val;
+    return_val = GDK_FILTER_CONTINUE;
+
+    if (!gPluginFocusWindow || xevent->type!=ClientMessage) {
+        return return_val;
+    }
+
+    // When WM sends out WM_TAKE_FOCUS, gtk2 will use XSetInputFocus
+    // to set the focus to the focus proxy. To prevent this happen
+    // while the focus is on the plugin, we filter the WM_TAKE_FOCUS
+    // out.
+    if (gdk_x11_get_xatom_by_name("WM_PROTOCOLS")
+            != xevent->xclient.message_type) {
+        return return_val;
+    }
+
+    if ((Atom) xevent->xclient.data.l[0] ==
+            gdk_x11_get_xatom_by_name("WM_TAKE_FOCUS")) {
+        // block it from gtk2.0 focus proxy
+        return_val = GDK_FILTER_REMOVE;
+    }
+
+    return return_val;
+}
+#endif /* MOZ_X11 */
+
+static gboolean
+key_press_event_cb(GtkWidget *widget, GdkEventKey *event)
+{
+    LOG(("key_press_event_cb\n"));
+
+    UpdateLastInputEventTime(event);
+
+    // find the window with focus and dispatch this event to that widget
+    nsWindow *window = get_window_for_gtk_widget(widget);
+    if (!window)
+        return FALSE;
+
+    RefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
+
+#ifdef MOZ_X11
+    // Keyboard repeat can cause key press events to queue up when there are
+    // slow event handlers (bug 301029).  Throttle these events by removing
+    // consecutive pending duplicate KeyPress events to the same window.
+    // We use the event time of the last one.
+    // Note: GDK calls XkbSetDetectableAutorepeat so that KeyRelease events
+    // are generated only when the key is physically released.
+#define NS_GDKEVENT_MATCH_MASK 0x1FFF /* GDK_SHIFT_MASK .. GDK_BUTTON5_MASK */
+    GdkDisplay* gdkDisplay = gtk_widget_get_display(widget);
+    if (GDK_IS_X11_DISPLAY(gdkDisplay)) {
+        Display* dpy = GDK_DISPLAY_XDISPLAY(gdkDisplay);
+        while (XPending(dpy)) {
+            XEvent next_event;
+            XPeekEvent(dpy, &next_event);
+            GdkWindow* nextGdkWindow =
+                gdk_x11_window_lookup_for_display(gdkDisplay, next_event.xany.window);
+            if (nextGdkWindow != event->window ||
+                next_event.type != KeyPress ||
+                next_event.xkey.keycode != event->hardware_keycode ||
+                next_event.xkey.state != (event->state & NS_GDKEVENT_MATCH_MASK)) {
+                break;
+            }
+            XNextEvent(dpy, &next_event);
+            event->time = next_event.xkey.time;
+        }
+    }
+#endif
+
+    return focusWindow->OnKeyPressEvent(event);
+}
+
+static gboolean
+key_release_event_cb(GtkWidget *widget, GdkEventKey *event)
+{
+    LOG(("key_release_event_cb\n"));
+
+    UpdateLastInputEventTime(event);
+
+    // find the window with focus and dispatch this event to that widget
+    nsWindow *window = get_window_for_gtk_widget(widget);
+    if (!window)
+        return FALSE;
+
+    RefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
+
+    return focusWindow->OnKeyReleaseEvent(event);
+}
+
+static gboolean
+property_notify_event_cb(GtkWidget* aWidget, GdkEventProperty* aEvent)
+{
+    RefPtr<nsWindow> window = get_window_for_gdk_window(aEvent->window);
+    if (!window)
+        return FALSE;
+
+    return window->OnPropertyNotifyEvent(aWidget, aEvent);
+}
+
+static gboolean
+scroll_event_cb(GtkWidget *widget, GdkEventScroll *event)
+{
+    nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
+    if (!window)
+        return FALSE;
+
+    window->OnScrollEvent(event);
+
+    return TRUE;
+}
+
+static gboolean
+visibility_notify_event_cb (GtkWidget *widget, GdkEventVisibility *event)
+{
+    RefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
+    if (!window)
+        return FALSE;
+
+    window->OnVisibilityNotifyEvent(event);
+
+    return TRUE;
+}
+
+static void
+hierarchy_changed_cb (GtkWidget *widget,
+                      GtkWidget *previous_toplevel)
+{
+    GtkWidget *toplevel = gtk_widget_get_toplevel(widget);
+    GdkWindowState old_window_state = GDK_WINDOW_STATE_WITHDRAWN;
+    GdkEventWindowState event;
+
+    event.new_window_state = GDK_WINDOW_STATE_WITHDRAWN;
+
+    if (GTK_IS_WINDOW(previous_toplevel)) {
+        g_signal_handlers_disconnect_by_func(previous_toplevel,
+                                             FuncToGpointer(window_state_event_cb),
+                                             widget);
+        GdkWindow *win = gtk_widget_get_window(previous_toplevel);
+        if (win) {
+            old_window_state = gdk_window_get_state(win);
+        }
+    }
+
+    if (GTK_IS_WINDOW(toplevel)) {
+        g_signal_connect_swapped(toplevel, "window-state-event",
+                                 G_CALLBACK(window_state_event_cb), widget);
+        GdkWindow *win = gtk_widget_get_window(toplevel);
+        if (win) {
+            event.new_window_state = gdk_window_get_state(win);
+        }
+    }
+
+    event.changed_mask = static_cast<GdkWindowState>
+        (old_window_state ^ event.new_window_state);
+
+    if (event.changed_mask) {
+        event.type = GDK_WINDOW_STATE;
+        event.window = nullptr;
+        event.send_event = TRUE;
+        window_state_event_cb(widget, &event);
+    }
+}
+
+static gboolean
+window_state_event_cb (GtkWidget *widget, GdkEventWindowState *event)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+    if (!window)
+        return FALSE;
+
+    window->OnWindowStateEvent(widget, event);
+
+    return FALSE;
+}
+
+static void
+theme_changed_cb (GtkSettings *settings, GParamSpec *pspec, nsWindow *data)
+{
+    RefPtr<nsWindow> window = data;
+    window->ThemeChanged();
+}
+
+static void
+check_resize_cb (GtkContainer* container, gpointer user_data)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(GTK_WIDGET(container));
+    if (!window) {
+      return;
+    }
+    window->OnCheckResize();
+}
+
+#if (MOZ_WIDGET_GTK == 3)
+static void
+scale_changed_cb (GtkWidget* widget, GParamSpec* aPSpec, gpointer aPointer)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+    if (!window) {
+      return;
+    }
+    window->OnDPIChanged();
+
+    // configure_event is already fired before scale-factor signal,
+    // but size-allocate isn't fired by changing scale
+    GtkAllocation allocation;
+    gtk_widget_get_allocation(widget, &allocation);
+    window->OnSizeAllocate(&allocation);
+}
+#endif
+
+#if GTK_CHECK_VERSION(3,4,0)
+static gboolean
+touch_event_cb(GtkWidget* aWidget, GdkEventTouch* aEvent)
+{
+    UpdateLastInputEventTime(aEvent);
+
+    nsWindow* window = GetFirstNSWindowForGDKWindow(aEvent->window);
+    if (!window) {
+        return FALSE;
+    }
+
+    return window->OnTouchEvent(aEvent);
+}
+#endif
+
+//////////////////////////////////////////////////////////////////////
+// These are all of our drag and drop operations
+
+void
+nsWindow::InitDragEvent(WidgetDragEvent &aEvent)
+{
+    // set the keyboard modifiers
+    guint modifierState = KeymapWrapper::GetCurrentModifierState();
+    KeymapWrapper::InitInputEvent(aEvent, modifierState);
+}
+
+static gboolean
+drag_motion_event_cb(GtkWidget *aWidget,
+                     GdkDragContext *aDragContext,
+                     gint aX,
+                     gint aY,
+                     guint aTime,
+                     gpointer aData)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+    if (!window)
+        return FALSE;
+
+    // figure out which internal widget this drag motion actually happened on
+    nscoord retx = 0;
+    nscoord rety = 0;
+
+    GdkWindow *innerWindow =
+        get_inner_gdk_window(gtk_widget_get_window(aWidget), aX, aY,
+                             &retx, &rety);
+    RefPtr<nsWindow> innerMostWindow = get_window_for_gdk_window(innerWindow);
+
+    if (!innerMostWindow) {
+        innerMostWindow = window;
+    }
+
+    LOGDRAG(("nsWindow drag-motion signal for %p\n", (void*)innerMostWindow));
+
+    LayoutDeviceIntPoint point = window->GdkPointToDevicePixels({ retx, rety });
+
+    return nsDragService::GetInstance()->
+        ScheduleMotionEvent(innerMostWindow, aDragContext,
+                            point, aTime);
+}
+
+static void
+drag_leave_event_cb(GtkWidget *aWidget,
+                    GdkDragContext *aDragContext,
+                    guint aTime,
+                    gpointer aData)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+    if (!window)
+        return;
+
+    nsDragService *dragService = nsDragService::GetInstance();
+
+    nsWindow *mostRecentDragWindow = dragService->GetMostRecentDestWindow();
+    if (!mostRecentDragWindow) {
+        // This can happen when the target will not accept a drop.  A GTK drag
+        // source sends the leave message to the destination before the
+        // drag-failed signal on the source widget, but the leave message goes
+        // via the X server, and so doesn't get processed at least until the
+        // event loop runs again.
+        return;
+    }
+
+    GtkWidget *mozContainer = mostRecentDragWindow->GetMozContainerWidget();
+    if (aWidget != mozContainer)
+    {
+        // When the drag moves between widgets, GTK can send leave signal for
+        // the old widget after the motion or drop signal for the new widget.
+        // We'll send the leave event when the motion or drop event is run.
+        return;
+    }
+
+    LOGDRAG(("nsWindow drag-leave signal for %p\n",
+             (void*)mostRecentDragWindow));
+
+    dragService->ScheduleLeaveEvent();
+}
+
+
+static gboolean
+drag_drop_event_cb(GtkWidget *aWidget,
+                   GdkDragContext *aDragContext,
+                   gint aX,
+                   gint aY,
+                   guint aTime,
+                   gpointer aData)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+    if (!window)
+        return FALSE;
+
+    // figure out which internal widget this drag motion actually happened on
+    nscoord retx = 0;
+    nscoord rety = 0;
+
+    GdkWindow *innerWindow =
+        get_inner_gdk_window(gtk_widget_get_window(aWidget), aX, aY,
+                             &retx, &rety);
+    RefPtr<nsWindow> innerMostWindow = get_window_for_gdk_window(innerWindow);
+
+    if (!innerMostWindow) {
+        innerMostWindow = window;
+    }
+
+    LOGDRAG(("nsWindow drag-drop signal for %p\n", (void*)innerMostWindow));
+
+    LayoutDeviceIntPoint point = window->GdkPointToDevicePixels({ retx, rety });
+
+    return nsDragService::GetInstance()->
+        ScheduleDropEvent(innerMostWindow, aDragContext,
+                          point, aTime);
+}
+
+static void
+drag_data_received_event_cb(GtkWidget *aWidget,
+                            GdkDragContext *aDragContext,
+                            gint aX,
+                            gint aY,
+                            GtkSelectionData  *aSelectionData,
+                            guint aInfo,
+                            guint aTime,
+                            gpointer aData)
+{
+    RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+    if (!window)
+        return;
+
+    window->OnDragDataReceivedEvent(aWidget,
+                                    aDragContext,
+                                    aX, aY,
+                                    aSelectionData,
+                                    aInfo, aTime, aData);
+}
+
+static nsresult
+initialize_prefs(void)
+{
+    gRaiseWindows =
+        Preferences::GetBool("mozilla.widget.raise-on-setfocus", true);
+
+    return NS_OK;
+}
+
+static GdkWindow *
+get_inner_gdk_window (GdkWindow *aWindow,
+                      gint x, gint y,
+                      gint *retx, gint *rety)
+{
+    gint cx, cy, cw, ch;
+    GList *children = gdk_window_peek_children(aWindow);
+    for (GList *child = g_list_last(children);
+         child;
+         child = g_list_previous(child)) {
+        GdkWindow *childWindow = (GdkWindow *) child->data;
+        if (get_window_for_gdk_window(childWindow)) {
+#if (MOZ_WIDGET_GTK == 2)
+            gdk_window_get_geometry(childWindow, &cx, &cy, &cw, &ch, nullptr);
+#else
+            gdk_window_get_geometry(childWindow, &cx, &cy, &cw, &ch);
+#endif
+            if ((cx < x) && (x < (cx + cw)) &&
+                (cy < y) && (y < (cy + ch)) &&
+                gdk_window_is_visible(childWindow)) {
+                return get_inner_gdk_window(childWindow,
+                                            x - cx, y - cy,
+                                            retx, rety);
+            }
+        }
+    }
+    *retx = x;
+    *rety = y;
+    return aWindow;
+}
+
+static inline bool
+is_context_menu_key(const WidgetKeyboardEvent& aKeyEvent)
+{
+    return ((aKeyEvent.mKeyCode == NS_VK_F10 && aKeyEvent.IsShift() &&
+             !aKeyEvent.IsControl() && !aKeyEvent.IsMeta() &&
+             !aKeyEvent.IsAlt()) ||
+            (aKeyEvent.mKeyCode == NS_VK_CONTEXT_MENU && !aKeyEvent.IsShift() &&
+             !aKeyEvent.IsControl() && !aKeyEvent.IsMeta() &&
+             !aKeyEvent.IsAlt()));
+}
+
+static int
+is_parent_ungrab_enter(GdkEventCrossing *aEvent)
+{
+    return (GDK_CROSSING_UNGRAB == aEvent->mode) &&
+        ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
+         (GDK_NOTIFY_VIRTUAL == aEvent->detail));
+
+}
+
+static int
+is_parent_grab_leave(GdkEventCrossing *aEvent)
+{
+    return (GDK_CROSSING_GRAB == aEvent->mode) &&
+        ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
+            (GDK_NOTIFY_VIRTUAL == aEvent->detail));
+}
+
+#ifdef ACCESSIBILITY
+void
+nsWindow::CreateRootAccessible()
+{
+    if (mIsTopLevel && !mRootAccessible) {
+        LOG(("nsWindow:: Create Toplevel Accessibility\n"));
+        mRootAccessible = GetRootAccessible();
+    }
+}
+
+void
+nsWindow::DispatchEventToRootAccessible(uint32_t aEventType)
+{
+    if (!a11y::ShouldA11yBeEnabled()) {
+        return;
+    }
+
+    nsAccessibilityService* accService = GetOrCreateAccService();
+    if (!accService) {
+        return;
+    }
+
+    // Get the root document accessible and fire event to it.
+    a11y::Accessible* acc = GetRootAccessible();
+    if (acc) {
+        accService->FireAccessibleEvent(aEventType, acc);
+    }
+}
+
+void
+nsWindow::DispatchActivateEventAccessible(void)
+{
+    DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_ACTIVATE);
+}
+
+void
+nsWindow::DispatchDeactivateEventAccessible(void)
+{
+    DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_DEACTIVATE);
+}
+
+void
+nsWindow::DispatchMaximizeEventAccessible(void)
+{
+    DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_MAXIMIZE);
+}
+
+void
+nsWindow::DispatchMinimizeEventAccessible(void)
+{
+    DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_MINIMIZE);
+}
+
+void
+nsWindow::DispatchRestoreEventAccessible(void)
+{
+    DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_RESTORE);
+}
+
+#endif /* #ifdef ACCESSIBILITY */
+
+// nsChildWindow class
+
+nsChildWindow::nsChildWindow()
+{
+}
+
+nsChildWindow::~nsChildWindow()
+{
+}
+
+NS_IMETHODIMP_(void)
+nsWindow::SetInputContext(const InputContext& aContext,
+                          const InputContextAction& aAction)
+{
+    if (!mIMContext) {
+        return;
+    }
+    mIMContext->SetInputContext(this, &aContext, &aAction);
+}
+
+NS_IMETHODIMP_(InputContext)
+nsWindow::GetInputContext()
+{
+  InputContext context;
+  if (!mIMContext) {
+      context.mIMEState.mEnabled = IMEState::DISABLED;
+      context.mIMEState.mOpen = IMEState::OPEN_STATE_NOT_SUPPORTED;
+  } else {
+      context = mIMContext->GetInputContext();
+  }
+  return context;
+}
+
+nsIMEUpdatePreference
+nsWindow::GetIMEUpdatePreference()
+{
+    if (!mIMContext) {
+        return nsIMEUpdatePreference();
+    }
+    return mIMContext->GetIMEUpdatePreference();
+}
+
+NS_IMETHODIMP_(TextEventDispatcherListener*)
+nsWindow::GetNativeTextEventDispatcherListener()
+{
+    if (NS_WARN_IF(!mIMContext)) {
+        return nullptr;
+    }
+    return mIMContext;
+}
+
+bool
+nsWindow::ExecuteNativeKeyBindingRemapped(NativeKeyBindingsType aType,
+                                          const WidgetKeyboardEvent& aEvent,
+                                          DoCommandCallback aCallback,
+                                          void* aCallbackData,
+                                          uint32_t aGeckoKeyCode,
+                                          uint32_t aNativeKeyCode)
+{
+    WidgetKeyboardEvent modifiedEvent(aEvent);
+    modifiedEvent.mKeyCode = aGeckoKeyCode;
+    static_cast<GdkEventKey*>(modifiedEvent.mNativeKeyEvent)->keyval =
+        aNativeKeyCode;
+
+    NativeKeyBindings* keyBindings = NativeKeyBindings::GetInstance(aType);
+    return keyBindings->Execute(modifiedEvent, aCallback, aCallbackData);
+}
+
+NS_IMETHODIMP_(bool)
+nsWindow::ExecuteNativeKeyBinding(NativeKeyBindingsType aType,
+                                  const WidgetKeyboardEvent& aEvent,
+                                  DoCommandCallback aCallback,
+                                  void* aCallbackData)
+{
+    if (aEvent.mKeyCode >= NS_VK_LEFT && aEvent.mKeyCode <= NS_VK_DOWN) {
+
+        // Check if we're targeting content with vertical writing mode,
+        // and if so remap the arrow keys.
+        WidgetQueryContentEvent query(true, eQuerySelectedText, this);
+        nsEventStatus status;
+        DispatchEvent(&query, status);
+
+        if (query.mSucceeded && query.mReply.mWritingMode.IsVertical()) {
+            uint32_t geckoCode = 0;
+            uint32_t gdkCode = 0;
+            switch (aEvent.mKeyCode) {
+            case NS_VK_LEFT:
+                if (query.mReply.mWritingMode.IsVerticalLR()) {
+                    geckoCode = NS_VK_UP;
+                    gdkCode = GDK_Up;
+                } else {
+                    geckoCode = NS_VK_DOWN;
+                    gdkCode = GDK_Down;
+                }
+                break;
+
+            case NS_VK_RIGHT:
+                if (query.mReply.mWritingMode.IsVerticalLR()) {
+                    geckoCode = NS_VK_DOWN;
+                    gdkCode = GDK_Down;
+                } else {
+                    geckoCode = NS_VK_UP;
+                    gdkCode = GDK_Up;
+                }
+                break;
+
+            case NS_VK_UP:
+                geckoCode = NS_VK_LEFT;
+                gdkCode = GDK_Left;
+                break;
+
+            case NS_VK_DOWN:
+                geckoCode = NS_VK_RIGHT;
+                gdkCode = GDK_Right;
+                break;
+            }
+
+            return ExecuteNativeKeyBindingRemapped(aType, aEvent, aCallback,
+                                                   aCallbackData,
+                                                   geckoCode, gdkCode);
+        }
+    }
+
+    NativeKeyBindings* keyBindings = NativeKeyBindings::GetInstance(aType);
+    return keyBindings->Execute(aEvent, aCallback, aCallbackData);
+}
+
+#if defined(MOZ_X11) && (MOZ_WIDGET_GTK == 2)
+/* static */ already_AddRefed<DrawTarget>
+nsWindow::GetDrawTargetForGdkDrawable(GdkDrawable* aDrawable,
+                                      const IntSize& aSize)
+{
+    GdkVisual* visual = gdk_drawable_get_visual(aDrawable);
+    Screen* xScreen =
+        gdk_x11_screen_get_xscreen(gdk_drawable_get_screen(aDrawable));
+    Display* xDisplay = DisplayOfScreen(xScreen);
+    Drawable xDrawable = gdk_x11_drawable_get_xid(aDrawable);
+
+    RefPtr<gfxASurface> surface;
+
+    if (visual) {
+        Visual* xVisual = gdk_x11_visual_get_xvisual(visual);
+
+        surface = new gfxXlibSurface(xDisplay, xDrawable, xVisual, aSize);
+    } else {
+        // no visual? we must be using an xrender format.  Find a format
+        // for this depth.
+        XRenderPictFormat *pf = nullptr;
+        switch (gdk_drawable_get_depth(aDrawable)) {
+            case 32:
+                pf = XRenderFindStandardFormat(xDisplay, PictStandardARGB32);
+                break;
+            case 24:
+                pf = XRenderFindStandardFormat(xDisplay, PictStandardRGB24);
+                break;
+            default:
+                NS_ERROR("Don't know how to handle the given depth!");
+                break;
+        }
+
+        surface = new gfxXlibSurface(xScreen, xDrawable, pf, aSize);
+    }
+
+    RefPtr<DrawTarget> dt =
+        gfxPlatform::GetPlatform()->CreateDrawTargetForSurface(surface, aSize);
+
+    if (!dt || !dt->IsValid()) {
+        return nullptr;
+    }
+
+    return dt.forget();
+}
+#endif
+
+already_AddRefed<DrawTarget>
+nsWindow::StartRemoteDrawingInRegion(LayoutDeviceIntRegion& aInvalidRegion, BufferMode* aBufferMode)
+{
+  return mSurfaceProvider.StartRemoteDrawingInRegion(aInvalidRegion, aBufferMode);
+}
+
+void
+nsWindow::EndRemoteDrawingInRegion(DrawTarget* aDrawTarget,
+                                   LayoutDeviceIntRegion& aInvalidRegion)
+{
+  mSurfaceProvider.EndRemoteDrawingInRegion(aDrawTarget, aInvalidRegion);
+}
+
+// Code shared begin BeginMoveDrag and BeginResizeDrag
+bool
+nsWindow::GetDragInfo(WidgetMouseEvent* aMouseEvent,
+                      GdkWindow** aWindow, gint* aButton,
+                      gint* aRootX, gint* aRootY)
+{
+    if (aMouseEvent->button != WidgetMouseEvent::eLeftButton) {
+        // we can only begin a move drag with the left mouse button
+        return false;
+    }
+    *aButton = 1;
+
+    // get the gdk window for this widget
+    GdkWindow* gdk_window = mGdkWindow;
+    if (!gdk_window) {
+        return false;
+    }
+#ifdef DEBUG
+    // GDK_IS_WINDOW(...) expands to a statement-expression, and
+    // statement-expressions are not allowed in template-argument lists. So we
+    // have to make the MOZ_ASSERT condition indirect.
+    if (!GDK_IS_WINDOW(gdk_window)) {
+        MOZ_ASSERT(false, "must really be window");
+    }
+#endif
+
+    // find the top-level window
+    gdk_window = gdk_window_get_toplevel(gdk_window);
+    MOZ_ASSERT(gdk_window,
+               "gdk_window_get_toplevel should not return null");
+    *aWindow = gdk_window;
+
+    if (!aMouseEvent->mWidget) {
+        return false;
+    }
+
+    // FIXME: It would be nice to have the widget position at the time
+    // of the event, but it's relatively unlikely that the widget has
+    // moved since the mousedown.  (On the other hand, it's quite likely
+    // that the mouse has moved, which is why we use the mouse position
+    // from the event.)
+    LayoutDeviceIntPoint offset = aMouseEvent->mWidget->WidgetToScreenOffset();
+    *aRootX = aMouseEvent->mRefPoint.x + offset.x;
+    *aRootY = aMouseEvent->mRefPoint.y + offset.y;
+
+    return true;
+}
+
+NS_IMETHODIMP
+nsWindow::BeginMoveDrag(WidgetMouseEvent* aEvent)
+{
+    MOZ_ASSERT(aEvent, "must have event");
+    MOZ_ASSERT(aEvent->mClass == eMouseEventClass,
+               "event must have correct struct type");
+
+    GdkWindow *gdk_window;
+    gint button, screenX, screenY;
+    if (!GetDragInfo(aEvent, &gdk_window, &button, &screenX, &screenY)) {
+        return NS_ERROR_FAILURE;
+    }
+
+    // tell the window manager to start the move
+    screenX = DevicePixelsToGdkCoordRoundDown(screenX);
+    screenY = DevicePixelsToGdkCoordRoundDown(screenY);
+    gdk_window_begin_move_drag(gdk_window, button, screenX, screenY,
+                               aEvent->mTime);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindow::BeginResizeDrag(WidgetGUIEvent* aEvent,
+                          int32_t aHorizontal,
+                          int32_t aVertical)
+{
+    NS_ENSURE_ARG_POINTER(aEvent);
+
+    if (aEvent->mClass != eMouseEventClass) {
+        // you can only begin a resize drag with a mouse event
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    GdkWindow *gdk_window;
+    gint button, screenX, screenY;
+    if (!GetDragInfo(aEvent->AsMouseEvent(), &gdk_window, &button,
+                     &screenX, &screenY)) {
+        return NS_ERROR_FAILURE;
+    }
+
+    // work out what GdkWindowEdge we're talking about
+    GdkWindowEdge window_edge;
+    if (aVertical < 0) {
+        if (aHorizontal < 0) {
+            window_edge = GDK_WINDOW_EDGE_NORTH_WEST;
+        } else if (aHorizontal == 0) {
+            window_edge = GDK_WINDOW_EDGE_NORTH;
+        } else {            window_edge = GDK_WINDOW_EDGE_NORTH_EAST;
+        }
+    } else if (aVertical == 0) {
+        if (aHorizontal < 0) {
+            window_edge = GDK_WINDOW_EDGE_WEST;
+        } else if (aHorizontal == 0) {
+            return NS_ERROR_INVALID_ARG;
+        } else {
+            window_edge = GDK_WINDOW_EDGE_EAST;
+        }
+    } else {
+        if (aHorizontal < 0) {
+            window_edge = GDK_WINDOW_EDGE_SOUTH_WEST;
+        } else if (aHorizontal == 0) {
+            window_edge = GDK_WINDOW_EDGE_SOUTH;
+        } else {
+            window_edge = GDK_WINDOW_EDGE_SOUTH_EAST;
+        }
+    }
+
+    // tell the window manager to start the resize
+    gdk_window_begin_resize_drag(gdk_window, window_edge, button,
+                                 screenX, screenY, aEvent->mTime);
+
+    return NS_OK;
+}
+
+nsIWidget::LayerManager*
+nsWindow::GetLayerManager(PLayerTransactionChild* aShadowManager,
+                          LayersBackend aBackendHint,
+                          LayerManagerPersistence aPersistence)
+{
+    if (mIsDestroyed) {
+      // Prevent external code from triggering the re-creation of the LayerManager/Compositor
+      // during shutdown. Just return what we currently have, which is most likely null.
+      return mLayerManager;
+    }
+    if (!mLayerManager && eTransparencyTransparent == GetTransparencyMode()) {
+        mLayerManager = CreateBasicLayerManager();
+    }
+
+    return nsBaseWidget::GetLayerManager(aShadowManager, aBackendHint, aPersistence);
+}
+
+void
+nsWindow::ClearCachedResources()
+{
+    if (mLayerManager &&
+        mLayerManager->GetBackendType() == mozilla::layers::LayersBackend::LAYERS_BASIC) {
+        mLayerManager->ClearCachedResources();
+    }
+
+    GList* children = gdk_window_peek_children(mGdkWindow);
+    for (GList* list = children; list; list = list->next) {
+        nsWindow* window = get_window_for_gdk_window(GDK_WINDOW(list->data));
+        if (window) {
+            window->ClearCachedResources();
+        }
+    }
+}
+
+gint
+nsWindow::GdkScaleFactor()
+{
+#if (MOZ_WIDGET_GTK >= 3)
+    // Available as of GTK 3.10+
+    static auto sGdkWindowGetScaleFactorPtr = (gint (*)(GdkWindow*))
+        dlsym(RTLD_DEFAULT, "gdk_window_get_scale_factor");
+    if (sGdkWindowGetScaleFactorPtr && mGdkWindow)
+        return (*sGdkWindowGetScaleFactorPtr)(mGdkWindow);
+#endif
+    return nsScreenGtk::GetGtkMonitorScaleFactor();
+}
+
+
+gint
+nsWindow::DevicePixelsToGdkCoordRoundUp(int pixels) {
+    gint scale = GdkScaleFactor();
+    return (pixels + scale - 1) / scale;
+}
+
+gint
+nsWindow::DevicePixelsToGdkCoordRoundDown(int pixels) {
+    gint scale = GdkScaleFactor();
+    return pixels / scale;
+}
+
+GdkPoint
+nsWindow::DevicePixelsToGdkPointRoundDown(LayoutDeviceIntPoint point) {
+    gint scale = GdkScaleFactor();
+    return { point.x / scale, point.y / scale };
+}
+
+GdkRectangle
+nsWindow::DevicePixelsToGdkRectRoundOut(LayoutDeviceIntRect rect) {
+    gint scale = GdkScaleFactor();
+    int x = rect.x / scale;
+    int y = rect.y / scale;
+    int right = (rect.x + rect.width + scale - 1) / scale;
+    int bottom = (rect.y + rect.height + scale - 1) / scale;
+    return { x, y, right - x, bottom - y };
+}
+
+GdkRectangle
+nsWindow::DevicePixelsToGdkSizeRoundUp(LayoutDeviceIntSize pixelSize) {
+    gint scale = GdkScaleFactor();
+    gint width = (pixelSize.width + scale - 1) / scale;
+    gint height = (pixelSize.height + scale - 1) / scale;
+    return { 0, 0, width, height };
+}
+
+int
+nsWindow::GdkCoordToDevicePixels(gint coord) {
+    return coord * GdkScaleFactor();
+}
+
+LayoutDeviceIntPoint
+nsWindow::GdkEventCoordsToDevicePixels(gdouble x, gdouble y)
+{
+    gint scale = GdkScaleFactor();
+    return LayoutDeviceIntPoint::Round(x * scale, y * scale);
+}
+
+LayoutDeviceIntPoint
+nsWindow::GdkPointToDevicePixels(GdkPoint point) {
+    gint scale = GdkScaleFactor();
+    return LayoutDeviceIntPoint(point.x * scale,
+                                point.y * scale);
+}
+
+LayoutDeviceIntRect
+nsWindow::GdkRectToDevicePixels(GdkRectangle rect) {
+    gint scale = GdkScaleFactor();
+    return LayoutDeviceIntRect(rect.x * scale,
+                               rect.y * scale,
+                               rect.width * scale,
+                               rect.height * scale);
+}
+
+nsresult
+nsWindow::SynthesizeNativeMouseEvent(LayoutDeviceIntPoint aPoint,
+                                     uint32_t aNativeMessage,
+                                     uint32_t aModifierFlags,
+                                     nsIObserver* aObserver)
+{
+  AutoObserverNotifier notifier(aObserver, "mouseevent");
+
+  if (!mGdkWindow) {
+    return NS_OK;
+  }
+
+  GdkDisplay* display = gdk_window_get_display(mGdkWindow);
+
+  // When a button-press/release event is requested, create it here and put it in the
+  // event queue. This will not emit a motion event - this needs to be done
+  // explicitly *before* requesting a button-press/release. You will also need to wait
+  // for the motion event to be dispatched before requesting a button-press/release
+  // event to maintain the desired event order.
+  if (aNativeMessage == GDK_BUTTON_PRESS || aNativeMessage == GDK_BUTTON_RELEASE) {
+    GdkEvent event;
+    memset(&event, 0, sizeof(GdkEvent));
+    event.type = (GdkEventType)aNativeMessage;
+    event.button.button = 1;
+    event.button.window = mGdkWindow;
+    event.button.time = GDK_CURRENT_TIME;
+
+#if (MOZ_WIDGET_GTK == 3)
+    // Get device for event source
+    GdkDeviceManager *device_manager = gdk_display_get_device_manager(display);
+    event.button.device = gdk_device_manager_get_client_pointer(device_manager);
+#endif
+
+    event.button.x_root = DevicePixelsToGdkCoordRoundDown(aPoint.x);
+    event.button.y_root = DevicePixelsToGdkCoordRoundDown(aPoint.y);
+
+    LayoutDeviceIntPoint pointInWindow = aPoint - WidgetToScreenOffset();
+    event.button.x = DevicePixelsToGdkCoordRoundDown(pointInWindow.x);
+    event.button.y = DevicePixelsToGdkCoordRoundDown(pointInWindow.y);
+
+    gdk_event_put(&event);
+  } else {
+    // We don't support specific events other than button-press/release. In all
+    // other cases we'll synthesize a motion event that will be emitted by
+    // gdk_display_warp_pointer().
+    GdkScreen* screen = gdk_window_get_screen(mGdkWindow);
+    GdkPoint point = DevicePixelsToGdkPointRoundDown(aPoint);
+    gdk_display_warp_pointer(display, screen, point.x, point.y);
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsWindow::SynthesizeNativeMouseScrollEvent(mozilla::LayoutDeviceIntPoint aPoint,
+                                           uint32_t aNativeMessage,
+                                           double aDeltaX,
+                                           double aDeltaY,
+                                           double aDeltaZ,
+                                           uint32_t aModifierFlags,
+                                           uint32_t aAdditionalFlags,
+                                           nsIObserver* aObserver)
+{
+  AutoObserverNotifier notifier(aObserver, "mousescrollevent");
+
+  if (!mGdkWindow) {
+    return NS_OK;
+  }
+
+  GdkEvent event;
+  memset(&event, 0, sizeof(GdkEvent));
+  event.type = GDK_SCROLL;
+  event.scroll.window = mGdkWindow;
+  event.scroll.time = GDK_CURRENT_TIME;
+#if (MOZ_WIDGET_GTK == 3)
+  // Get device for event source
+  GdkDisplay* display = gdk_window_get_display(mGdkWindow);
+  GdkDeviceManager *device_manager = gdk_display_get_device_manager(display);
+  event.scroll.device = gdk_device_manager_get_client_pointer(device_manager);
+#endif
+  event.scroll.x_root = DevicePixelsToGdkCoordRoundDown(aPoint.x);
+  event.scroll.y_root = DevicePixelsToGdkCoordRoundDown(aPoint.y);
+
+  LayoutDeviceIntPoint pointInWindow = aPoint - WidgetToScreenOffset();
+  event.scroll.x = DevicePixelsToGdkCoordRoundDown(pointInWindow.x);
+  event.scroll.y = DevicePixelsToGdkCoordRoundDown(pointInWindow.y);
+
+  // The delta values are backwards on Linux compared to Windows and Cocoa,
+  // hence the negation.
+#if GTK_CHECK_VERSION(3,4,0)
+  // TODO: is this correct? I don't have GTK 3.4+ so I can't check
+  event.scroll.direction = GDK_SCROLL_SMOOTH;
+  event.scroll.delta_x = -aDeltaX;
+  event.scroll.delta_y = -aDeltaY;
+#else
+  if (aDeltaX < 0) {
+    event.scroll.direction = GDK_SCROLL_RIGHT;
+  } else if (aDeltaX > 0) {
+    event.scroll.direction = GDK_SCROLL_LEFT;
+  } else if (aDeltaY < 0) {
+    event.scroll.direction = GDK_SCROLL_DOWN;
+  } else if (aDeltaY > 0) {
+    event.scroll.direction = GDK_SCROLL_UP;
+  } else {
+    return NS_OK;
+  }
+#endif
+
+  gdk_event_put(&event);
+
+  return NS_OK;
+}
+
+#if GTK_CHECK_VERSION(3,4,0)
+nsresult
+nsWindow::SynthesizeNativeTouchPoint(uint32_t aPointerId,
+                                     TouchPointerState aPointerState,
+                                     LayoutDeviceIntPoint aPoint,
+                                     double aPointerPressure,
+                                     uint32_t aPointerOrientation,
+                                     nsIObserver* aObserver)
+{
+  AutoObserverNotifier notifier(aObserver, "touchpoint");
+
+  if (!mGdkWindow) {
+    return NS_OK;
+  }
+
+  GdkEvent event;
+  memset(&event, 0, sizeof(GdkEvent));
+
+  static std::map<uint32_t, GdkEventSequence*> sKnownPointers;
+
+  auto result = sKnownPointers.find(aPointerId);
+  switch (aPointerState) {
+  case TOUCH_CONTACT:
+    if (result == sKnownPointers.end()) {
+      // GdkEventSequence isn't a thing we can instantiate, and never gets
+      // dereferenced in the gtk code. It's an opaque pointer, the only
+      // requirement is that it be distinct from other instances of
+      // GdkEventSequence*.
+      event.touch.sequence = (GdkEventSequence*)((uintptr_t)aPointerId);
+      sKnownPointers[aPointerId] = event.touch.sequence;
+      event.type = GDK_TOUCH_BEGIN;
+    } else {
+      event.touch.sequence = result->second;
+      event.type = GDK_TOUCH_UPDATE;
+    }
+    break;
+  case TOUCH_REMOVE:
+    event.type = GDK_TOUCH_END;
+    if (result == sKnownPointers.end()) {
+      NS_WARNING("Tried to synthesize touch-end for unknown pointer!");
+      return NS_ERROR_UNEXPECTED;
+    }
+    event.touch.sequence = result->second;
+    sKnownPointers.erase(result);
+    break;
+  case TOUCH_CANCEL:
+    event.type = GDK_TOUCH_CANCEL;
+    if (result == sKnownPointers.end()) {
+      NS_WARNING("Tried to synthesize touch-cancel for unknown pointer!");
+      return NS_ERROR_UNEXPECTED;
+    }
+    event.touch.sequence = result->second;
+    sKnownPointers.erase(result);
+    break;
+  case TOUCH_HOVER:
+  default:
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  event.touch.window = mGdkWindow;
+  event.touch.time = GDK_CURRENT_TIME;
+
+  GdkDisplay* display = gdk_window_get_display(mGdkWindow);
+  GdkDeviceManager* device_manager = gdk_display_get_device_manager(display);
+  event.touch.device = gdk_device_manager_get_client_pointer(device_manager);
+
+  event.touch.x_root = DevicePixelsToGdkCoordRoundDown(aPoint.x);
+  event.touch.y_root = DevicePixelsToGdkCoordRoundDown(aPoint.y);
+
+  LayoutDeviceIntPoint pointInWindow = aPoint - WidgetToScreenOffset();
+  event.touch.x = DevicePixelsToGdkCoordRoundDown(pointInWindow.x);
+  event.touch.y = DevicePixelsToGdkCoordRoundDown(pointInWindow.y);
+
+  gdk_event_put(&event);
+
+  return NS_OK;
+}
+#endif
+
+int32_t
+nsWindow::RoundsWidgetCoordinatesTo()
+{
+    return GdkScaleFactor();
+}
+
+void nsWindow::GetCompositorWidgetInitData(mozilla::widget::CompositorWidgetInitData* aInitData)
+{
+  #ifdef MOZ_X11
+  if (mIsX11Display) {
+    *aInitData = mozilla::widget::CompositorWidgetInitData(
+                                  mXWindow,
+                                  nsCString(XDisplayString(mXDisplay)),
+                                  GetClientSize());
+  #ifdef GDK_WINDOWING_WAYLAND
+  } else {
+    *aInitData = mozilla::widget::CompositorWidgetInitData(
+                                  (uintptr_t)mWaylandSurface,
+                                  nsCString(nullptr),
+                                  GetClientSize());
+  }
+  #endif
+  #endif
+}
+
diff -rupN a/widget/gtk/nsWindow.h b/widget/gtk/nsWindow.h
--- a/widget/gtk/nsWindow.h	2017-01-23 11:13:56.000000000 -0500
+++ b/widget/gtk/nsWindow.h	2017-03-07 23:42:45.353642663 -0500
@@ -23,6 +23,9 @@
 #ifdef MOZ_X11
 #include <gdk/gdkx.h>
 #endif /* MOZ_X11 */
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
 
 #include "mozilla/widget/WindowSurface.h"
 #include "mozilla/widget/WindowSurfaceProvider.h"
@@ -346,9 +349,13 @@ public:
                                                 nsIObserver* aObserver) override;
 #endif
 
+    bool     IsX11Display() { return mIsX11Display; }
 #ifdef MOZ_X11
     Display* XDisplay() { return mXDisplay; }
 #endif
+#ifdef GDK_WINDOWING_WAYLAND
+    wl_display* WaylandDisplay() { return mWaylandDisplay; }
+#endif
     virtual void GetCompositorWidgetInitData(mozilla::widget::CompositorWidgetInitData* aInitData) override;
 
     // HiDPI scale conversion
@@ -462,9 +469,12 @@ private:
     Window              mXWindow;
     Visual*             mXVisual;
     int                 mXDepth;
+#ifdef GDK_WINDOWING_WAYLAND
+    wl_display*         mWaylandDisplay;
+    wl_surface*         mWaylandSurface;
+#endif
     mozilla::widget::WindowSurfaceProvider mSurfaceProvider;
 #endif
-
     // Upper bound on pending ConfigureNotify events to be dispatched to the
     // window. See bug 1225044.
     unsigned int mPendingConfigures;
diff -rupN a/widget/gtk/nsWindow.h.orig b/widget/gtk/nsWindow.h.orig
--- a/widget/gtk/nsWindow.h.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/widget/gtk/nsWindow.h.orig	2017-01-23 11:13:56.000000000 -0500
@@ -0,0 +1,580 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsWindow_h__
+#define __nsWindow_h__
+
+#include "mozcontainer.h"
+#include "mozilla/RefPtr.h"
+#include "mozilla/UniquePtr.h"
+#include "nsIDragService.h"
+#include "nsITimer.h"
+#include "nsGkAtoms.h"
+#include "nsRefPtrHashtable.h"
+
+#include "nsBaseWidget.h"
+#include <gdk/gdk.h>
+#include <gtk/gtk.h>
+
+#ifdef MOZ_X11
+#include <gdk/gdkx.h>
+#endif /* MOZ_X11 */
+
+#include "mozilla/widget/WindowSurface.h"
+#include "mozilla/widget/WindowSurfaceProvider.h"
+
+#ifdef ACCESSIBILITY
+#include "mozilla/a11y/Accessible.h"
+#endif
+#include "mozilla/EventForwards.h"
+#include "mozilla/TouchEvents.h"
+
+#include "IMContextWrapper.h"
+
+#undef LOG
+#ifdef MOZ_LOGGING
+
+#include "mozilla/Logging.h"
+#include "nsTArray.h"
+#include "Units.h"
+
+extern PRLogModuleInfo *gWidgetLog;
+extern PRLogModuleInfo *gWidgetFocusLog;
+extern PRLogModuleInfo *gWidgetDragLog;
+extern PRLogModuleInfo *gWidgetDrawLog;
+
+#define LOG(args) MOZ_LOG(gWidgetLog, mozilla::LogLevel::Debug, args)
+#define LOGFOCUS(args) MOZ_LOG(gWidgetFocusLog, mozilla::LogLevel::Debug, args)
+#define LOGDRAG(args) MOZ_LOG(gWidgetDragLog, mozilla::LogLevel::Debug, args)
+#define LOGDRAW(args) MOZ_LOG(gWidgetDrawLog, mozilla::LogLevel::Debug, args)
+
+#else
+
+#define LOG(args)
+#define LOGFOCUS(args)
+#define LOGDRAG(args)
+#define LOGDRAW(args)
+
+#endif /* MOZ_LOGGING */
+
+class gfxPattern;
+class nsPluginNativeWindowGtk;
+
+namespace mozilla {
+class TimeStamp;
+class CurrentX11TimeGetter;
+}
+
+class nsWindow : public nsBaseWidget
+{
+public:
+    typedef mozilla::gfx::DrawTarget DrawTarget;
+    typedef mozilla::WidgetEventTime WidgetEventTime;
+
+    nsWindow();
+
+    static void ReleaseGlobals();
+
+    NS_DECL_ISUPPORTS_INHERITED
+
+    void CommonCreate(nsIWidget *aParent, bool aListenForResizes);
+
+    virtual nsresult DispatchEvent(mozilla::WidgetGUIEvent* aEvent,
+                                   nsEventStatus& aStatus) override;
+
+    // called when we are destroyed
+    virtual void OnDestroy(void) override;
+
+    // called to check and see if a widget's dimensions are sane
+    bool AreBoundsSane(void);
+
+    // nsIWidget
+    using nsBaseWidget::Create; // for Create signature not overridden here
+    virtual MOZ_MUST_USE nsresult Create(nsIWidget* aParent,
+                                         nsNativeWidget aNativeParent,
+                                         const LayoutDeviceIntRect& aRect,
+                                         nsWidgetInitData* aInitData) override;
+    virtual void       Destroy() override;
+    virtual nsIWidget *GetParent() override;
+    virtual float      GetDPI() override;
+    virtual double     GetDefaultScaleInternal() override;
+    // Under Gtk, we manage windows using device pixels so no scaling is needed:
+    mozilla::DesktopToLayoutDeviceScale GetDesktopToDeviceScale() final
+    {
+        return mozilla::DesktopToLayoutDeviceScale(1.0);
+    }
+    virtual nsresult   SetParent(nsIWidget* aNewParent) override;
+    virtual void       SetModal(bool aModal) override;
+    virtual bool       IsVisible() const override;
+    virtual void       ConstrainPosition(bool aAllowSlop,
+                                         int32_t *aX,
+                                         int32_t *aY) override;
+    virtual void       SetSizeConstraints(const SizeConstraints& aConstraints) override;
+    NS_IMETHOD         Move(double aX,
+                            double aY) override;
+    NS_IMETHOD         Show             (bool aState) override;
+    NS_IMETHOD         Resize           (double aWidth,
+                                         double aHeight,
+                                         bool   aRepaint) override;
+    NS_IMETHOD         Resize           (double aX,
+                                         double aY,
+                                         double aWidth,
+                                         double aHeight,
+                                         bool   aRepaint) override;
+    virtual bool       IsEnabled() const override;
+
+    void               SetZIndex(int32_t aZIndex) override;
+    virtual void       SetSizeMode(nsSizeMode aMode) override;
+    NS_IMETHOD         Enable(bool aState) override;
+    NS_IMETHOD         SetFocus(bool aRaise = false) override;
+    virtual LayoutDeviceIntRect GetScreenBounds() override;
+    virtual LayoutDeviceIntRect GetClientBounds() override;
+    virtual LayoutDeviceIntSize GetClientSize() override;
+    virtual LayoutDeviceIntPoint GetClientOffset() override;
+    NS_IMETHOD         SetCursor(nsCursor aCursor) override;
+    NS_IMETHOD         SetCursor(imgIContainer* aCursor,
+                                 uint32_t aHotspotX, uint32_t aHotspotY) override;
+    NS_IMETHOD         Invalidate(const LayoutDeviceIntRect& aRect) override;
+    virtual void*      GetNativeData(uint32_t aDataType) override;
+    void               SetNativeData(uint32_t aDataType, uintptr_t aVal) override;
+    NS_IMETHOD         SetTitle(const nsAString& aTitle) override;
+    NS_IMETHOD         SetIcon(const nsAString& aIconSpec) override;
+    virtual void       SetWindowClass(const nsAString& xulWinType) override;
+    virtual LayoutDeviceIntPoint WidgetToScreenOffset() override;
+    virtual void       CaptureMouse(bool aCapture) override;
+    virtual void       CaptureRollupEvents(nsIRollupListener *aListener,
+                                           bool aDoCapture) override;
+    NS_IMETHOD         GetAttention(int32_t aCycleCount) override;
+    virtual nsresult   SetWindowClipRegion(const nsTArray<LayoutDeviceIntRect>& aRects,
+                                           bool aIntersectWithExisting) override;
+    virtual bool       HasPendingInputEvent() override;
+
+    virtual bool PrepareForFullscreenTransition(nsISupports** aData) override;
+    virtual void PerformFullscreenTransition(FullscreenTransitionStage aStage,
+                                             uint16_t aDuration,
+                                             nsISupports* aData,
+                                             nsIRunnable* aCallback) override;
+    virtual nsresult   MakeFullScreen(bool aFullScreen,
+                                      nsIScreen* aTargetScreen = nullptr) override;
+    NS_IMETHOD         HideWindowChrome(bool aShouldHide) override;
+
+    /**
+     * GetLastUserInputTime returns a timestamp for the most recent user input
+     * event.  This is intended for pointer grab requests (including drags).
+     */
+    static guint32     GetLastUserInputTime();
+
+    // utility method, -1 if no change should be made, otherwise returns a
+    // value that can be passed to gdk_window_set_decorations
+    gint               ConvertBorderStyles(nsBorderStyle aStyle);
+
+    GdkRectangle DevicePixelsToGdkRectRoundOut(LayoutDeviceIntRect aRect);
+
+    // event callbacks
+#if (MOZ_WIDGET_GTK == 2)
+    gboolean           OnExposeEvent(GdkEventExpose *aEvent);
+#else
+    gboolean           OnExposeEvent(cairo_t *cr);
+#endif
+    gboolean           OnConfigureEvent(GtkWidget *aWidget,
+                                        GdkEventConfigure *aEvent);
+    void               OnContainerUnrealize();
+    void               OnSizeAllocate(GtkAllocation *aAllocation);
+    void               OnDeleteEvent();
+    void               OnEnterNotifyEvent(GdkEventCrossing *aEvent);
+    void               OnLeaveNotifyEvent(GdkEventCrossing *aEvent);
+    void               OnMotionNotifyEvent(GdkEventMotion *aEvent);
+    void               OnButtonPressEvent(GdkEventButton *aEvent);
+    void               OnButtonReleaseEvent(GdkEventButton *aEvent);
+    void               OnContainerFocusInEvent(GdkEventFocus *aEvent);
+    void               OnContainerFocusOutEvent(GdkEventFocus *aEvent);
+    gboolean           OnKeyPressEvent(GdkEventKey *aEvent);
+    gboolean           OnKeyReleaseEvent(GdkEventKey *aEvent);
+    void               OnScrollEvent(GdkEventScroll *aEvent);
+    void               OnVisibilityNotifyEvent(GdkEventVisibility *aEvent);
+    void               OnWindowStateEvent(GtkWidget *aWidget,
+                                          GdkEventWindowState *aEvent);
+    void               OnDragDataReceivedEvent(GtkWidget       *aWidget,
+                                               GdkDragContext  *aDragContext,
+                                               gint             aX,
+                                               gint             aY,
+                                               GtkSelectionData*aSelectionData,
+                                               guint            aInfo,
+                                               guint            aTime,
+                                               gpointer         aData);
+    gboolean           OnPropertyNotifyEvent(GtkWidget *aWidget,
+                                             GdkEventProperty *aEvent);
+#if GTK_CHECK_VERSION(3,4,0)
+    gboolean           OnTouchEvent(GdkEventTouch* aEvent);
+#endif
+
+    virtual already_AddRefed<mozilla::gfx::DrawTarget>
+                       StartRemoteDrawingInRegion(LayoutDeviceIntRegion& aInvalidRegion,
+                                                  mozilla::layers::BufferMode* aBufferMode) override;
+    virtual void       EndRemoteDrawingInRegion(mozilla::gfx::DrawTarget* aDrawTarget,
+                                                LayoutDeviceIntRegion& aInvalidRegion) override;
+
+private:
+    void               UpdateAlpha(mozilla::gfx::SourceSurface* aSourceSurface, nsIntRect aBoundsRect);
+
+    void               NativeMove();
+    void               NativeResize();
+    void               NativeMoveResize();
+
+    void               NativeShow  (bool    aAction);
+    void               SetHasMappedToplevel(bool aState);
+    LayoutDeviceIntSize GetSafeWindowSize(LayoutDeviceIntSize aSize);
+
+    void               EnsureGrabs  (void);
+    void               GrabPointer  (guint32 aTime);
+    void               ReleaseGrabs (void);
+
+    void               UpdateClientOffset();
+
+public:
+    enum PluginType {
+        PluginType_NONE = 0,   /* do not have any plugin */
+        PluginType_XEMBED,     /* the plugin support xembed */
+        PluginType_NONXEMBED   /* the plugin does not support xembed */
+    };
+
+    void               SetPluginType(PluginType aPluginType);
+#ifdef MOZ_X11
+    void               SetNonXEmbedPluginFocus(void);
+    void               LoseNonXEmbedPluginFocus(void);
+#endif /* MOZ_X11 */
+
+    void               ThemeChanged(void);
+    void               OnDPIChanged(void);
+    void               OnCheckResize(void);
+
+#ifdef MOZ_X11
+    Window             mOldFocusWindow;
+#endif /* MOZ_X11 */
+
+    static guint32     sLastButtonPressTime;
+
+    NS_IMETHOD         BeginResizeDrag(mozilla::WidgetGUIEvent* aEvent,
+                                       int32_t aHorizontal,
+                                       int32_t aVertical) override;
+    NS_IMETHOD         BeginMoveDrag(mozilla::WidgetMouseEvent* aEvent) override;
+
+    MozContainer*      GetMozContainer() { return mContainer; }
+    // GetMozContainerWidget returns the MozContainer even for undestroyed
+    // descendant windows
+    GtkWidget*         GetMozContainerWidget();
+    GdkWindow*         GetGdkWindow() { return mGdkWindow; }
+    bool               IsDestroyed() { return mIsDestroyed; }
+
+    void               DispatchDragEvent(mozilla::EventMessage aMsg,
+                                         const LayoutDeviceIntPoint& aRefPoint,
+                                         guint aTime);
+    static void        UpdateDragStatus (GdkDragContext *aDragContext,
+                                         nsIDragService *aDragService);
+    // If this dispatched the keydown event actually, this returns TRUE,
+    // otherwise, FALSE.
+    bool               DispatchKeyDownEvent(GdkEventKey *aEvent,
+                                            bool *aIsCancelled);
+    WidgetEventTime    GetWidgetEventTime(guint32 aEventTime);
+    mozilla::TimeStamp GetEventTimeStamp(guint32 aEventTime);
+    mozilla::CurrentX11TimeGetter* GetCurrentTimeGetter();
+
+    NS_IMETHOD_(void) SetInputContext(const InputContext& aContext,
+                                      const InputContextAction& aAction) override;
+    NS_IMETHOD_(InputContext) GetInputContext() override;
+    virtual nsIMEUpdatePreference GetIMEUpdatePreference() override;
+    NS_IMETHOD_(TextEventDispatcherListener*)
+        GetNativeTextEventDispatcherListener() override;
+    bool ExecuteNativeKeyBindingRemapped(
+                        NativeKeyBindingsType aType,
+                        const mozilla::WidgetKeyboardEvent& aEvent,
+                        DoCommandCallback aCallback,
+                        void* aCallbackData,
+                        uint32_t aGeckoKeyCode,
+                        uint32_t aNativeKeyCode);
+    NS_IMETHOD_(bool) ExecuteNativeKeyBinding(
+                        NativeKeyBindingsType aType,
+                        const mozilla::WidgetKeyboardEvent& aEvent,
+                        DoCommandCallback aCallback,
+                        void* aCallbackData) override;
+
+    // These methods are for toplevel windows only.
+    void               ResizeTransparencyBitmap();
+    void               ApplyTransparencyBitmap();
+    void               ClearTransparencyBitmap();
+
+   virtual void        SetTransparencyMode(nsTransparencyMode aMode) override;
+   virtual nsTransparencyMode GetTransparencyMode() override;
+   virtual nsresult    ConfigureChildren(const nsTArray<Configuration>& aConfigurations) override;
+   nsresult            UpdateTranslucentWindowAlphaInternal(const nsIntRect& aRect,
+                                                            uint8_t* aAlphas, int32_t aStride);
+
+#if (MOZ_WIDGET_GTK == 2)
+    static already_AddRefed<DrawTarget> GetDrawTargetForGdkDrawable(GdkDrawable* aDrawable,
+                                                                    const mozilla::gfx::IntSize& aSize);
+#endif
+    virtual void       ReparentNativeWidget(nsIWidget* aNewParent) override;
+
+    virtual nsresult SynthesizeNativeMouseEvent(LayoutDeviceIntPoint aPoint,
+                                                uint32_t aNativeMessage,
+                                                uint32_t aModifierFlags,
+                                                nsIObserver* aObserver) override;
+
+    virtual nsresult SynthesizeNativeMouseMove(LayoutDeviceIntPoint aPoint,
+                                               nsIObserver* aObserver) override
+    { return SynthesizeNativeMouseEvent(aPoint, GDK_MOTION_NOTIFY, 0, aObserver); }
+
+    virtual nsresult SynthesizeNativeMouseScrollEvent(LayoutDeviceIntPoint aPoint,
+                                                      uint32_t aNativeMessage,
+                                                      double aDeltaX,
+                                                      double aDeltaY,
+                                                      double aDeltaZ,
+                                                      uint32_t aModifierFlags,
+                                                      uint32_t aAdditionalFlags,
+                                                      nsIObserver* aObserver) override;
+
+#if GTK_CHECK_VERSION(3,4,0)
+    virtual nsresult SynthesizeNativeTouchPoint(uint32_t aPointerId,
+                                                TouchPointerState aPointerState,
+                                                LayoutDeviceIntPoint aPoint,
+                                                double aPointerPressure,
+                                                uint32_t aPointerOrientation,
+                                                nsIObserver* aObserver) override;
+#endif
+
+#ifdef MOZ_X11
+    Display* XDisplay() { return mXDisplay; }
+#endif
+    virtual void GetCompositorWidgetInitData(mozilla::widget::CompositorWidgetInitData* aInitData) override;
+
+    // HiDPI scale conversion
+    gint GdkScaleFactor();
+
+    // To GDK
+    gint DevicePixelsToGdkCoordRoundUp(int pixels);
+    gint DevicePixelsToGdkCoordRoundDown(int pixels);
+    GdkPoint DevicePixelsToGdkPointRoundDown(LayoutDeviceIntPoint point);
+    GdkRectangle DevicePixelsToGdkSizeRoundUp(LayoutDeviceIntSize pixelSize);
+
+    // From GDK
+    int GdkCoordToDevicePixels(gint coord);
+    LayoutDeviceIntPoint GdkPointToDevicePixels(GdkPoint point);
+    LayoutDeviceIntPoint GdkEventCoordsToDevicePixels(gdouble x, gdouble y);
+    LayoutDeviceIntRect GdkRectToDevicePixels(GdkRectangle rect);
+
+    virtual bool WidgetTypeSupportsAcceleration() override;
+protected:
+    virtual ~nsWindow();
+
+    // event handling code
+    void DispatchActivateEvent(void);
+    void DispatchDeactivateEvent(void);
+    void DispatchResized();
+    void MaybeDispatchResized();
+
+    // Helper for SetParent and ReparentNativeWidget.
+    void ReparentNativeWidgetInternal(nsIWidget* aNewParent,
+                                      GtkWidget* aNewContainer,
+                                      GdkWindow* aNewParentWindow,
+                                      GtkWidget* aOldContainer);
+
+    virtual void RegisterTouchWindow() override;
+
+    nsCOMPtr<nsIWidget> mParent;
+    // Is this a toplevel window?
+    bool                mIsTopLevel;
+    // Has this widget been destroyed yet?
+    bool                mIsDestroyed;
+
+    // Should we send resize events on all resizes?
+    bool                mListenForResizes;
+    // Does WindowResized need to be called on listeners?
+    bool                mNeedsDispatchResized;
+    // This flag tracks if we're hidden or shown.
+    bool                mIsShown;
+    bool                mNeedsShow;
+    // is this widget enabled?
+    bool                mEnabled;
+    // has the native window for this been created yet?
+    bool                mCreated;
+#if GTK_CHECK_VERSION(3,4,0)
+    // whether we handle touch event
+    bool                mHandleTouchEvent;
+#endif
+    // true if this is a drag and drop feedback popup
+    bool               mIsDragPopup;
+    // Can we access X?
+    bool               mIsX11Display;
+
+private:
+    void               DestroyChildWindows();
+    GtkWidget         *GetToplevelWidget();
+    nsWindow          *GetContainerWindow();
+    void               SetUrgencyHint(GtkWidget *top_window, bool state);
+    void              *SetupPluginPort(void);
+    void               SetDefaultIcon(void);
+    void               InitButtonEvent(mozilla::WidgetMouseEvent& aEvent,
+                                       GdkEventButton* aGdkEvent);
+    bool               DispatchCommandEvent(nsIAtom* aCommand);
+    bool               DispatchContentCommandEvent(mozilla::EventMessage aMsg);
+    bool               CheckForRollup(gdouble aMouseX, gdouble aMouseY,
+                                      bool aIsWheel, bool aAlwaysRollup);
+    void               CheckForRollupDuringGrab()
+    {
+      CheckForRollup(0, 0, false, true);
+    }
+
+    bool               GetDragInfo(mozilla::WidgetMouseEvent* aMouseEvent,
+                                   GdkWindow** aWindow, gint* aButton,
+                                   gint* aRootX, gint* aRootY);
+    void               ClearCachedResources();
+    nsIWidgetListener* GetListener();
+
+    GtkWidget          *mShell;
+    MozContainer       *mContainer;
+    GdkWindow          *mGdkWindow;
+
+    uint32_t            mHasMappedToplevel : 1,
+                        mIsFullyObscured : 1,
+                        mRetryPointerGrab : 1;
+    nsSizeMode          mSizeState;
+    PluginType          mPluginType;
+
+    int32_t             mTransparencyBitmapWidth;
+    int32_t             mTransparencyBitmapHeight;
+
+    nsIntPoint          mClientOffset;
+
+#if GTK_CHECK_VERSION(3,4,0)
+    // This field omits duplicate scroll events caused by GNOME bug 726878.
+    guint32             mLastScrollEventTime;
+
+    // for touch event handling
+    nsRefPtrHashtable<nsPtrHashKey<GdkEventSequence>, mozilla::dom::Touch> mTouches;
+#endif
+
+#ifdef MOZ_X11
+    Display*            mXDisplay;
+    Window              mXWindow;
+    Visual*             mXVisual;
+    int                 mXDepth;
+    mozilla::widget::WindowSurfaceProvider mSurfaceProvider;
+#endif
+
+    // Upper bound on pending ConfigureNotify events to be dispatched to the
+    // window. See bug 1225044.
+    unsigned int mPendingConfigures;
+
+#ifdef ACCESSIBILITY
+    RefPtr<mozilla::a11y::Accessible> mRootAccessible;
+
+    /**
+     * Request to create the accessible for this window if it is top level.
+     */
+    void                CreateRootAccessible();
+
+    /**
+     * Dispatch accessible event for the top level window accessible.
+     *
+     * @param  aEventType  [in] the accessible event type to dispatch
+     */
+    void                DispatchEventToRootAccessible(uint32_t aEventType);
+
+    /**
+     * Dispatch accessible window activate event for the top level window
+     * accessible.
+     */
+    void                DispatchActivateEventAccessible();
+
+    /**
+     * Dispatch accessible window deactivate event for the top level window
+     * accessible.
+     */
+    void                DispatchDeactivateEventAccessible();
+
+    /**
+     * Dispatch accessible window maximize event for the top level window
+     * accessible.
+     */
+    void                DispatchMaximizeEventAccessible();
+
+    /**
+     * Dispatch accessible window minize event for the top level window
+     * accessible.
+     */
+    void                DispatchMinimizeEventAccessible();
+
+    /**
+     * Dispatch accessible window restore event for the top level window
+     * accessible.
+     */
+    void                DispatchRestoreEventAccessible();
+#endif
+
+    // Updates the bounds of the socket widget we manage for remote plugins.
+    void ResizePluginSocketWidget();
+
+    // e10s specific - for managing the socket widget this window hosts.
+    nsPluginNativeWindowGtk* mPluginNativeWindow;
+
+    // The cursor cache
+    static GdkCursor   *gsGtkCursorCache[eCursorCount];
+
+    // Transparency
+    bool         mIsTransparent;
+    // This bitmap tracks which pixels are transparent. We don't support
+    // full translucency at this time; each pixel is either fully opaque
+    // or fully transparent.
+    gchar*       mTransparencyBitmap;
+
+    // all of our DND stuff
+    void   InitDragEvent(mozilla::WidgetDragEvent& aEvent);
+
+    float              mLastMotionPressure;
+
+    // Remember the last sizemode so that we can restore it when
+    // leaving fullscreen
+    nsSizeMode         mLastSizeMode;
+
+    static bool DragInProgress(void);
+
+    void DispatchMissedButtonReleases(GdkEventCrossing *aGdkEvent);
+
+    // nsBaseWidget
+    virtual LayerManager* GetLayerManager(PLayerTransactionChild* aShadowManager = nullptr,
+                                          LayersBackend aBackendHint = mozilla::layers::LayersBackend::LAYERS_NONE,
+                                          LayerManagerPersistence aPersistence = LAYER_MANAGER_CURRENT) override;
+
+    void CleanLayerManagerRecursive();
+
+    virtual int32_t RoundsWidgetCoordinatesTo() override;
+
+    /**
+     * |mIMContext| takes all IME related stuff.
+     *
+     * This is owned by the top-level nsWindow or the topmost child
+     * nsWindow embedded in a non-Gecko widget.
+     *
+     * The instance is created when the top level widget is created.  And when
+     * the widget is destroyed, it's released.  All child windows refer its
+     * ancestor widget's instance.  So, one set of IM contexts is created for
+     * all windows in a hierarchy.  If the children are released after the top
+     * level window is released, the children still have a valid pointer,
+     * however, IME doesn't work at that time.
+     */
+    RefPtr<mozilla::widget::IMContextWrapper> mIMContext;
+
+    mozilla::UniquePtr<mozilla::CurrentX11TimeGetter> mCurrentTimeGetter;
+};
+
+class nsChildWindow : public nsWindow {
+public:
+    nsChildWindow();
+    ~nsChildWindow();
+};
+
+#endif /* __nsWindow_h__ */
diff -rupN a/widget/gtk/os-compatibility.c b/widget/gtk/os-compatibility.c
--- a/widget/gtk/os-compatibility.c	1969-12-31 19:00:00.000000000 -0500
+++ b/widget/gtk/os-compatibility.c	2017-03-07 23:40:34.292635643 -0500
@@ -0,0 +1,201 @@
+/*
+ * Copyright  2012 Collabora, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+* This file is a part of Weston project,
+* https://github.com/wayland-project/weston/blob/master/shared/os-compatibility.c
+*/
+
+#include "mozilla-config.h"
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/epoll.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "os-compatibility.h"
+
+int
+os_fd_set_cloexec(int fd)
+{
+	long flags;
+
+	if (fd == -1)
+		return -1;
+
+	flags = fcntl(fd, F_GETFD);
+	if (flags == -1)
+		return -1;
+
+	if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1)
+		return -1;
+
+	return 0;
+}
+
+static int
+set_cloexec_or_close(int fd)
+{
+	if (os_fd_set_cloexec(fd) != 0) {
+		close(fd);
+		return -1;
+	}
+	return fd;
+}
+
+int
+os_socketpair_cloexec(int domain, int type, int protocol, int *sv)
+{
+	int ret;
+
+#ifdef SOCK_CLOEXEC
+	ret = socketpair(domain, type | SOCK_CLOEXEC, protocol, sv);
+	if (ret == 0 || errno != EINVAL)
+		return ret;
+#endif
+
+	ret = socketpair(domain, type, protocol, sv);
+	if (ret < 0)
+		return ret;
+
+	sv[0] = set_cloexec_or_close(sv[0]);
+	sv[1] = set_cloexec_or_close(sv[1]);
+
+	if (sv[0] != -1 && sv[1] != -1)
+		return 0;
+
+	close(sv[0]);
+	close(sv[1]);
+	return -1;
+}
+
+int
+os_epoll_create_cloexec(void)
+{
+	int fd;
+
+#ifdef EPOLL_CLOEXEC
+	fd = epoll_create1(EPOLL_CLOEXEC);
+	if (fd >= 0)
+		return fd;
+	if (errno != EINVAL)
+		return -1;
+#endif
+
+	fd = epoll_create(1);
+	return set_cloexec_or_close(fd);
+}
+
+static int
+create_tmpfile_cloexec(char *tmpname)
+{
+	int fd;
+
+#ifdef HAVE_MKOSTEMP
+	fd = mkostemp(tmpname, O_CLOEXEC);
+	if (fd >= 0)
+		unlink(tmpname);
+#else
+	fd = mkstemp(tmpname);
+	if (fd >= 0) {
+		fd = set_cloexec_or_close(fd);
+		unlink(tmpname);
+	}
+#endif
+
+	return fd;
+}
+
+/*
+ * Create a new, unique, anonymous file of the given size, and
+ * return the file descriptor for it. The file descriptor is set
+ * CLOEXEC. The file is immediately suitable for mmap()'ing
+ * the given size at offset zero.
+ *
+ * The file should not have a permanent backing store like a disk,
+ * but may have if XDG_RUNTIME_DIR is not properly implemented in OS.
+ *
+ * The file name is deleted from the file system.
+ *
+ * The file is suitable for buffer sharing between processes by
+ * transmitting the file descriptor over Unix sockets using the
+ * SCM_RIGHTS methods.
+ *
+ * If the C library implements posix_fallocate(), it is used to
+ * guarantee that disk space is available for the file at the
+ * given size. If disk space is insufficent, errno is set to ENOSPC.
+ * If posix_fallocate() is not supported, program may receive
+ * SIGBUS on accessing mmap()'ed file contents instead.
+ */
+int
+os_create_anonymous_file(off_t size)
+{
+	static const char template[] = "/weston-shared-XXXXXX";
+	const char *path;
+	char *name;
+	int fd;
+	int ret;
+
+	path = getenv("XDG_RUNTIME_DIR");
+	if (!path) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	name = malloc(strlen(path) + sizeof(template));
+	if (!name)
+		return -1;
+
+	strcpy(name, path);
+	strcat(name, template);
+
+	fd = create_tmpfile_cloexec(name);
+
+	free(name);
+
+	if (fd < 0)
+		return -1;
+
+#ifdef HAVE_POSIX_FALLOCATE
+	ret = posix_fallocate(fd, 0, size);
+	if (ret != 0) {
+		close(fd);
+		errno = ret;
+		return -1;
+	}
+#else
+	ret = ftruncate(fd, size);
+	if (ret < 0) {
+		close(fd);
+		return -1;
+	}
+#endif
+
+	return fd;
+}
diff -rupN a/widget/gtk/os-compatibility.h b/widget/gtk/os-compatibility.h
--- a/widget/gtk/os-compatibility.h	1969-12-31 19:00:00.000000000 -0500
+++ b/widget/gtk/os-compatibility.h	2017-03-07 23:40:34.293635643 -0500
@@ -0,0 +1,54 @@
+/*
+ * Copyright  2012 Collabora, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+ /*
+  * This file is a part of Weston project,
+  * https://github.com/wayland-project/weston/blob/master/shared/os-compatibility.h
+  */
+
+#ifndef OS_COMPATIBILITY_H
+#define OS_COMPATIBILITY_H
+
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+int
+os_fd_set_cloexec(int fd);
+
+int
+os_socketpair_cloexec(int domain, int type, int protocol, int *sv);
+
+int
+os_epoll_create_cloexec(void);
+
+int
+os_create_anonymous_file(off_t size);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* OS_COMPATIBILITY_H */
diff -rupN a/widget/gtk/WindowSurfaceProvider.cpp b/widget/gtk/WindowSurfaceProvider.cpp
--- a/widget/gtk/WindowSurfaceProvider.cpp	2017-01-23 11:13:56.000000000 -0500
+++ b/widget/gtk/WindowSurfaceProvider.cpp	2017-03-07 23:41:46.921639533 -0500
@@ -11,6 +11,7 @@
 #include "WindowSurfaceX11Image.h"
 #include "WindowSurfaceX11SHM.h"
 #include "WindowSurfaceXRender.h"
+#include "WindowSurfaceWayland.h"
 
 namespace mozilla {
 namespace widget {
@@ -19,11 +20,17 @@ using namespace mozilla::gfx;
 using namespace mozilla::layers;
 
 WindowSurfaceProvider::WindowSurfaceProvider()
-    : mXDisplay(nullptr)
+    : mIsX11Display(false)
+    , mXDisplay(nullptr)
     , mXWindow(0)
     , mXVisual(nullptr)
     , mXDepth(0)
     , mWindowSurface(nullptr)
+#ifdef GDK_WINDOWING_WAYLAND
+    , mWidget(nullptr)
+    , mWaylandDisplay(nullptr)
+    , mWaylandSurface(nullptr)
+#endif
 {
 }
 
@@ -43,7 +50,23 @@ void WindowSurfaceProvider::Initialize(
   mXWindow = aWindow;
   mXVisual = aVisual;
   mXDepth = aDepth;
+  mIsX11Display = true;
 }
+
+void WindowSurfaceProvider::Initialize(
+      nsWindow *aWidget,
+      wl_display *aWaylandDisplay,
+      wl_surface *aWaylandSurface)
+{
+  // We should not be initialized
+  MOZ_ASSERT(!mWaylandSurface);
+
+  mWidget = aWidget;
+  mWaylandDisplay = aWaylandDisplay;
+  mWaylandSurface = aWaylandSurface;
+  mIsX11Display = false;
+}
+
 void WindowSurfaceProvider::CleanupResources()
 {
   mWindowSurface = nullptr;
@@ -52,30 +75,36 @@ void WindowSurfaceProvider::CleanupResou
 UniquePtr<WindowSurface>
 WindowSurfaceProvider::CreateWindowSurface()
 {
-  // We should be initialized
-  MOZ_ASSERT(mXDisplay);
-
-  // Blit to the window with the following priority:
-  // 1. XRender (iff XRender is enabled && we are in-process)
-  // 2. MIT-SHM
-  // 3. XPutImage
+  if (mIsX11Display) {
+    // We should be initialized
+    MOZ_ASSERT(mXDisplay);
+
+    // Blit to the window with the following priority:
+    // 1. XRender (iff XRender is enabled && we are in-process)
+    // 2. MIT-SHM
+    // 3. XPutImage
 
 #ifdef MOZ_WIDGET_GTK
-  if (gfxVars::UseXRender()) {
-    LOGDRAW(("Drawing to nsWindow %p using XRender\n", (void*)this));
-    return MakeUnique<WindowSurfaceXRender>(mXDisplay, mXWindow, mXVisual, mXDepth);
-  }
+    if (gfxVars::UseXRender()) {
+      LOGDRAW(("Drawing to nsWindow %p using XRender\n", (void*)this));
+      return MakeUnique<WindowSurfaceXRender>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    }
 #endif // MOZ_WIDGET_GTK
 
 #ifdef MOZ_HAVE_SHMIMAGE
-  if (nsShmImage::UseShm()) {
-    LOGDRAW(("Drawing to nsWindow %p using MIT-SHM\n", (void*)this));
-    return MakeUnique<WindowSurfaceX11SHM>(mXDisplay, mXWindow, mXVisual, mXDepth);
-  }
+    if (nsShmImage::UseShm()) {
+      LOGDRAW(("Drawing to nsWindow %p using MIT-SHM\n", (void*)this));
+      return MakeUnique<WindowSurfaceX11SHM>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    }
 #endif // MOZ_HAVE_SHMIMAGE
 
-  LOGDRAW(("Drawing to nsWindow %p using XPutImage\n", (void*)this));
-  return MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    LOGDRAW(("Drawing to nsWindow %p using XPutImage\n", (void*)this));
+    return MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
+  } else {
+    MOZ_ASSERT(mWaylandDisplay);
+    LOGDRAW(("Drawing to nsWindow %p using wl_surface\n", (void*)this));
+    return MakeUnique<WindowSurfaceWayland>(mWidget, mWaylandDisplay, mWaylandSurface);
+  }
 }
 
 already_AddRefed<gfx::DrawTarget>
diff -rupN a/widget/gtk/WindowSurfaceProvider.cpp.orig b/widget/gtk/WindowSurfaceProvider.cpp.orig
--- a/widget/gtk/WindowSurfaceProvider.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/widget/gtk/WindowSurfaceProvider.cpp.orig	2017-01-23 11:13:56.000000000 -0500
@@ -0,0 +1,114 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "WindowSurfaceProvider.h"
+
+#include "gfxPlatformGtk.h"
+#include "mozilla/layers/LayersTypes.h"
+#include "WindowSurfaceX11Image.h"
+#include "WindowSurfaceX11SHM.h"
+#include "WindowSurfaceXRender.h"
+
+namespace mozilla {
+namespace widget {
+
+using namespace mozilla::gfx;
+using namespace mozilla::layers;
+
+WindowSurfaceProvider::WindowSurfaceProvider()
+    : mXDisplay(nullptr)
+    , mXWindow(0)
+    , mXVisual(nullptr)
+    , mXDepth(0)
+    , mWindowSurface(nullptr)
+{
+}
+
+void WindowSurfaceProvider::Initialize(
+      Display* aDisplay,
+      Window aWindow,
+      Visual* aVisual,
+      int aDepth)
+{
+  // We should not be initialized
+  MOZ_ASSERT(!mXDisplay);
+
+  // This should also be a valid initialization
+  MOZ_ASSERT(aDisplay && aWindow != X11None && aVisual);
+
+  mXDisplay = aDisplay;
+  mXWindow = aWindow;
+  mXVisual = aVisual;
+  mXDepth = aDepth;
+}
+void WindowSurfaceProvider::CleanupResources()
+{
+  mWindowSurface = nullptr;
+}
+
+UniquePtr<WindowSurface>
+WindowSurfaceProvider::CreateWindowSurface()
+{
+  // We should be initialized
+  MOZ_ASSERT(mXDisplay);
+
+  // Blit to the window with the following priority:
+  // 1. XRender (iff XRender is enabled && we are in-process)
+  // 2. MIT-SHM
+  // 3. XPutImage
+
+#ifdef MOZ_WIDGET_GTK
+  if (gfxVars::UseXRender()) {
+    LOGDRAW(("Drawing to nsWindow %p using XRender\n", (void*)this));
+    return MakeUnique<WindowSurfaceXRender>(mXDisplay, mXWindow, mXVisual, mXDepth);
+  }
+#endif // MOZ_WIDGET_GTK
+
+#ifdef MOZ_HAVE_SHMIMAGE
+  if (nsShmImage::UseShm()) {
+    LOGDRAW(("Drawing to nsWindow %p using MIT-SHM\n", (void*)this));
+    return MakeUnique<WindowSurfaceX11SHM>(mXDisplay, mXWindow, mXVisual, mXDepth);
+  }
+#endif // MOZ_HAVE_SHMIMAGE
+
+  LOGDRAW(("Drawing to nsWindow %p using XPutImage\n", (void*)this));
+  return MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
+}
+
+already_AddRefed<gfx::DrawTarget>
+WindowSurfaceProvider::StartRemoteDrawingInRegion(LayoutDeviceIntRegion& aInvalidRegion,
+                                                layers::BufferMode* aBufferMode)
+{
+  if (aInvalidRegion.IsEmpty())
+    return nullptr;
+
+  if (!mWindowSurface) {
+    mWindowSurface = CreateWindowSurface();
+    if (!mWindowSurface)
+      return nullptr;
+  }
+
+  *aBufferMode = BufferMode::BUFFER_NONE;
+  RefPtr<DrawTarget> dt = nullptr;
+  if (!(dt = mWindowSurface->Lock(aInvalidRegion)) &&
+      !mWindowSurface->IsFallback()) {
+    gfxWarningOnce() << "Failed to lock WindowSurface, falling back to XPutImage backend.";
+    mWindowSurface = MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
+    dt = mWindowSurface->Lock(aInvalidRegion);
+  }
+  return dt.forget();
+}
+
+void
+WindowSurfaceProvider::EndRemoteDrawingInRegion(gfx::DrawTarget* aDrawTarget,
+                                              LayoutDeviceIntRegion& aInvalidRegion)
+{
+  if (mWindowSurface)
+    mWindowSurface->Commit(aInvalidRegion);
+}
+
+} // namespace mozilla
+} // namespace widget
diff -rupN a/widget/gtk/WindowSurfaceProvider.cpp.rej b/widget/gtk/WindowSurfaceProvider.cpp.rej
--- a/widget/gtk/WindowSurfaceProvider.cpp.rej	1969-12-31 19:00:00.000000000 -0500
+++ b/widget/gtk/WindowSurfaceProvider.cpp.rej	2017-03-07 23:40:34.290635643 -0500
@@ -0,0 +1,11 @@
+--- widget/gtk/WindowSurfaceProvider.cpp
++++ widget/gtk/WindowSurfaceProvider.cpp
+@@ -117,7 +141,7 @@ WindowSurfaceProvider::StartRemoteDrawingInRegion(LayoutDeviceIntRegion& aInvali
+ 
+   *aBufferMode = BufferMode::BUFFER_NONE;
+   RefPtr<DrawTarget> dt = nullptr;
+-  if (!(dt = mWindowSurface->Lock(aInvalidRegion))) {
++  if (!(dt = mWindowSurface->Lock(aInvalidRegion)) && mIsX11Display) {
+     gfxWarningOnce() << "Failed to lock WindowSurface, falling back to XPutImage backend.";
+     mWindowSurface = MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual, mXDepth);
+   }
diff -rupN a/widget/gtk/WindowSurfaceProvider.h b/widget/gtk/WindowSurfaceProvider.h
--- a/widget/gtk/WindowSurfaceProvider.h	2016-11-14 11:12:28.000000000 -0500
+++ b/widget/gtk/WindowSurfaceProvider.h	2017-03-07 23:41:54.273639927 -0500
@@ -12,8 +12,14 @@
 #include "mozilla/gfx/2D.h"
 #include "Units.h"
 
+#include <gdk/gdk.h>
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
 #include <X11/Xlib.h> // for Window, Display, Visual, etc.
 
+class nsWindow;
+
 namespace mozilla {
 namespace widget {
 
@@ -39,6 +45,12 @@ public:
       Visual* aVisual,
       int aDepth);
 
+#ifdef GDK_WINDOWING_WAYLAND
+   void Initialize(nsWindow *aWidget,
+                   wl_display *aWaylandDisplay,
+                   wl_surface *aWaylandSurface);
+#endif
+
   /**
    * Releases any surfaces created by this provider.
    * This is used by X11CompositorWidget to get rid
@@ -55,12 +67,18 @@ public:
 private:
   UniquePtr<WindowSurface> CreateWindowSurface();
 
-  Display*  mXDisplay;
-  Window    mXWindow;
-  Visual*   mXVisual;
-  int       mXDepth;
-
+  // Can we access X?
+  bool        mIsX11Display;
+  Display*    mXDisplay;
+  Window      mXWindow;
+  Visual*     mXVisual;
+  int         mXDepth;
   UniquePtr<WindowSurface> mWindowSurface;
+#ifdef GDK_WINDOWING_WAYLAND
+  nsWindow*   mWidget;
+  wl_display* mWaylandDisplay;
+  wl_surface* mWaylandSurface;
+#endif
 };
 
 }  // namespace widget
diff -rupN a/widget/gtk/WindowSurfaceWayland.cpp b/widget/gtk/WindowSurfaceWayland.cpp
--- a/widget/gtk/WindowSurfaceWayland.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/widget/gtk/WindowSurfaceWayland.cpp	2017-03-07 23:43:20.977644571 -0500
@@ -0,0 +1,536 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/*
+ * Derived from Weston project,
+ * https://github.com/wayland-project/weston/blob/master/clients/simple-shm.c
+ */
+/*
+TODO:
+moz-container -> display check
+X11CompositorWidget - update
+nsWindow::GetCompositorWidgetInitData
+GDK_WINDOWING_X11 - remove
+#ifdef GDK_WINDOWING_WAYLAND + display test
+- ensure we always draw to container
+- surface cleaning/realocation
+- can we redraw on allocate?
+- create subsurface on show
+- share fd/pool with more buffers?
+- resize (pool size) optimization
+- pool of available buffers?
+- call wayland display/queue events right after attach&co?
+- optimization -> use Image bufer when update area is smaller that whole window
+- is bounds.x bounds.y non-zero??
+- buffer sync - can be undamaged part unsynced?
+- GdkWidnow - show/hide -> callback, get surface and frame callback
+- optimization - give backbuffer directly when requested whole area in Lock()
+- how big is rectangle owerlap in BackBufferWayland::CopyRectangle()?
+(firefox:15155): Gdk-WARNING **: Tried to map a popup with a non-top most parent
+  - it was ok in X11
+*/
+#include <assert.h>
+#include <poll.h>
+
+#include "WindowSurfaceWayland.h"
+
+#include "mozilla/gfx/2D.h"
+#include "mozilla/gfx/Tools.h"
+#include "gfxPlatform.h"
+#include "os-compatibility.h"
+
+#ifdef GDK_WINDOWING_WAYLAND
+#include <gdk/gdkwayland.h>
+#endif
+#include <sys/mman.h>
+#include <fcntl.h>
+
+namespace mozilla {
+namespace widget {
+
+bool                WindowSurfaceWayland::mIsAvailable;
+bool                WindowSurfaceWayland::mInitialized;
+gfx::SurfaceFormat  WindowSurfaceWayland::mFormat = gfx::SurfaceFormat::UNKNOWN;
+wl_shm*             WindowSurfaceWayland::mShm;
+wl_event_queue*     WindowSurfaceWayland::mQueue;
+GThread*            WindowSurfaceWayland::mThread;
+wl_display*         WindowSurfaceWayland::mDisplay;
+
+ImageBuffer::ImageBuffer()
+  : mBufferData(nullptr)
+  , mBufferAllocated(0)
+  , mWidth(0)
+  , mHeight(0)
+{
+}
+
+ImageBuffer::~ImageBuffer()
+{
+  if (mBufferData)
+    free(mBufferData);
+}
+
+already_AddRefed<gfx::DrawTarget>
+ImageBuffer::Lock(const LayoutDeviceIntRegion& aRegion)
+{    
+  gfx::IntRect bounds = aRegion.GetBounds().ToUnknownRect();
+  gfx::IntSize imageSize(bounds.XMost(), bounds.YMost());
+
+  // We use the same trick as nsShmImage::CreateDrawTarget() does:
+  // Due to bug 1205045, we must avoid making GTK calls off the main thread
+  // to query window size.
+  // Instead we just track the largest offset within the image we are
+  // drawing to and grow the image to accomodate it. Since usually
+  // the entire window is invalidated on the first paint to it,
+  // this should grow the image to the necessary size quickly without
+  // many intermediate reallocations.
+  int newSize = imageSize.width * imageSize.height * BUFFER_BPP;
+  if (!mBufferData || mBufferAllocated < newSize) {
+    if (mBufferData) {
+      free(mBufferData);
+    }
+    
+    mBufferData = (unsigned char*)malloc(newSize);
+    if (!mBufferData)
+      return nullptr;
+    
+    mBufferAllocated = newSize;
+  }
+
+  mWidth = imageSize.width;
+  mHeight = imageSize.height;
+
+  return gfxPlatform::CreateDrawTargetForData(mBufferData, imageSize,
+    BUFFER_BPP * mWidth, WindowSurfaceWayland::GetSurfaceFormat());
+}
+
+bool BackBufferWayland::CreateShmPool(int aSize)
+{
+  mAllocatedSize = aSize;
+
+  mShmPoolFd = os_create_anonymous_file(mAllocatedSize);
+  if (mShmPoolFd < 0)
+    return false;
+
+  mBufferData = mmap(nullptr, mAllocatedSize,
+                     PROT_READ | PROT_WRITE, MAP_SHARED, mShmPoolFd, 0);
+  if (mBufferData == MAP_FAILED) {
+    close(mShmPoolFd);
+    mShmPoolFd = 0;
+    return false;
+  }
+
+  mShmPool = wl_shm_create_pool(WindowSurfaceWayland::GetShm(),
+                                mShmPoolFd, mAllocatedSize);
+  wl_proxy_set_queue((struct wl_proxy *)mShmPool,
+                     WindowSurfaceWayland::GetQueue());
+                                
+  return true;
+}
+
+bool BackBufferWayland::ResizeShmPool(int aSize)
+{
+  // We do size increase only
+  if (aSize <= mAllocatedSize)
+    return true;
+
+  if (ftruncate(mShmPoolFd, aSize) < 0)
+    return false;
+
+#ifdef HAVE_POSIX_FALLOCATE
+  errno = posix_fallocate(mShmPoolFd, 0, aSize);
+  if (errno != 0)
+    return false;
+#endif
+
+  wl_shm_pool_resize(mShmPool, aSize);
+
+  munmap(mBufferData, mAllocatedSize);
+
+  mBufferData = mmap(nullptr, aSize,
+                     PROT_READ | PROT_WRITE, MAP_SHARED, mShmPoolFd, 0);
+  if (mBufferData == MAP_FAILED)
+    return false;
+
+  mAllocatedSize = aSize;
+  return true;
+}
+
+void BackBufferWayland::ReleaseShmPool()
+{
+  munmap(mBufferData, mAllocatedSize);
+  wl_shm_pool_destroy(mShmPool);
+  close(mShmPoolFd);
+
+  mBufferData = nullptr;
+  mAllocatedSize = 0;
+}
+
+static void
+buffer_release(void *data, wl_buffer *buffer)
+{  
+  auto surface = reinterpret_cast<BackBufferWayland*>(data);
+  surface->Detach();
+}
+
+static const struct wl_buffer_listener buffer_listener = {
+  buffer_release
+};
+
+void BackBufferWayland::CreateBuffer(int aWidth, int aHeight)
+{
+  mBuffer = wl_shm_pool_create_buffer(mShmPool, 0,
+                              			  aWidth, aHeight, aWidth*BUFFER_BPP,
+                              			  WL_SHM_FORMAT_ARGB8888);
+  wl_proxy_set_queue((struct wl_proxy *)mBuffer,
+                     WindowSurfaceWayland::GetQueue());
+  wl_buffer_add_listener(mBuffer, &buffer_listener, this);
+
+  mWidth = aWidth;
+  mHeight = aHeight;
+}
+
+void BackBufferWayland::ReleaseBuffer()
+{
+  wl_buffer_destroy(mBuffer);
+  mWidth = mHeight = 0;
+}
+
+BackBufferWayland::BackBufferWayland(int aWidth, int aHeight)
+ : mShmPool(nullptr)
+  ,mShmPoolFd(0)
+  ,mAllocatedSize(0)
+  ,mBuffer(nullptr)
+  ,mBufferData(nullptr)
+  ,mWidth(aWidth)
+  ,mHeight(aHeight)
+  ,mAttached(false)
+{
+  if(CreateShmPool(aWidth*aHeight*BUFFER_BPP)) {
+    CreateBuffer(aWidth, aHeight);
+  } else
+    assert(0);
+}
+
+BackBufferWayland::~BackBufferWayland()
+{
+  ReleaseBuffer();
+  ReleaseShmPool();
+}
+
+bool
+BackBufferWayland::Resize(int aWidth, int aHeight)
+{
+  if (aWidth == mWidth && aHeight == mHeight)
+    return true;
+
+  fprintf(stderr, "BackBufferResize, %dx%d -> %dx%d",
+          mWidth, mHeight, aWidth, aHeight);
+  ReleaseBuffer();
+
+  int newSize = aWidth*aHeight*BUFFER_BPP;
+  if (newSize > mAllocatedSize)
+    ResizeShmPool(newSize);
+
+  CreateBuffer(aWidth, aHeight);
+  return (mBuffer != nullptr);
+}
+
+// Update back buffer with image data from ImageBuffer
+void
+BackBufferWayland::CopyRectangle(ImageBuffer *aImage,
+                                 const mozilla::LayoutDeviceIntRect &rect)
+{
+  mozilla::LayoutDeviceIntRect r = rect;
+
+  if (r.x + r.width > mWidth)
+    r.width = mWidth - r.x;
+  if (r.y + r.height > mHeight)
+    r.height = mHeight - r.y;
+
+  for (int y = r.y; y < r.y + r.height; y++) {
+    int start = (y * mWidth + r.x) * BUFFER_BPP;
+    int lenght = r.width * BUFFER_BPP;
+    memcpy((unsigned char *)mBufferData + start,
+            aImage->GetData() + ((y * aImage->mWidth) + r.x) * BUFFER_BPP,
+            lenght);
+  }
+}
+
+void
+BackBufferWayland::Attach(wl_surface* aSurface)
+{
+  // Taken from Hybris project:
+  // Some compositors, namely Weston, queue buffer release events instead
+  // of sending them immediately.  If a frame event is used, this should
+  // not be a problem.  Without a frame event, we need to send a sync
+  // request to ensure that they get flushed.    
+  //wl_callback_destroy(wl_display_sync(WindowSurfaceWayland::GetDisplay()));
+  
+  wl_surface_attach(aSurface, mBuffer, 0, 0);
+  wl_surface_commit(aSurface);
+  wl_display_flush(WindowSurfaceWayland::GetDisplay());
+  mAttached = true;
+}
+
+void
+BackBufferWayland::Detach()
+{
+  mAttached = false;
+}
+
+bool BackBufferWayland::Sync(class BackBufferWayland* aSourceBuffer)
+{
+  bool bufferSizeMatches = MatchSize(aSourceBuffer);
+  if (!bufferSizeMatches) {
+    Resize(aSourceBuffer->mWidth, aSourceBuffer->mHeight);
+  }
+
+  memcpy(mBufferData, aSourceBuffer->mBufferData,
+         aSourceBuffer->mWidth * aSourceBuffer->mHeight * BUFFER_BPP);
+  return true;
+}
+
+void
+WindowSurfaceWayland::SetWaylandPixelFormat(uint32_t format)
+{
+  switch (format) {
+    case WL_SHM_FORMAT_ARGB8888:
+      mFormat = gfx::SurfaceFormat::B8G8R8A8;
+      break;
+    case WL_SHM_FORMAT_XRGB8888:
+      // TODO - We can use non-alpha formats when we need that
+    default:
+      break;
+  }
+}
+
+static void
+shm_format(void *data, wl_shm *wl_shm, uint32_t format)
+{
+  auto interface = reinterpret_cast<WindowSurfaceWayland *>(data);
+  interface->SetWaylandPixelFormat(format);
+ }
+
+struct wl_shm_listener shm_listener = {
+	shm_format
+};
+
+static void
+global_registry_handler(void *data, wl_registry *registry, uint32_t id,
+	                      const char *interface, uint32_t version)
+{
+  if (strcmp(interface, "wl_shm") == 0) {
+    auto shm = static_cast<wl_shm*>(
+        wl_registry_bind(registry, id, &wl_shm_interface, 1));
+    wl_proxy_set_queue((struct wl_proxy *)shm, WindowSurfaceWayland::GetQueue());
+    wl_shm_add_listener(shm, &shm_listener, NULL);
+    auto interface = reinterpret_cast<WindowSurfaceWayland *>(data);
+    interface->SetShm(shm);
+  }
+}
+
+static void
+global_registry_remover(void *data, wl_registry *registry, uint32_t id)
+{
+}
+
+static const struct wl_registry_listener registry_listener = {
+  global_registry_handler,
+  global_registry_remover
+};
+
+static gpointer
+gst_wl_display_thread_run (gpointer data)
+{
+  struct pollfd fds;
+  fds.fd = wl_display_get_fd (WindowSurfaceWayland::GetDisplay());
+  fds.events = POLLIN;
+
+  /* main loop */
+  while (1) {
+    while (wl_display_prepare_read_queue (WindowSurfaceWayland::GetDisplay(),
+                                          WindowSurfaceWayland::GetQueue()) < 0) {
+      wl_display_dispatch_queue_pending (WindowSurfaceWayland::GetDisplay(),
+                                         WindowSurfaceWayland::GetQueue());
+    }
+    wl_display_flush (WindowSurfaceWayland::GetDisplay());
+
+    int ret = poll(&fds, 1, -1);
+    if (ret == -1) {
+      wl_display_cancel_read(WindowSurfaceWayland::GetDisplay());
+      break;
+    }
+    wl_display_read_events(WindowSurfaceWayland::GetDisplay());
+    wl_display_dispatch_queue_pending (WindowSurfaceWayland::GetDisplay(), 
+                                       WindowSurfaceWayland::GetQueue());
+  }
+
+  return NULL;
+}
+
+extern "C" {
+struct wl_event_queue* moz_container_get_wl_queue();
+}
+
+static void
+redraw(void *data, struct wl_callback *callback, uint32_t time)
+{
+    auto surface = reinterpret_cast<WindowSurfaceWayland*>(data);
+    surface->Draw();
+}
+
+static const struct wl_callback_listener frame_listener = {
+    redraw
+};
+
+void
+WindowSurfaceWayland::Init()
+{
+  // Try to initialize only once
+  if (mInitialized)
+    return;
+  mInitialized = true;
+  
+  mQueue = moz_container_get_wl_queue();
+
+  // wl_shm and wl_subcompositor are not provided by Gtk so we need
+  // to query wayland directly
+  wl_registry* registry = wl_display_get_registry(mDisplay);
+  wl_proxy_set_queue((struct wl_proxy *)registry, mQueue);
+  wl_registry_add_listener(registry,
+                           &registry_listener, nullptr);
+
+  // We need two roundtrips here to get the registry info
+  wl_display_dispatch_queue(mDisplay, mQueue);
+  wl_display_roundtrip_queue(mDisplay, mQueue);
+  wl_display_roundtrip_queue(mDisplay, mQueue);
+
+  // We should have a valid pixel format now
+  mIsAvailable = (mFormat != gfx::SurfaceFormat::UNKNOWN);
+  NS_ASSERTION(mIsAvailable, "We don't have any pixel format!");
+  
+  assert(mFormat != gfx::SurfaceFormat::UNKNOWN);
+
+  GError *err = nullptr;
+  mThread = g_thread_try_new ("GstWlDisplay", gst_wl_display_thread_run,
+                              this, &err);
+}
+
+WindowSurfaceWayland::WindowSurfaceWayland(nsWindow *aWidget,
+                                           wl_display *aDisplay,
+                                           wl_surface *aSurface)
+  : mWidget(aWidget)
+  , mSurface(aSurface)
+  , mFrontBuffer(nullptr)
+  , mBackBuffer(nullptr)
+  , mFrameCallback(nullptr)
+  , mDelayedCommit(false)
+{
+  NS_ASSERTION(mSurface != nullptr,
+               "Missing Wayland surfaces to draw to!");
+
+  mDisplay = aDisplay;
+  Init();
+  wl_proxy_set_queue((struct wl_proxy *)mSurface, mQueue);    
+}
+
+WindowSurfaceWayland::~WindowSurfaceWayland()
+{
+  // TODO - free registry, buffers etc.
+}
+
+BackBufferWayland*
+WindowSurfaceWayland::GetBufferToDraw(int aWidth, int aHeight)
+{
+  if (!mFrontBuffer) {
+    mFrontBuffer = new BackBufferWayland(aWidth, aHeight);
+    mBackBuffer = new BackBufferWayland(aWidth, aHeight);  
+  } else {
+    if (mFrontBuffer->IsAttached()) {
+      if (mBackBuffer->IsAttached()) {
+        NS_ASSERTION(!mBackBuffer->IsAttached(), "We don't have any buffer to draw to!");
+        return nullptr;
+      }
+      
+      BackBufferWayland *tmp = mFrontBuffer;
+      mFrontBuffer = mBackBuffer;
+      mBackBuffer = tmp;
+
+      mFrontBuffer->Sync(mBackBuffer);
+      
+      // TODO (https://bugzilla.redhat.com/show_bug.cgi?id=1418260)
+      wl_surface_damage(mSurface, 0, 0, aWidth, aHeight);
+    }
+
+    if (!mFrontBuffer->MatchSize(aWidth, aHeight)) {
+      mFrontBuffer->Resize(aWidth, aHeight);
+    }
+  }
+
+  return mFrontBuffer;
+}
+
+already_AddRefed<gfx::DrawTarget>
+WindowSurfaceWayland::Lock(const LayoutDeviceIntRegion& aRegion)
+{
+  return mImageBuffer.Lock(aRegion);
+}
+
+void
+WindowSurfaceWayland::Commit(const LayoutDeviceIntRegion& aInvalidRegion)
+{
+  gfx::IntRect bounds = aInvalidRegion.GetBounds().ToUnknownRect();
+  gfx::IntSize bufferSize(bounds.XMost(), bounds.YMost());
+
+  LayoutDeviceIntRect rect = mWidget->GetBounds();
+  BackBufferWayland* buffer = GetBufferToDraw(rect.width,
+                                              rect.height);
+  NS_ASSERTION(buffer, "We don't have any buffer to draw to!");
+  if (!buffer)
+    return;
+
+  for (auto iter = aInvalidRegion.RectIter(); !iter.Done(); iter.Next()) {
+    const mozilla::LayoutDeviceIntRect &r = iter.Get();
+    buffer->CopyRectangle(&mImageBuffer, r);
+    wl_surface_damage(mSurface, r.x, r.y, r.width, r.height);
+  }
+
+  if (mFrameCallback) {
+    // Do nothing here - buffer will be commited to compositor
+    // in next frame callback event.
+    mDelayedCommit = true;
+    return;
+  } else  {
+    mFrameCallback = wl_surface_frame(mSurface);
+    wl_callback_add_listener(mFrameCallback, &frame_listener, this);
+
+    // There's no pending frame callback so we can draw immediately
+    // and create frame callback for possible subsequent drawing.
+    mFrontBuffer->Attach(mSurface);
+    mDelayedCommit = false;
+  }
+}
+
+void
+WindowSurfaceWayland::Draw()
+{
+  if (mFrameCallback) {
+      wl_callback_destroy(mFrameCallback);
+      mFrameCallback = nullptr;
+  }
+
+  if (mDelayedCommit) {
+    mFrameCallback = wl_surface_frame(mSurface);
+    wl_callback_add_listener(mFrameCallback, &frame_listener, this);
+
+    mFrontBuffer->Attach(mSurface);
+    mDelayedCommit = false;
+  }
+}
+
+}  // namespace widget
+}  // namespace mozilla
diff -rupN a/widget/gtk/WindowSurfaceWayland.h b/widget/gtk/WindowSurfaceWayland.h
--- a/widget/gtk/WindowSurfaceWayland.h	1969-12-31 19:00:00.000000000 -0500
+++ b/widget/gtk/WindowSurfaceWayland.h	2017-03-08 02:06:18.536365174 -0500
@@ -0,0 +1,132 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
+#define _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
+
+namespace mozilla {
+namespace widget {
+
+// We support only 32bpp formats
+#define BUFFER_BPP 4
+
+// Image surface which holds actual drawing to back buffer,
+// it is commited to BackBufferWayland
+class ImageBuffer {
+friend class BackBufferWayland;
+public:
+  ImageBuffer();
+  ~ImageBuffer();
+
+  already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion);
+  unsigned char* GetData() { return mBufferData; };
+
+private:
+  unsigned char*     mBufferData;
+  int                mBufferAllocated;
+  int                mWidth;
+  int                mHeight;
+};
+
+// Holds actual graphics data for wl_surface
+class BackBufferWayland {
+public:
+  BackBufferWayland(int aWidth, int aHeight);
+  ~BackBufferWayland();
+
+  void CopyRectangle(ImageBuffer *aImage,
+                     const mozilla::LayoutDeviceIntRect &rect);
+  
+  void Attach(wl_surface* aSurface);
+  void Detach();
+  bool IsAttached() { return mAttached; }
+
+  bool Resize(int aWidth, int aHeight);
+  bool Sync(class BackBufferWayland* aSourceBuffer);
+  
+  bool MatchSize(int aWidth, int aHeight) 
+  {
+    return aWidth == mWidth && aHeight == mHeight;
+  }
+  bool MatchSize(class BackBufferWayland *aBuffer) 
+  {
+    return aBuffer->mWidth == mWidth && aBuffer->mHeight == mHeight; 
+  }
+ 
+  bool MatchAllocatedSize(int aSize)
+  {
+    return aSize <= mAllocatedSize; 
+  }
+  
+private:
+  bool CreateShmPool(int aSize);
+  bool ResizeShmPool(int aSize);
+  void ReleaseShmPool(void);
+
+  void CreateBuffer(int aWidth, int aHeight);
+  void ReleaseBuffer();
+
+  wl_shm_pool*       mShmPool;
+  int                mShmPoolFd;
+  int                mAllocatedSize;
+  wl_buffer*         mBuffer;
+  void*              mBufferData;
+  int                mWidth;
+  int                mHeight;
+  bool               mAttached;
+};
+
+// WindowSurfaceWayland is an abstraction for wl_surface
+// and related management
+class WindowSurfaceWayland : public WindowSurface {
+public:
+  WindowSurfaceWayland(nsWindow *aWidget, wl_display *aDisplay, wl_surface *aSurface);
+  ~WindowSurfaceWayland();
+
+  already_AddRefed<gfx::DrawTarget> Lock(const LayoutDeviceIntRegion& aRegion) override;
+  void                      Commit(const LayoutDeviceIntRegion& aInvalidRegion) final;
+  void                      Draw();
+
+  static void               SetShm(wl_shm* aShm) { mShm = aShm; };
+  static wl_shm*            GetShm() { return(mShm); };
+  static wl_event_queue*    GetQueue() { return mQueue; };
+  static wl_display*        GetDisplay() { return mDisplay; };
+  static void               SetWaylandPixelFormat(uint32_t format);
+  static gfx::SurfaceFormat GetSurfaceFormat() { return mFormat; };
+
+private:
+  BackBufferWayland*        GetBufferToDraw(int aWidth, int aHeight);
+  void                      Init();
+
+  static bool               mIsAvailable;
+  static bool               mInitialized;
+  static gfx::SurfaceFormat mFormat;
+  static wl_shm*            mShm;
+  static wl_event_queue*    mQueue;
+  static GThread*           mThread;
+  static wl_display*        mDisplay;
+
+  nsWindow*                 mWidget;
+  
+  // The surface size is dynamically allocated by Commit() call,
+  // we store the latest size request here to optimize 
+  // buffer usage and our gfx operations
+  wl_surface*               mSurface;
+  int                       mWidth;
+  int                       mHeight;
+
+  ImageBuffer               mImageBuffer;
+  
+  BackBufferWayland*        mFrontBuffer;
+  BackBufferWayland*        mBackBuffer;
+  wl_callback*              mFrameCallback;
+  bool                      mDelayedCommit;
+};
+
+}  // namespace widget
+}  // namespace mozilla
+
+#endif // _MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
diff -rupN a/widget/gtk/X11CompositorWidget.cpp b/widget/gtk/X11CompositorWidget.cpp
--- a/widget/gtk/X11CompositorWidget.cpp	2016-11-14 11:12:28.000000000 -0500
+++ b/widget/gtk/X11CompositorWidget.cpp	2017-03-07 23:42:23.681641502 -0500
@@ -21,27 +21,39 @@ X11CompositorWidget::X11CompositorWidget
   // If we have a nsWindow, then grab the already existing display connection
   // If we don't, then use the init data to connect to the display
   if (aWindow) {
-    mXDisplay = aWindow->XDisplay();
+    mIsX11Display = aWindow->IsX11Display();
+    if (mIsX11Display) {
+      mXDisplay = aWindow->XDisplay();
+    } else {
+      mWaylandDisplay = aWindow->WaylandDisplay();
+    }
   } else {
+    // TODO - not implemented
+    abort();
     mXDisplay = XOpenDisplay(aInitData.XDisplayString().get());
-  }
-  mXWindow = (Window)aInitData.XWindow();
-
-  // Grab the window's visual and depth
-  XWindowAttributes windowAttrs;
-  XGetWindowAttributes(mXDisplay, mXWindow, &windowAttrs);
+  }  
+  
+  if (mIsX11Display) {
+    mXWindow = (Window)aInitData.XWindow();
 
-  Visual*   visual = windowAttrs.visual;
-  int       depth = windowAttrs.depth;
+    // Grab the window's visual and depth
+    XWindowAttributes windowAttrs;
+    XGetWindowAttributes(mXDisplay, mXWindow, &windowAttrs);
 
-  // Initialize the window surface provider
-  mProvider.Initialize(
-    mXDisplay,
-    mXWindow,
-    visual,
-    depth
-    );
+    Visual*   visual = windowAttrs.visual;
+    int       depth = windowAttrs.depth;
 
+    // Initialize the window surface provider
+    mProvider.Initialize(
+      mXDisplay,
+      mXWindow,
+      visual,
+      depth
+      );
+  } else {
+    mWaylandSurface = (wl_surface *)aInitData.XWindow();
+    mProvider.Initialize(aWindow, mWaylandDisplay, mWaylandSurface);
+  }
   mClientSize = aInitData.InitialClientSize();
 }
 
diff -rupN a/widget/gtk/X11CompositorWidget.h b/widget/gtk/X11CompositorWidget.h
--- a/widget/gtk/X11CompositorWidget.h	2016-11-14 11:12:28.000000000 -0500
+++ b/widget/gtk/X11CompositorWidget.h	2017-03-07 23:40:34.291635643 -0500
@@ -58,8 +58,13 @@ protected:
 private:
   LayoutDeviceIntSize mClientSize;
 
+  bool     mIsX11Display;
   Display* mXDisplay;
   Window   mXWindow;
+#ifdef GDK_WINDOWING_WAYLAND
+  wl_display* mWaylandDisplay;
+  wl_surface* mWaylandSurface;
+#endif  
   WindowSurfaceProvider mProvider;
 };
 
diff -rupN a/widget/nsBaseWidget.cpp b/widget/nsBaseWidget.cpp
--- a/widget/nsBaseWidget.cpp	2017-01-23 11:13:56.000000000 -0500
+++ b/widget/nsBaseWidget.cpp	2017-03-07 23:41:13.545637745 -0500
@@ -1407,6 +1407,7 @@ void nsBaseWidget::NotifyRemoteComposito
 bool nsBaseWidget::ShouldUseOffMainThreadCompositing()
 {
   return gfxPlatform::UsesOffMainThreadCompositing();
+  //return false;
 }
 
 LayerManager* nsBaseWidget::GetLayerManager(PLayerTransactionChild* aShadowManager,
diff -rupN a/widget/nsBaseWidget.cpp.orig b/widget/nsBaseWidget.cpp.orig
--- a/widget/nsBaseWidget.cpp.orig	1969-12-31 19:00:00.000000000 -0500
+++ b/widget/nsBaseWidget.cpp.orig	2017-03-07 23:40:34.293635643 -0500
@@ -0,0 +1,3326 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/UniquePtr.h"
+#include "mozilla/TextEventDispatcher.h"
+#include "mozilla/TextEventDispatcherListener.h"
+
+#include "mozilla/layers/CompositorBridgeChild.h"
+#include "mozilla/layers/CompositorBridgeParent.h"
+#include "mozilla/layers/ImageBridgeChild.h"
+#include "nsBaseWidget.h"
+#include "nsDeviceContext.h"
+#include "nsCOMPtr.h"
+#include "nsGfxCIID.h"
+#include "nsWidgetsCID.h"
+#include "nsServiceManagerUtils.h"
+#include "nsIKeyEventInPluginCallback.h"
+#include "nsIScreenManager.h"
+#include "nsAppDirectoryServiceDefs.h"
+#include "nsISimpleEnumerator.h"
+#include "nsIContent.h"
+#include "nsIDocument.h"
+#include "nsIPresShell.h"
+#include "nsIServiceManager.h"
+#include "mozilla/Preferences.h"
+#include "BasicLayers.h"
+#include "ClientLayerManager.h"
+#include "mozilla/layers/Compositor.h"
+#include "nsIXULRuntime.h"
+#include "nsIXULWindow.h"
+#include "nsIBaseWindow.h"
+#include "nsXULPopupManager.h"
+#include "nsIWidgetListener.h"
+#include "nsIGfxInfo.h"
+#include "npapi.h"
+#include "X11UndefineNone.h"
+#include "base/thread.h"
+#include "prdtoa.h"
+#include "prenv.h"
+#include "mozilla/Attributes.h"
+#include "mozilla/Unused.h"
+#include "nsContentUtils.h"
+#include "gfxPrefs.h"
+#include "mozilla/gfx/2D.h"
+#include "mozilla/MouseEvents.h"
+#include "GLConsts.h"
+#include "mozilla/Unused.h"
+#include "mozilla/IMEStateManager.h"
+#include "mozilla/VsyncDispatcher.h"
+#include "mozilla/layers/IAPZCTreeManager.h"
+#include "mozilla/layers/APZEventState.h"
+#include "mozilla/layers/APZThreadUtils.h"
+#include "mozilla/layers/ChromeProcessController.h"
+#include "mozilla/layers/InputAPZContext.h"
+#include "mozilla/layers/APZCCallbackHelper.h"
+#include "mozilla/dom/ContentChild.h"
+#include "mozilla/dom/TabParent.h"
+#include "mozilla/gfx/GPUProcessManager.h"
+#include "mozilla/Move.h"
+#include "mozilla/Services.h"
+#include "mozilla/Sprintf.h"
+#include "nsRefPtrHashtable.h"
+#include "TouchEvents.h"
+#include "WritingModes.h"
+#include "InputData.h"
+#include "FrameLayerBuilder.h"
+#ifdef ACCESSIBILITY
+#include "nsAccessibilityService.h"
+#endif
+#include "gfxConfig.h"
+#include "mozilla/layers/CompositorSession.h"
+#include "VRManagerChild.h"
+
+#ifdef DEBUG
+#include "nsIObserver.h"
+
+static void debug_RegisterPrefCallbacks();
+
+#endif
+
+#ifdef NOISY_WIDGET_LEAKS
+static int32_t gNumWidgets;
+#endif
+
+#ifdef XP_MACOSX
+#include "nsCocoaFeatures.h"
+#endif
+
+#if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
+static nsRefPtrHashtable<nsVoidPtrHashKey, nsIWidget>* sPluginWidgetList;
+#endif
+
+nsIRollupListener* nsBaseWidget::gRollupListener = nullptr;
+
+using namespace mozilla::dom;
+using namespace mozilla::layers;
+using namespace mozilla::ipc;
+using namespace mozilla::widget;
+using namespace mozilla;
+using base::Thread;
+
+nsIContent* nsBaseWidget::mLastRollup = nullptr;
+// Global user preference for disabling native theme. Used
+// in NativeWindowTheme.
+bool            gDisableNativeTheme               = false;
+
+// Async pump timer during injected long touch taps
+#define TOUCH_INJECT_PUMP_TIMER_MSEC 50
+#define TOUCH_INJECT_LONG_TAP_DEFAULT_MSEC 1500
+int32_t nsIWidget::sPointerIdCounter = 0;
+
+// Some statics from nsIWidget.h
+/*static*/ uint64_t AutoObserverNotifier::sObserverId = 0;
+/*static*/ nsDataHashtable<nsUint64HashKey, nsCOMPtr<nsIObserver>> AutoObserverNotifier::sSavedObservers;
+
+namespace mozilla {
+namespace widget {
+
+void
+IMENotification::SelectionChangeDataBase::SetWritingMode(
+                                        const WritingMode& aWritingMode)
+{
+  mWritingMode = aWritingMode.mWritingMode;
+}
+
+WritingMode
+IMENotification::SelectionChangeDataBase::GetWritingMode() const
+{
+  return WritingMode(mWritingMode);
+}
+
+} // namespace widget
+} // namespace mozilla
+
+nsAutoRollup::nsAutoRollup()
+{
+  // remember if mLastRollup was null, and only clear it upon destruction
+  // if so. This prevents recursive usage of nsAutoRollup from clearing
+  // mLastRollup when it shouldn't.
+  wasClear = !nsBaseWidget::mLastRollup;
+}
+
+nsAutoRollup::~nsAutoRollup()
+{
+  if (nsBaseWidget::mLastRollup && wasClear) {
+    NS_RELEASE(nsBaseWidget::mLastRollup);
+  }
+}
+
+NS_IMPL_ISUPPORTS(nsBaseWidget, nsIWidget, nsISupportsWeakReference)
+
+//-------------------------------------------------------------------------
+//
+// nsBaseWidget constructor
+//
+//-------------------------------------------------------------------------
+
+nsBaseWidget::nsBaseWidget()
+: mWidgetListener(nullptr)
+, mAttachedWidgetListener(nullptr)
+, mPreviouslyAttachedWidgetListener(nullptr)
+, mLayerManager(nullptr)
+, mCompositorVsyncDispatcher(nullptr)
+, mCursor(eCursor_standard)
+, mBorderStyle(eBorderStyle_none)
+, mBounds(0,0,0,0)
+, mOriginalBounds(nullptr)
+, mClipRectCount(0)
+, mSizeMode(nsSizeMode_Normal)
+, mPopupLevel(ePopupLevelTop)
+, mPopupType(ePopupTypeAny)
+, mCompositorWidgetDelegate(nullptr)
+, mUpdateCursor(true)
+, mUseAttachedEvents(false)
+, mIMEHasFocus(false)
+#if defined(XP_WIN) || defined(XP_MACOSX) || defined(MOZ_WIDGET_GTK)
+, mAccessibilityInUseFlag(false)
+#endif
+{
+#ifdef NOISY_WIDGET_LEAKS
+  gNumWidgets++;
+  printf("WIDGETS+ = %d\n", gNumWidgets);
+#endif
+
+#ifdef DEBUG
+  debug_RegisterPrefCallbacks();
+#endif
+
+#if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
+  if (!sPluginWidgetList) {
+    sPluginWidgetList = new nsRefPtrHashtable<nsVoidPtrHashKey, nsIWidget>();
+  }
+#endif
+  mShutdownObserver = new WidgetShutdownObserver(this);
+}
+
+NS_IMPL_ISUPPORTS(WidgetShutdownObserver, nsIObserver)
+
+WidgetShutdownObserver::WidgetShutdownObserver(nsBaseWidget* aWidget) :
+  mWidget(aWidget),
+  mRegistered(false)
+{
+  Register();
+}
+
+WidgetShutdownObserver::~WidgetShutdownObserver()
+{
+  // No need to call Unregister(), we can't be destroyed until nsBaseWidget
+  // gets torn down. The observer service and nsBaseWidget have a ref on us
+  // so nsBaseWidget has to call Unregister and then clear its ref.
+}
+
+NS_IMETHODIMP
+WidgetShutdownObserver::Observe(nsISupports *aSubject,
+                                const char *aTopic,
+                                const char16_t *aData)
+{
+  if (mWidget && !strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)) {
+    RefPtr<nsBaseWidget> widget(mWidget);
+    widget->Shutdown();
+  }
+  return NS_OK;
+}
+
+void
+WidgetShutdownObserver::Register()
+{
+  if (!mRegistered) {
+    mRegistered = true;
+    nsContentUtils::RegisterShutdownObserver(this);
+  }
+}
+
+void
+WidgetShutdownObserver::Unregister()
+{
+  if (mRegistered) {
+    mWidget = nullptr;
+    nsContentUtils::UnregisterShutdownObserver(this);
+    mRegistered = false;
+  }
+}
+
+void
+nsBaseWidget::Shutdown()
+{
+  RevokeTransactionIdAllocator();
+  DestroyCompositor();
+  FreeShutdownObserver();
+#if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
+  if (sPluginWidgetList) {
+    delete sPluginWidgetList;
+    sPluginWidgetList = nullptr;
+  }
+#endif
+}
+
+void nsBaseWidget::DestroyCompositor()
+{
+  // We release this before releasing the compositor, since it may hold the
+  // last reference to our ClientLayerManager. ClientLayerManager's dtor can
+  // trigger a paint, creating a new compositor, and we don't want to re-use
+  // the old vsync dispatcher.
+  if (mCompositorVsyncDispatcher) {
+    mCompositorVsyncDispatcher->Shutdown();
+    mCompositorVsyncDispatcher = nullptr;
+  }
+
+  // The compositor shutdown sequence looks like this:
+  //  1. CompositorSession calls CompositorBridgeChild::Destroy.
+  //  2. CompositorBridgeChild synchronously sends WillClose.
+  //  3. CompositorBridgeParent releases some resources (such as the layer
+  //     manager, compositor, and widget).
+  //  4. CompositorBridgeChild::Destroy returns.
+  //  5. Asynchronously, CompositorBridgeParent::ActorDestroy will fire on the
+  //     compositor thread when the I/O thread closes the IPC channel.
+  //  6. Step 5 will schedule DeferredDestroy on the compositor thread, which
+  //     releases the reference CompositorBridgeParent holds to itself.
+  //
+  // When CompositorSession::Shutdown returns, we assume the compositor is gone
+  // or will be gone very soon.
+  if (mCompositorSession) {
+    ReleaseContentController();
+    mAPZC = nullptr;
+    mCompositorWidgetDelegate = nullptr;
+    mCompositorBridgeChild = nullptr;
+
+    // XXX CompositorBridgeChild and CompositorBridgeParent might be re-created in
+    // ClientLayerManager destructor. See bug 1133426.
+    RefPtr<CompositorSession> session = mCompositorSession.forget();
+    session->Shutdown();
+  }
+}
+
+// This prevents the layer manager from starting a new transaction during
+// shutdown.
+void
+nsBaseWidget::RevokeTransactionIdAllocator()
+{
+  if (!mLayerManager) {
+    return;
+  }
+
+  ClientLayerManager* clm = mLayerManager->AsClientLayerManager();
+  if (!clm) {
+    return;
+  }
+
+  clm->SetTransactionIdAllocator(nullptr);
+}
+
+void nsBaseWidget::ReleaseContentController()
+{
+  if (mRootContentController) {
+    mRootContentController->Destroy();
+    mRootContentController = nullptr;
+  }
+}
+
+void nsBaseWidget::DestroyLayerManager()
+{
+  if (mLayerManager) {
+    mLayerManager->Destroy();
+    mLayerManager = nullptr;
+  }
+  DestroyCompositor();
+}
+
+void
+nsBaseWidget::OnRenderingDeviceReset()
+{
+  if (!mLayerManager || !mCompositorSession) {
+    return;
+  }
+
+  nsTArray<LayersBackend> backendHints;
+  gfxPlatform::GetPlatform()->GetCompositorBackends(ComputeShouldAccelerate(), backendHints);
+
+  // If the existing compositor does not use acceleration, and this widget
+  // should not be accelerated, then there's no point in resetting.
+  //
+  // Note that if this widget should be accelerated, but instead has a basic
+  // compositor, we still reset just in case we're now in the position to get
+  // accelerated layers again.
+  RefPtr<ClientLayerManager> clm = mLayerManager->AsClientLayerManager();
+  if (!ComputeShouldAccelerate() &&
+      clm->GetTextureFactoryIdentifier().mParentBackend != LayersBackend::LAYERS_BASIC)
+  {
+    return;
+  }
+
+  // Recreate the compositor.
+  TextureFactoryIdentifier identifier;
+  if (!mCompositorSession->Reset(backendHints, &identifier)) {
+    // No action was taken, so we don't have to do anything.
+    return;
+  }
+
+  // Invalidate all layers.
+  FrameLayerBuilder::InvalidateAllLayers(mLayerManager);
+
+  // Update the texture factory identifier.
+  clm->UpdateTextureFactoryIdentifier(identifier);
+  ImageBridgeChild::IdentifyCompositorTextureHost(identifier);
+  gfx::VRManagerChild::IdentifyTextureHost(identifier);
+}
+
+void
+nsBaseWidget::FreeShutdownObserver()
+{
+  if (mShutdownObserver) {
+    mShutdownObserver->Unregister();
+  }
+  mShutdownObserver = nullptr;
+}
+
+//-------------------------------------------------------------------------
+//
+// nsBaseWidget destructor
+//
+//-------------------------------------------------------------------------
+
+nsBaseWidget::~nsBaseWidget()
+{
+  IMEStateManager::WidgetDestroyed(this);
+
+  if (mLayerManager) {
+    if (BasicLayerManager* mgr = mLayerManager->AsBasicLayerManager()) {
+      mgr->ClearRetainerWidget();
+    }
+  }
+
+  FreeShutdownObserver();
+  RevokeTransactionIdAllocator();
+  DestroyLayerManager();
+
+#ifdef NOISY_WIDGET_LEAKS
+  gNumWidgets--;
+  printf("WIDGETS- = %d\n", gNumWidgets);
+#endif
+
+  delete mOriginalBounds;
+}
+
+//-------------------------------------------------------------------------
+//
+// Basic create.
+//
+//-------------------------------------------------------------------------
+void nsBaseWidget::BaseCreate(nsIWidget* aParent,
+                              nsWidgetInitData* aInitData)
+{
+  static bool gDisableNativeThemeCached = false;
+  if (!gDisableNativeThemeCached) {
+    Preferences::AddBoolVarCache(&gDisableNativeTheme,
+                                 "mozilla.widget.disable-native-theme",
+                                 gDisableNativeTheme);
+    gDisableNativeThemeCached = true;
+  }
+
+  // keep a reference to the device context
+  if (nullptr != aInitData) {
+    mWindowType = aInitData->mWindowType;
+    mBorderStyle = aInitData->mBorderStyle;
+    mPopupLevel = aInitData->mPopupLevel;
+    mPopupType = aInitData->mPopupHint;
+  }
+
+  if (aParent) {
+    aParent->AddChild(this);
+  }
+}
+
+//-------------------------------------------------------------------------
+//
+// Accessor functions to get/set the client data
+//
+//-------------------------------------------------------------------------
+
+nsIWidgetListener* nsBaseWidget::GetWidgetListener()
+{
+  return mWidgetListener;
+}
+
+void nsBaseWidget::SetWidgetListener(nsIWidgetListener* aWidgetListener)
+{
+  mWidgetListener = aWidgetListener;
+}
+
+already_AddRefed<nsIWidget>
+nsBaseWidget::CreateChild(const LayoutDeviceIntRect& aRect,
+                          nsWidgetInitData* aInitData,
+                          bool aForceUseIWidgetParent)
+{
+  nsIWidget* parent = this;
+  nsNativeWidget nativeParent = nullptr;
+
+  if (!aForceUseIWidgetParent) {
+    // Use only either parent or nativeParent, not both, to match
+    // existing code.  Eventually Create() should be divested of its
+    // nativeWidget parameter.
+    nativeParent = parent ? parent->GetNativeData(NS_NATIVE_WIDGET) : nullptr;
+    parent = nativeParent ? nullptr : parent;
+    MOZ_ASSERT(!parent || !nativeParent, "messed up logic");
+  }
+
+  nsCOMPtr<nsIWidget> widget;
+  if (aInitData && aInitData->mWindowType == eWindowType_popup) {
+    widget = AllocateChildPopupWidget();
+  } else {
+    static NS_DEFINE_IID(kCChildCID, NS_CHILD_CID);
+    widget = do_CreateInstance(kCChildCID);
+  }
+
+  if (widget &&
+      NS_SUCCEEDED(widget->Create(parent, nativeParent, aRect, aInitData))) {
+    return widget.forget();
+  }
+
+  return nullptr;
+}
+
+// Attach a view to our widget which we'll send events to.
+void
+nsBaseWidget::AttachViewToTopLevel(bool aUseAttachedEvents)
+{
+  NS_ASSERTION((mWindowType == eWindowType_toplevel ||
+                mWindowType == eWindowType_dialog ||
+                mWindowType == eWindowType_invisible ||
+                mWindowType == eWindowType_child),
+               "Can't attach to window of that type");
+
+  mUseAttachedEvents = aUseAttachedEvents;
+}
+
+nsIWidgetListener* nsBaseWidget::GetAttachedWidgetListener()
+ {
+   return mAttachedWidgetListener;
+ }
+
+nsIWidgetListener* nsBaseWidget::GetPreviouslyAttachedWidgetListener()
+ {
+   return mPreviouslyAttachedWidgetListener;
+ }
+
+void nsBaseWidget::SetPreviouslyAttachedWidgetListener(nsIWidgetListener* aListener)
+ {
+   mPreviouslyAttachedWidgetListener = aListener;
+ }
+
+void nsBaseWidget::SetAttachedWidgetListener(nsIWidgetListener* aListener)
+ {
+   mAttachedWidgetListener = aListener;
+ }
+
+//-------------------------------------------------------------------------
+//
+// Close this nsBaseWidget
+//
+//-------------------------------------------------------------------------
+void nsBaseWidget::Destroy()
+{
+  // Just in case our parent is the only ref to us
+  nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
+  // disconnect from the parent
+  nsIWidget *parent = GetParent();
+  if (parent) {
+    parent->RemoveChild(this);
+  }
+
+#if defined(XP_WIN)
+  // Allow our scroll capture container to be cleaned up, if we have one.
+  mScrollCaptureContainer = nullptr;
+#endif
+}
+
+
+//-------------------------------------------------------------------------
+//
+// Set this nsBaseWidget's parent
+//
+//-------------------------------------------------------------------------
+NS_IMETHODIMP nsBaseWidget::SetParent(nsIWidget* aNewParent)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+
+//-------------------------------------------------------------------------
+//
+// Get this nsBaseWidget parent
+//
+//-------------------------------------------------------------------------
+nsIWidget* nsBaseWidget::GetParent(void)
+{
+  return nullptr;
+}
+
+//-------------------------------------------------------------------------
+//
+// Get this nsBaseWidget top level widget
+//
+//-------------------------------------------------------------------------
+nsIWidget* nsBaseWidget::GetTopLevelWidget()
+{
+  nsIWidget *topLevelWidget = nullptr, *widget = this;
+  while (widget) {
+    topLevelWidget = widget;
+    widget = widget->GetParent();
+  }
+  return topLevelWidget;
+}
+
+//-------------------------------------------------------------------------
+//
+// Get this nsBaseWidget's top (non-sheet) parent (if it's a sheet)
+//
+//-------------------------------------------------------------------------
+nsIWidget* nsBaseWidget::GetSheetWindowParent(void)
+{
+  return nullptr;
+}
+
+float nsBaseWidget::GetDPI()
+{
+  return 96.0f;
+}
+
+CSSToLayoutDeviceScale nsIWidget::GetDefaultScale()
+{
+  double devPixelsPerCSSPixel = DefaultScaleOverride();
+
+  if (devPixelsPerCSSPixel <= 0.0) {
+    devPixelsPerCSSPixel = GetDefaultScaleInternal();
+  }
+
+  return CSSToLayoutDeviceScale(devPixelsPerCSSPixel);
+}
+
+/* static */
+double nsIWidget::DefaultScaleOverride()
+{
+  // The number of device pixels per CSS pixel. A value <= 0 means choose
+  // automatically based on the DPI. A positive value is used as-is. This effectively
+  // controls the size of a CSS "px".
+  double devPixelsPerCSSPixel = -1.0;
+
+  nsAdoptingCString prefString = Preferences::GetCString("layout.css.devPixelsPerPx");
+  if (!prefString.IsEmpty()) {
+    devPixelsPerCSSPixel = PR_strtod(prefString, nullptr);
+  }
+
+  return devPixelsPerCSSPixel;
+}
+
+//-------------------------------------------------------------------------
+//
+// Add a child to the list of children
+//
+//-------------------------------------------------------------------------
+void nsBaseWidget::AddChild(nsIWidget* aChild)
+{
+  MOZ_ASSERT(!aChild->GetNextSibling() && !aChild->GetPrevSibling(),
+             "aChild not properly removed from its old child list");
+
+  if (!mFirstChild) {
+    mFirstChild = mLastChild = aChild;
+  } else {
+    // append to the list
+    MOZ_ASSERT(mLastChild);
+    MOZ_ASSERT(!mLastChild->GetNextSibling());
+    mLastChild->SetNextSibling(aChild);
+    aChild->SetPrevSibling(mLastChild);
+    mLastChild = aChild;
+  }
+}
+
+
+//-------------------------------------------------------------------------
+//
+// Remove a child from the list of children
+//
+//-------------------------------------------------------------------------
+void nsBaseWidget::RemoveChild(nsIWidget* aChild)
+{
+#ifdef DEBUG
+#ifdef XP_MACOSX
+  // nsCocoaWindow doesn't implement GetParent, so in that case parent will be
+  // null and we'll just have to do without this assertion.
+  nsIWidget* parent = aChild->GetParent();
+  NS_ASSERTION(!parent || parent == this, "Not one of our kids!");
+#else
+  MOZ_RELEASE_ASSERT(aChild->GetParent() == this, "Not one of our kids!");
+#endif
+#endif
+
+  if (mLastChild == aChild) {
+    mLastChild = mLastChild->GetPrevSibling();
+  }
+  if (mFirstChild == aChild) {
+    mFirstChild = mFirstChild->GetNextSibling();
+  }
+
+  // Now remove from the list.  Make sure that we pass ownership of the tail
+  // of the list correctly before we have aChild let go of it.
+  nsIWidget* prev = aChild->GetPrevSibling();
+  nsIWidget* next = aChild->GetNextSibling();
+  if (prev) {
+    prev->SetNextSibling(next);
+  }
+  if (next) {
+    next->SetPrevSibling(prev);
+  }
+
+  aChild->SetNextSibling(nullptr);
+  aChild->SetPrevSibling(nullptr);
+}
+
+
+//-------------------------------------------------------------------------
+//
+// Sets widget's position within its parent's child list.
+//
+//-------------------------------------------------------------------------
+void nsBaseWidget::SetZIndex(int32_t aZIndex)
+{
+  // Hold a ref to ourselves just in case, since we're going to remove
+  // from our parent.
+  nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
+
+  mZIndex = aZIndex;
+
+  // reorder this child in its parent's list.
+  nsBaseWidget* parent = static_cast<nsBaseWidget*>(GetParent());
+  if (parent) {
+    parent->RemoveChild(this);
+    // Scope sib outside the for loop so we can check it afterward
+    nsIWidget* sib = parent->GetFirstChild();
+    for ( ; sib; sib = sib->GetNextSibling()) {
+      int32_t childZIndex = GetZIndex();
+      if (aZIndex < childZIndex) {
+        // Insert ourselves before sib
+        nsIWidget* prev = sib->GetPrevSibling();
+        mNextSibling = sib;
+        mPrevSibling = prev;
+        sib->SetPrevSibling(this);
+        if (prev) {
+          prev->SetNextSibling(this);
+        } else {
+          NS_ASSERTION(sib == parent->mFirstChild, "Broken child list");
+          // We've taken ownership of sib, so it's safe to have parent let
+          // go of it
+          parent->mFirstChild = this;
+        }
+        PlaceBehind(eZPlacementBelow, sib, false);
+        break;
+      }
+    }
+    // were we added to the list?
+    if (!sib) {
+      parent->AddChild(this);
+    }
+  }
+}
+
+//-------------------------------------------------------------------------
+//
+// Maximize, minimize or restore the window. The BaseWidget implementation
+// merely stores the state.
+//
+//-------------------------------------------------------------------------
+void
+nsBaseWidget::SetSizeMode(nsSizeMode aMode)
+{
+  MOZ_ASSERT(aMode == nsSizeMode_Normal ||
+             aMode == nsSizeMode_Minimized ||
+             aMode == nsSizeMode_Maximized ||
+             aMode == nsSizeMode_Fullscreen);
+  mSizeMode = aMode;
+}
+
+//-------------------------------------------------------------------------
+//
+// Get this component cursor
+//
+//-------------------------------------------------------------------------
+nsCursor nsBaseWidget::GetCursor()
+{
+  return mCursor;
+}
+
+NS_IMETHODIMP nsBaseWidget::SetCursor(nsCursor aCursor)
+{
+  mCursor = aCursor;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsBaseWidget::SetCursor(imgIContainer* aCursor,
+                                      uint32_t aHotspotX, uint32_t aHotspotY)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+//-------------------------------------------------------------------------
+//
+// Window transparency methods
+//
+//-------------------------------------------------------------------------
+
+void nsBaseWidget::SetTransparencyMode(nsTransparencyMode aMode) {
+}
+
+nsTransparencyMode nsBaseWidget::GetTransparencyMode() {
+  return eTransparencyOpaque;
+}
+
+bool
+nsBaseWidget::IsWindowClipRegionEqual(const nsTArray<LayoutDeviceIntRect>& aRects)
+{
+  return mClipRects &&
+         mClipRectCount == aRects.Length() &&
+         memcmp(mClipRects.get(), aRects.Elements(), sizeof(LayoutDeviceIntRect)*mClipRectCount) == 0;
+}
+
+void
+nsBaseWidget::StoreWindowClipRegion(const nsTArray<LayoutDeviceIntRect>& aRects)
+{
+  mClipRectCount = aRects.Length();
+  mClipRects = MakeUnique<LayoutDeviceIntRect[]>(mClipRectCount);
+  if (mClipRects) {
+    memcpy(mClipRects.get(), aRects.Elements(), sizeof(LayoutDeviceIntRect)*mClipRectCount);
+  }
+}
+
+void
+nsBaseWidget::GetWindowClipRegion(nsTArray<LayoutDeviceIntRect>* aRects)
+{
+  if (mClipRects) {
+    aRects->AppendElements(mClipRects.get(), mClipRectCount);
+  } else {
+    aRects->AppendElement(LayoutDeviceIntRect(0, 0, mBounds.width, mBounds.height));
+  }
+}
+
+const LayoutDeviceIntRegion
+nsBaseWidget::RegionFromArray(const nsTArray<LayoutDeviceIntRect>& aRects)
+{
+  LayoutDeviceIntRegion region;
+  for (uint32_t i = 0; i < aRects.Length(); ++i) {
+    region.Or(region, aRects[i]);
+  }
+  return region;
+}
+
+void
+nsBaseWidget::ArrayFromRegion(const LayoutDeviceIntRegion& aRegion,
+                              nsTArray<LayoutDeviceIntRect>& aRects)
+{
+  for (auto iter = aRegion.RectIter(); !iter.Done(); iter.Next()) {
+    aRects.AppendElement(iter.Get());
+  }
+}
+
+nsresult
+nsBaseWidget::SetWindowClipRegion(const nsTArray<LayoutDeviceIntRect>& aRects,
+                                  bool aIntersectWithExisting)
+{
+  if (!aIntersectWithExisting) {
+    StoreWindowClipRegion(aRects);
+  } else {
+    // get current rects
+    nsTArray<LayoutDeviceIntRect> currentRects;
+    GetWindowClipRegion(&currentRects);
+    // create region from them
+    LayoutDeviceIntRegion currentRegion = RegionFromArray(currentRects);
+    // create region from new rects
+    LayoutDeviceIntRegion newRegion = RegionFromArray(aRects);
+    // intersect regions
+    LayoutDeviceIntRegion intersection;
+    intersection.And(currentRegion, newRegion);
+    // create int rect array from intersection
+    nsTArray<LayoutDeviceIntRect> rects;
+    ArrayFromRegion(intersection, rects);
+    // store
+    StoreWindowClipRegion(rects);
+  }
+  return NS_OK;
+}
+
+//-------------------------------------------------------------------------
+//
+// Hide window borders/decorations for this widget
+//
+//-------------------------------------------------------------------------
+NS_IMETHODIMP nsBaseWidget::HideWindowChrome(bool aShouldHide)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* virtual */ void
+nsBaseWidget::PerformFullscreenTransition(FullscreenTransitionStage aStage,
+                                          uint16_t aDuration,
+                                          nsISupports* aData,
+                                          nsIRunnable* aCallback)
+{
+  MOZ_ASSERT_UNREACHABLE(
+    "Should never call PerformFullscreenTransition on nsBaseWidget");
+}
+
+//-------------------------------------------------------------------------
+//
+// Put the window into full-screen mode
+//
+//-------------------------------------------------------------------------
+void
+nsBaseWidget::InfallibleMakeFullScreen(bool aFullScreen, nsIScreen* aScreen)
+{
+  HideWindowChrome(aFullScreen);
+
+  if (aFullScreen) {
+    if (!mOriginalBounds) {
+      mOriginalBounds = new LayoutDeviceIntRect();
+    }
+    *mOriginalBounds = GetScreenBounds();
+
+    // Move to top-left corner of screen and size to the screen dimensions
+    nsCOMPtr<nsIScreen> screen = aScreen;
+    if (!screen) {
+      screen = GetWidgetScreen();
+    }
+    if (screen) {
+      int32_t left, top, width, height;
+      if (NS_SUCCEEDED(screen->GetRectDisplayPix(&left, &top, &width, &height))) {
+        Resize(left, top, width, height, true);
+      }
+    }
+  } else if (mOriginalBounds) {
+    if (BoundsUseDesktopPixels()) {
+      DesktopRect deskRect = *mOriginalBounds / GetDesktopToDeviceScale();
+      Resize(deskRect.x, deskRect.y, deskRect.width, deskRect.height, true);
+    } else {
+      Resize(mOriginalBounds->x, mOriginalBounds->y, mOriginalBounds->width,
+             mOriginalBounds->height, true);
+    }
+  }
+}
+
+nsresult
+nsBaseWidget::MakeFullScreen(bool aFullScreen, nsIScreen* aScreen)
+{
+  InfallibleMakeFullScreen(aFullScreen, aScreen);
+  return NS_OK;
+}
+
+nsBaseWidget::AutoLayerManagerSetup::AutoLayerManagerSetup(
+    nsBaseWidget* aWidget, gfxContext* aTarget,
+    BufferMode aDoubleBuffering, ScreenRotation aRotation)
+  : mWidget(aWidget)
+{
+  LayerManager* lm = mWidget->GetLayerManager();
+  NS_ASSERTION(!lm || lm->GetBackendType() == LayersBackend::LAYERS_BASIC,
+    "AutoLayerManagerSetup instantiated for non-basic layer backend!");
+  if (lm) {
+    mLayerManager = lm->AsBasicLayerManager();
+    if (mLayerManager) {
+      mLayerManager->SetDefaultTarget(aTarget);
+      mLayerManager->SetDefaultTargetConfiguration(aDoubleBuffering, aRotation);
+    }
+  }
+}
+
+nsBaseWidget::AutoLayerManagerSetup::~AutoLayerManagerSetup()
+{
+  if (mLayerManager) {
+    mLayerManager->SetDefaultTarget(nullptr);
+    mLayerManager->SetDefaultTargetConfiguration(mozilla::layers::BufferMode::BUFFER_NONE, ROTATION_0);
+  }
+}
+
+bool nsBaseWidget::IsSmallPopup() const
+{
+  return mWindowType == eWindowType_popup && mPopupType != ePopupTypePanel;
+}
+
+bool
+nsBaseWidget::ComputeShouldAccelerate()
+{
+  return gfx::gfxConfig::IsEnabled(gfx::Feature::HW_COMPOSITING) &&
+         WidgetTypeSupportsAcceleration();
+}
+
+bool
+nsBaseWidget::UseAPZ()
+{
+  return (gfxPlatform::AsyncPanZoomEnabled() &&
+          (WindowType() == eWindowType_toplevel || WindowType() == eWindowType_child));
+}
+
+void nsBaseWidget::CreateCompositor()
+{
+  LayoutDeviceIntRect rect = GetBounds();
+  CreateCompositor(rect.width, rect.height);
+}
+
+already_AddRefed<GeckoContentController>
+nsBaseWidget::CreateRootContentController()
+{
+  RefPtr<GeckoContentController> controller = new ChromeProcessController(this, mAPZEventState, mAPZC);
+  return controller.forget();
+}
+
+void nsBaseWidget::ConfigureAPZCTreeManager()
+{
+  MOZ_ASSERT(mAPZC);
+
+  ConfigureAPZControllerThread();
+
+  mAPZC->SetDPI(GetDPI());
+
+  RefPtr<IAPZCTreeManager> treeManager = mAPZC;  // for capture by the lambdas
+
+  ContentReceivedInputBlockCallback callback(
+      [treeManager](const ScrollableLayerGuid& aGuid,
+                    uint64_t aInputBlockId,
+                    bool aPreventDefault)
+      {
+        MOZ_ASSERT(NS_IsMainThread());
+        APZThreadUtils::RunOnControllerThread(NewRunnableMethod
+                                              <uint64_t, bool>(treeManager,
+                                                               &IAPZCTreeManager::ContentReceivedInputBlock,
+                                                               aInputBlockId,
+                                                               aPreventDefault));
+      });
+  mAPZEventState = new APZEventState(this, mozilla::Move(callback));
+
+  mSetAllowedTouchBehaviorCallback = [treeManager](uint64_t aInputBlockId,
+                                                   const nsTArray<TouchBehaviorFlags>& aFlags)
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+    APZThreadUtils::RunOnControllerThread(NewRunnableMethod
+      <uint64_t,
+       StoreCopyPassByLRef<nsTArray<TouchBehaviorFlags>>>(treeManager,
+                                                          &IAPZCTreeManager::SetAllowedTouchBehavior,
+                                                          aInputBlockId, aFlags));
+  };
+
+  mRootContentController = CreateRootContentController();
+  if (mRootContentController) {
+    mCompositorSession->SetContentController(mRootContentController);
+  }
+
+  // When APZ is enabled, we can actually enable raw touch events because we
+  // have code that can deal with them properly. If APZ is not enabled, this
+  // function doesn't get called.
+  if (Preferences::GetInt("dom.w3c_touch_events.enabled", 0) ||
+      Preferences::GetBool("dom.w3c_pointer_events.enabled", false)) {
+    RegisterTouchWindow();
+  }
+}
+
+void nsBaseWidget::ConfigureAPZControllerThread()
+{
+  // By default the controller thread is the main thread.
+  APZThreadUtils::SetControllerThread(MessageLoop::current());
+}
+
+void
+nsBaseWidget::SetConfirmedTargetAPZC(uint64_t aInputBlockId,
+                                     const nsTArray<ScrollableLayerGuid>& aTargets) const
+{
+  APZThreadUtils::RunOnControllerThread(NewRunnableMethod
+    <uint64_t, StoreCopyPassByRRef<nsTArray<ScrollableLayerGuid>>>(mAPZC,
+                                                                   &IAPZCTreeManager::SetTargetAPZC,
+                                                                   aInputBlockId, aTargets));
+}
+
+void
+nsBaseWidget::UpdateZoomConstraints(const uint32_t& aPresShellId,
+                                    const FrameMetrics::ViewID& aViewId,
+                                    const Maybe<ZoomConstraints>& aConstraints)
+{
+  if (!mCompositorSession || !mAPZC) {
+    if (mInitialZoomConstraints) {
+      MOZ_ASSERT(mInitialZoomConstraints->mPresShellID == aPresShellId);
+      MOZ_ASSERT(mInitialZoomConstraints->mViewID == aViewId);
+      if (!aConstraints) {
+        mInitialZoomConstraints.reset();
+      }
+    }
+
+    if (aConstraints) {
+      // We have some constraints, but the compositor and APZC aren't created yet.
+      // Save these so we can use them later.
+      mInitialZoomConstraints = Some(InitialZoomConstraints(aPresShellId, aViewId, aConstraints.ref()));
+    }
+    return;
+  }
+  uint64_t layersId = mCompositorSession->RootLayerTreeId();
+  mAPZC->UpdateZoomConstraints(ScrollableLayerGuid(layersId, aPresShellId, aViewId),
+                               aConstraints);
+}
+
+bool
+nsBaseWidget::AsyncPanZoomEnabled() const
+{
+  return !!mAPZC;
+}
+
+nsEventStatus
+nsBaseWidget::ProcessUntransformedAPZEvent(WidgetInputEvent* aEvent,
+                                           const ScrollableLayerGuid& aGuid,
+                                           uint64_t aInputBlockId,
+                                           nsEventStatus aApzResponse)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  InputAPZContext context(aGuid, aInputBlockId, aApzResponse);
+
+  // If this is an event that the APZ has targeted to an APZC in the root
+  // process, apply that APZC's callback-transform before dispatching the
+  // event. If the event is instead targeted to an APZC in the child process,
+  // the transform will be applied in the child process before dispatching
+  // the event there (see e.g. TabChild::RecvRealTouchEvent()).
+  if (aGuid.mLayersId == mCompositorSession->RootLayerTreeId()) {
+    APZCCallbackHelper::ApplyCallbackTransform(*aEvent, aGuid,
+        GetDefaultScale());
+  }
+
+  // Make a copy of the original event for the APZCCallbackHelper helpers that
+  // we call later, because the event passed to DispatchEvent can get mutated in
+  // ways that we don't want (i.e. touch points can get stripped out).
+  nsEventStatus status;
+  UniquePtr<WidgetEvent> original(aEvent->Duplicate());
+  DispatchEvent(aEvent, status);
+
+  if (mAPZC && !context.WasRoutedToChildProcess() && aInputBlockId) {
+    // EventStateManager did not route the event into the child process.
+    // It's safe to communicate to APZ that the event has been processed.
+    // TODO: Eventually we'll be able to move the SendSetTargetAPZCNotification
+    // call into APZEventState::Process*Event() as well.
+    if (WidgetTouchEvent* touchEvent = aEvent->AsTouchEvent()) {
+      if (touchEvent->mMessage == eTouchStart) {
+        if (gfxPrefs::TouchActionEnabled()) {
+          APZCCallbackHelper::SendSetAllowedTouchBehaviorNotification(this,
+              GetDocument(), *(original->AsTouchEvent()), aInputBlockId,
+              mSetAllowedTouchBehaviorCallback);
+        }
+        APZCCallbackHelper::SendSetTargetAPZCNotification(this, GetDocument(),
+            *(original->AsTouchEvent()), aGuid, aInputBlockId);
+      }
+      mAPZEventState->ProcessTouchEvent(*touchEvent, aGuid, aInputBlockId,
+          aApzResponse, status);
+    } else if (WidgetWheelEvent* wheelEvent = aEvent->AsWheelEvent()) {
+      MOZ_ASSERT(wheelEvent->mFlags.mHandledByAPZ);
+      APZCCallbackHelper::SendSetTargetAPZCNotification(this, GetDocument(),
+          *(original->AsWheelEvent()), aGuid, aInputBlockId);
+      if (wheelEvent->mCanTriggerSwipe) {
+        ReportSwipeStarted(aInputBlockId, wheelEvent->TriggersSwipe());
+      }
+      mAPZEventState->ProcessWheelEvent(*wheelEvent, aGuid, aInputBlockId);
+    } else if (WidgetMouseEvent* mouseEvent = aEvent->AsMouseEvent()) {
+      MOZ_ASSERT(mouseEvent->mFlags.mHandledByAPZ);
+      APZCCallbackHelper::SendSetTargetAPZCNotification(this, GetDocument(),
+          *(original->AsMouseEvent()), aGuid, aInputBlockId);
+      mAPZEventState->ProcessMouseEvent(*mouseEvent, aGuid, aInputBlockId);
+    }
+  }
+
+  return status;
+}
+
+class DispatchWheelEventOnMainThread : public Runnable
+{
+public:
+  DispatchWheelEventOnMainThread(const ScrollWheelInput& aWheelInput,
+                                 nsBaseWidget* aWidget,
+                                 nsEventStatus aAPZResult,
+                                 uint64_t aInputBlockId,
+                                 ScrollableLayerGuid aGuid)
+    : mWheelInput(aWheelInput)
+    , mWidget(aWidget)
+    , mAPZResult(aAPZResult)
+    , mInputBlockId(aInputBlockId)
+    , mGuid(aGuid)
+  {
+  }
+
+  NS_IMETHOD Run() override
+  {
+    WidgetWheelEvent wheelEvent = mWheelInput.ToWidgetWheelEvent(mWidget);
+    mWidget->ProcessUntransformedAPZEvent(&wheelEvent, mGuid, mInputBlockId, mAPZResult);
+    return NS_OK;
+  }
+
+private:
+  ScrollWheelInput mWheelInput;
+  nsBaseWidget* mWidget;
+  nsEventStatus mAPZResult;
+  uint64_t mInputBlockId;
+  ScrollableLayerGuid mGuid;
+};
+
+class DispatchWheelInputOnControllerThread : public Runnable
+{
+public:
+  DispatchWheelInputOnControllerThread(const WidgetWheelEvent& aWheelEvent,
+                                       IAPZCTreeManager* aAPZC,
+                                       nsBaseWidget* aWidget)
+    : mMainMessageLoop(MessageLoop::current())
+    , mWheelInput(aWheelEvent)
+    , mAPZC(aAPZC)
+    , mWidget(aWidget)
+    , mInputBlockId(0)
+  {
+  }
+
+  NS_IMETHOD Run() override
+  {
+    nsEventStatus result = mAPZC->ReceiveInputEvent(mWheelInput, &mGuid, &mInputBlockId);
+    if (result == nsEventStatus_eConsumeNoDefault) {
+      return NS_OK;
+    }
+    RefPtr<Runnable> r = new DispatchWheelEventOnMainThread(mWheelInput, mWidget, result, mInputBlockId, mGuid);
+    mMainMessageLoop->PostTask(r.forget());
+    return NS_OK;
+  }
+
+private:
+  MessageLoop* mMainMessageLoop;
+  ScrollWheelInput mWheelInput;
+  RefPtr<IAPZCTreeManager> mAPZC;
+  nsBaseWidget* mWidget;
+  uint64_t mInputBlockId;
+  ScrollableLayerGuid mGuid;
+};
+
+void
+nsBaseWidget::DispatchTouchInput(MultiTouchInput& aInput)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  if (mAPZC) {
+    MOZ_ASSERT(APZThreadUtils::IsControllerThread());
+    uint64_t inputBlockId = 0;
+    ScrollableLayerGuid guid;
+
+    nsEventStatus result = mAPZC->ReceiveInputEvent(aInput, &guid, &inputBlockId);
+    if (result == nsEventStatus_eConsumeNoDefault) {
+      return;
+    }
+
+    WidgetTouchEvent event = aInput.ToWidgetTouchEvent(this);
+    ProcessUntransformedAPZEvent(&event, guid, inputBlockId, result);
+  } else {
+    WidgetTouchEvent event = aInput.ToWidgetTouchEvent(this);
+
+    nsEventStatus status;
+    DispatchEvent(&event, status);
+  }
+}
+
+nsEventStatus
+nsBaseWidget::DispatchInputEvent(WidgetInputEvent* aEvent)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  if (mAPZC) {
+    if (APZThreadUtils::IsControllerThread()) {
+      uint64_t inputBlockId = 0;
+      ScrollableLayerGuid guid;
+
+      nsEventStatus result = mAPZC->ReceiveInputEvent(*aEvent, &guid, &inputBlockId);
+      if (result == nsEventStatus_eConsumeNoDefault) {
+          return result;
+      }
+      return ProcessUntransformedAPZEvent(aEvent, guid, inputBlockId, result);
+    } else {
+      WidgetWheelEvent* wheelEvent = aEvent->AsWheelEvent();
+      if (wheelEvent) {
+        RefPtr<Runnable> r = new DispatchWheelInputOnControllerThread(*wheelEvent, mAPZC, this);
+        APZThreadUtils::RunOnControllerThread(r.forget());
+        return nsEventStatus_eConsumeDoDefault;
+      }
+      MOZ_CRASH();
+    }
+  }
+
+  nsEventStatus status;
+  DispatchEvent(aEvent, status);
+  return status;
+}
+
+void
+nsBaseWidget::DispatchEventToAPZOnly(mozilla::WidgetInputEvent* aEvent)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  if (mAPZC) {
+    MOZ_ASSERT(APZThreadUtils::IsControllerThread());
+    uint64_t inputBlockId = 0;
+    ScrollableLayerGuid guid;
+    mAPZC->ReceiveInputEvent(*aEvent, &guid, &inputBlockId);
+  }
+}
+
+nsIDocument*
+nsBaseWidget::GetDocument() const
+{
+  if (mWidgetListener) {
+    if (nsIPresShell* presShell = mWidgetListener->GetPresShell()) {
+      return presShell->GetDocument();
+    }
+  }
+  return nullptr;
+}
+
+void nsBaseWidget::CreateCompositorVsyncDispatcher()
+{
+  // Parent directly listens to the vsync source whereas
+  // child process communicate via IPC
+  // Should be called AFTER gfxPlatform is initialized
+  if (XRE_IsParentProcess()) {
+    mCompositorVsyncDispatcher = new CompositorVsyncDispatcher();
+  }
+}
+
+CompositorVsyncDispatcher*
+nsBaseWidget::GetCompositorVsyncDispatcher()
+{
+  return mCompositorVsyncDispatcher;
+}
+
+void nsBaseWidget::CreateCompositor(int aWidth, int aHeight)
+{
+  // This makes sure that gfxPlatforms gets initialized if it hasn't by now.
+  gfxPlatform::GetPlatform();
+
+  MOZ_ASSERT(gfxPlatform::UsesOffMainThreadCompositing(),
+             "This function assumes OMTC");
+
+  MOZ_ASSERT(!mCompositorSession && !mCompositorBridgeChild,
+    "Should have properly cleaned up the previous PCompositor pair beforehand");
+
+  if (mCompositorBridgeChild) {
+    mCompositorBridgeChild->Destroy();
+  }
+
+  // Recreating this is tricky, as we may still have an old and we need
+  // to make sure it's properly destroyed by calling DestroyCompositor!
+
+  // If we've already received a shutdown notification, don't try
+  // create a new compositor.
+  if (!mShutdownObserver) {
+    return;
+  }
+
+  CreateCompositorVsyncDispatcher();
+
+  RefPtr<ClientLayerManager> lm = new ClientLayerManager(this);
+
+  bool useAPZ = UseAPZ();
+
+  gfx::GPUProcessManager* gpu = gfx::GPUProcessManager::Get();
+  mCompositorSession = gpu->CreateTopLevelCompositor(
+    this,
+    lm,
+    GetDefaultScale(),
+    useAPZ,
+    UseExternalCompositingSurface(),
+    gfx::IntSize(aWidth, aHeight));
+  mCompositorBridgeChild = mCompositorSession->GetCompositorBridgeChild();
+  mCompositorWidgetDelegate = mCompositorSession->GetCompositorWidgetDelegate();
+
+  if (useAPZ) {
+    mAPZC = mCompositorSession->GetAPZCTreeManager();
+    ConfigureAPZCTreeManager();
+  } else {
+    mAPZC = nullptr;
+  }
+
+  if (mInitialZoomConstraints) {
+    UpdateZoomConstraints(mInitialZoomConstraints->mPresShellID,
+                          mInitialZoomConstraints->mViewID,
+                          Some(mInitialZoomConstraints->mConstraints));
+    mInitialZoomConstraints.reset();
+  }
+
+  ShadowLayerForwarder* lf = lm->AsShadowForwarder();
+  // As long as we are creating a ClientLayerManager above lf must be non-null.
+  MOZ_ASSERT(lf);
+
+  if (lf) {
+    TextureFactoryIdentifier textureFactoryIdentifier;
+    PLayerTransactionChild* shadowManager = nullptr;
+
+    nsTArray<LayersBackend> backendHints;
+    gfxPlatform::GetPlatform()->GetCompositorBackends(ComputeShouldAccelerate(), backendHints);
+
+    bool success = false;
+    if (!backendHints.IsEmpty()) {
+      shadowManager = mCompositorBridgeChild->SendPLayerTransactionConstructor(
+        backendHints, 0, &textureFactoryIdentifier, &success);
+    }
+
+    if (!success) {
+      NS_WARNING("Failed to create an OMT compositor.");
+      DestroyCompositor();
+      mLayerManager = nullptr;
+      return;
+    }
+
+    lf->SetShadowManager(shadowManager);
+    if (ClientLayerManager* clm = lm->AsClientLayerManager()) {
+      clm->UpdateTextureFactoryIdentifier(textureFactoryIdentifier);
+    }
+    // Some popup or transparent widgets may use a different backend than the
+    // compositors used with ImageBridge and VR (and more generally web content).
+    if (WidgetTypeSupportsAcceleration()) {
+      ImageBridgeChild::IdentifyCompositorTextureHost(textureFactoryIdentifier);
+      gfx::VRManagerChild::IdentifyTextureHost(textureFactoryIdentifier);
+    }
+  }
+
+  WindowUsesOMTC();
+
+  mLayerManager = lm.forget();
+
+  // Only track compositors for top-level windows, since other window types
+  // may use the basic compositor.  Except on the OS X - see bug 1306383
+#if defined(XP_MACOSX)
+  bool getCompositorFromThisWindow = true;
+#else
+  bool getCompositorFromThisWindow = (mWindowType == eWindowType_toplevel);
+#endif
+
+  if (getCompositorFromThisWindow) {
+    gfxPlatform::GetPlatform()->NotifyCompositorCreated(mLayerManager->GetCompositorBackendType());
+  }
+}
+
+void nsBaseWidget::NotifyRemoteCompositorSessionLost(CompositorSession* aSession)
+{
+  MOZ_ASSERT(aSession == mCompositorSession);
+  DestroyLayerManager();
+}
+
+bool nsBaseWidget::ShouldUseOffMainThreadCompositing()
+{
+  return gfxPlatform::UsesOffMainThreadCompositing();  
+}
+
+LayerManager* nsBaseWidget::GetLayerManager(PLayerTransactionChild* aShadowManager,
+                                            LayersBackend aBackendHint,
+                                            LayerManagerPersistence aPersistence)
+{
+  if (!mLayerManager) {
+    if (!mShutdownObserver) {
+      // We are shutting down, do not try to re-create a LayerManager
+      return nullptr;
+    }
+    // Try to use an async compositor first, if possible
+    if (ShouldUseOffMainThreadCompositing()) {
+      // e10s uses the parameter to pass in the shadow manager from the TabChild
+      // so we don't expect to see it there since this doesn't support e10s.
+      NS_ASSERTION(aShadowManager == nullptr, "Async Compositor not supported with e10s");
+      CreateCompositor();
+    }
+
+    if (!mLayerManager) {
+      mLayerManager = CreateBasicLayerManager();
+    }
+  }
+  return mLayerManager;
+}
+
+LayerManager* nsBaseWidget::CreateBasicLayerManager()
+{
+  return new BasicLayerManager(this);
+}
+
+CompositorBridgeChild* nsBaseWidget::GetRemoteRenderer()
+{
+  return mCompositorBridgeChild;
+}
+
+already_AddRefed<gfx::DrawTarget>
+nsBaseWidget::StartRemoteDrawing()
+{
+  return nullptr;
+}
+
+uint32_t
+nsBaseWidget::GetGLFrameBufferFormat()
+{
+  return LOCAL_GL_RGBA;
+}
+
+//-------------------------------------------------------------------------
+//
+// Destroy the window
+//
+//-------------------------------------------------------------------------
+void nsBaseWidget::OnDestroy()
+{
+  if (mTextEventDispatcher) {
+    mTextEventDispatcher->OnDestroyWidget();
+    // Don't release it until this widget actually released because after this
+    // is called, TextEventDispatcher() may create it again.
+  }
+
+  // If this widget is being destroyed, let the APZ code know to drop references
+  // to this widget. Callers of this function all should be holding a deathgrip
+  // on this widget already.
+  ReleaseContentController();
+}
+
+NS_IMETHODIMP nsBaseWidget::MoveClient(double aX, double aY)
+{
+  LayoutDeviceIntPoint clientOffset(GetClientOffset());
+
+  // GetClientOffset returns device pixels; scale back to desktop pixels
+  // if that's what this widget uses for the Move/Resize APIs
+  if (BoundsUseDesktopPixels()) {
+    DesktopPoint desktopOffset = clientOffset / GetDesktopToDeviceScale();
+    return Move(aX - desktopOffset.x, aY - desktopOffset.y);
+  } else {
+    return Move(aX - clientOffset.x, aY - clientOffset.y);
+  }
+}
+
+NS_IMETHODIMP nsBaseWidget::ResizeClient(double aWidth,
+                                         double aHeight,
+                                         bool aRepaint)
+{
+  NS_ASSERTION((aWidth >=0) , "Negative width passed to ResizeClient");
+  NS_ASSERTION((aHeight >=0), "Negative height passed to ResizeClient");
+
+  LayoutDeviceIntRect clientBounds = GetClientBounds();
+
+  // GetClientBounds and mBounds are device pixels; scale back to desktop pixels
+  // if that's what this widget uses for the Move/Resize APIs
+  if (BoundsUseDesktopPixels()) {
+    DesktopSize desktopDelta =
+      (LayoutDeviceIntSize(mBounds.width, mBounds.height) -
+       clientBounds.Size()) / GetDesktopToDeviceScale();
+    return Resize(aWidth + desktopDelta.width, aHeight + desktopDelta.height,
+                  aRepaint);
+  } else {
+    return Resize(mBounds.width + (aWidth - clientBounds.width),
+                  mBounds.height + (aHeight - clientBounds.height), aRepaint);
+  }
+}
+
+NS_IMETHODIMP nsBaseWidget::ResizeClient(double aX,
+                                         double aY,
+                                         double aWidth,
+                                         double aHeight,
+                                         bool aRepaint)
+{
+  NS_ASSERTION((aWidth >=0) , "Negative width passed to ResizeClient");
+  NS_ASSERTION((aHeight >=0), "Negative height passed to ResizeClient");
+
+  LayoutDeviceIntRect clientBounds = GetClientBounds();
+  LayoutDeviceIntPoint clientOffset = GetClientOffset();
+
+  if (BoundsUseDesktopPixels()) {
+    DesktopToLayoutDeviceScale scale = GetDesktopToDeviceScale();
+    DesktopPoint desktopOffset = clientOffset / scale;
+    DesktopSize desktopDelta =
+      (LayoutDeviceIntSize(mBounds.width, mBounds.height) -
+       clientBounds.Size()) / scale;
+    return Resize(aX - desktopOffset.x, aY - desktopOffset.y,
+                  aWidth + desktopDelta.width, aHeight + desktopDelta.height,
+                  aRepaint);
+  } else {
+    return Resize(aX - clientOffset.x, aY - clientOffset.y,
+                  aWidth + mBounds.width - clientBounds.width,
+                  aHeight + mBounds.height - clientBounds.height,
+                  aRepaint);
+  }
+}
+
+//-------------------------------------------------------------------------
+//
+// Bounds
+//
+//-------------------------------------------------------------------------
+
+/**
+* If the implementation of nsWindow supports borders this method MUST be overridden
+*
+**/
+LayoutDeviceIntRect
+nsBaseWidget::GetClientBounds()
+{
+  return GetBounds();
+}
+
+/**
+* If the implementation of nsWindow supports borders this method MUST be overridden
+*
+**/
+LayoutDeviceIntRect
+nsBaseWidget::GetBounds()
+{
+  return mBounds;
+}
+
+/**
+* If the implementation of nsWindow uses a local coordinate system within the window,
+* this method must be overridden
+*
+**/
+LayoutDeviceIntRect
+nsBaseWidget::GetScreenBounds()
+{
+  return GetBounds();
+}
+
+nsresult
+nsBaseWidget::GetRestoredBounds(LayoutDeviceIntRect& aRect)
+{
+  if (SizeMode() != nsSizeMode_Normal) {
+    return NS_ERROR_FAILURE;
+  }
+  aRect = GetScreenBounds();
+  return NS_OK;
+}
+
+LayoutDeviceIntPoint
+nsBaseWidget::GetClientOffset()
+{
+  return LayoutDeviceIntPoint(0, 0);
+}
+
+NS_IMETHODIMP
+nsBaseWidget::SetNonClientMargins(LayoutDeviceIntMargin &margins)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+uint32_t nsBaseWidget::GetMaxTouchPoints() const
+{
+  return 0;
+}
+
+NS_IMETHODIMP
+nsBaseWidget::GetAttention(int32_t aCycleCount) {
+    return NS_OK;
+}
+
+bool
+nsBaseWidget::HasPendingInputEvent()
+{
+  return false;
+}
+
+NS_IMETHODIMP
+nsBaseWidget::SetIcon(const nsAString&)
+{
+  return NS_OK;
+}
+
+bool
+nsBaseWidget::ShowsResizeIndicator(LayoutDeviceIntRect* aResizerRect)
+{
+  return false;
+}
+
+/**
+ * Modifies aFile to point at an icon file with the given name and suffix.  The
+ * suffix may correspond to a file extension with leading '.' if appropriate.
+ * Returns true if the icon file exists and can be read.
+ */
+static bool
+ResolveIconNameHelper(nsIFile *aFile,
+                      const nsAString &aIconName,
+                      const nsAString &aIconSuffix)
+{
+  aFile->Append(NS_LITERAL_STRING("icons"));
+  aFile->Append(NS_LITERAL_STRING("default"));
+  aFile->Append(aIconName + aIconSuffix);
+
+  bool readable;
+  return NS_SUCCEEDED(aFile->IsReadable(&readable)) && readable;
+}
+
+/**
+ * Resolve the given icon name into a local file object.  This method is
+ * intended to be called by subclasses of nsBaseWidget.  aIconSuffix is a
+ * platform specific icon file suffix (e.g., ".ico" under Win32).
+ *
+ * If no file is found matching the given parameters, then null is returned.
+ */
+void
+nsBaseWidget::ResolveIconName(const nsAString &aIconName,
+                              const nsAString &aIconSuffix,
+                              nsIFile **aResult)
+{
+  *aResult = nullptr;
+
+  nsCOMPtr<nsIProperties> dirSvc = do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID);
+  if (!dirSvc)
+    return;
+
+  // first check auxilary chrome directories
+
+  nsCOMPtr<nsISimpleEnumerator> dirs;
+  dirSvc->Get(NS_APP_CHROME_DIR_LIST, NS_GET_IID(nsISimpleEnumerator),
+              getter_AddRefs(dirs));
+  if (dirs) {
+    bool hasMore;
+    while (NS_SUCCEEDED(dirs->HasMoreElements(&hasMore)) && hasMore) {
+      nsCOMPtr<nsISupports> element;
+      dirs->GetNext(getter_AddRefs(element));
+      if (!element)
+        continue;
+      nsCOMPtr<nsIFile> file = do_QueryInterface(element);
+      if (!file)
+        continue;
+      if (ResolveIconNameHelper(file, aIconName, aIconSuffix)) {
+        NS_ADDREF(*aResult = file);
+        return;
+      }
+    }
+  }
+
+  // then check the main app chrome directory
+
+  nsCOMPtr<nsIFile> file;
+  dirSvc->Get(NS_APP_CHROME_DIR, NS_GET_IID(nsIFile),
+              getter_AddRefs(file));
+  if (file && ResolveIconNameHelper(file, aIconName, aIconSuffix))
+    NS_ADDREF(*aResult = file);
+}
+
+NS_IMETHODIMP
+nsBaseWidget::BeginResizeDrag(WidgetGUIEvent* aEvent,
+                              int32_t aHorizontal,
+                              int32_t aVertical)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsBaseWidget::BeginMoveDrag(WidgetMouseEvent* aEvent)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+void nsBaseWidget::SetSizeConstraints(const SizeConstraints& aConstraints)
+{
+  mSizeConstraints = aConstraints;
+  // We can't ensure that the size is honored at this point because we're
+  // probably in the middle of a reflow.
+}
+
+const widget::SizeConstraints nsBaseWidget::GetSizeConstraints()
+{
+  return mSizeConstraints;
+}
+
+// static
+nsIRollupListener*
+nsBaseWidget::GetActiveRollupListener()
+{
+  // If set, then this is likely an <html:select> dropdown.
+  if (gRollupListener)
+    return gRollupListener;
+
+  return nsXULPopupManager::GetInstance();
+}
+
+void
+nsBaseWidget::NotifyWindowDestroyed()
+{
+  if (!mWidgetListener)
+    return;
+
+  nsCOMPtr<nsIXULWindow> window = mWidgetListener->GetXULWindow();
+  nsCOMPtr<nsIBaseWindow> xulWindow(do_QueryInterface(window));
+  if (xulWindow) {
+    xulWindow->Destroy();
+  }
+}
+
+void
+nsBaseWidget::NotifySizeMoveDone()
+{
+  if (!mWidgetListener || mWidgetListener->GetXULWindow())
+    return;
+
+  nsIPresShell* presShell = mWidgetListener->GetPresShell();
+  if (presShell) {
+    presShell->WindowSizeMoveDone();
+  }
+}
+
+void
+nsBaseWidget::NotifyWindowMoved(int32_t aX, int32_t aY)
+{
+  if (mWidgetListener) {
+    mWidgetListener->WindowMoved(this, aX, aY);
+  }
+
+  if (mIMEHasFocus && GetIMEUpdatePreference().WantPositionChanged()) {
+    NotifyIME(IMENotification(IMEMessage::NOTIFY_IME_OF_POSITION_CHANGE));
+  }
+}
+
+void
+nsBaseWidget::NotifySysColorChanged()
+{
+  if (!mWidgetListener || mWidgetListener->GetXULWindow())
+    return;
+
+  nsIPresShell* presShell = mWidgetListener->GetPresShell();
+  if (presShell) {
+    presShell->SysColorChanged();
+  }
+}
+
+void
+nsBaseWidget::NotifyThemeChanged()
+{
+  if (!mWidgetListener || mWidgetListener->GetXULWindow())
+    return;
+
+  nsIPresShell* presShell = mWidgetListener->GetPresShell();
+  if (presShell) {
+    presShell->ThemeChanged();
+  }
+}
+
+void
+nsBaseWidget::NotifyUIStateChanged(UIStateChangeType aShowAccelerators,
+                                   UIStateChangeType aShowFocusRings)
+{
+  if (nsIDocument* doc = GetDocument()) {
+    nsPIDOMWindowOuter* win = doc->GetWindow();
+    if (win) {
+      win->SetKeyboardIndicators(aShowAccelerators, aShowFocusRings);
+    }
+  }
+}
+
+NS_IMETHODIMP
+nsBaseWidget::NotifyIME(const IMENotification& aIMENotification)
+{
+  switch (aIMENotification.mMessage) {
+    case REQUEST_TO_COMMIT_COMPOSITION:
+    case REQUEST_TO_CANCEL_COMPOSITION:
+      // Currently, if native IME handler doesn't use TextEventDispatcher,
+      // the request may be notified to mTextEventDispatcher or native IME
+      // directly.  Therefore, if mTextEventDispatcher has a composition,
+      // the request should be handled by the mTextEventDispatcher.
+      if (mTextEventDispatcher && mTextEventDispatcher->IsComposing()) {
+        return mTextEventDispatcher->NotifyIME(aIMENotification);
+      }
+      // Otherwise, it should be handled by native IME.
+      return NotifyIMEInternal(aIMENotification);
+    default: {
+      if (aIMENotification.mMessage == NOTIFY_IME_OF_FOCUS) {
+        mIMEHasFocus = true;
+      }
+      EnsureTextEventDispatcher();
+      // If the platform specific widget uses TextEventDispatcher for handling
+      // native IME and keyboard events, IME event handler should be notified
+      // of the notification via TextEventDispatcher.  Otherwise, on the other
+      // platforms which have not used TextEventDispatcher yet, IME event
+      // handler should be notified by the old path (NotifyIMEInternal).
+      nsresult rv = mTextEventDispatcher->NotifyIME(aIMENotification);
+      nsresult rv2 = NotifyIMEInternal(aIMENotification);
+      if (aIMENotification.mMessage == NOTIFY_IME_OF_BLUR) {
+        mIMEHasFocus = false;
+      }
+      return rv2 == NS_ERROR_NOT_IMPLEMENTED ? rv : rv2;
+    }
+  }
+}
+
+void
+nsBaseWidget::EnsureTextEventDispatcher()
+{
+  if (mTextEventDispatcher) {
+    return;
+  }
+  mTextEventDispatcher = new TextEventDispatcher(this);
+}
+
+NS_IMETHODIMP_(nsIWidget::TextEventDispatcher*)
+nsBaseWidget::GetTextEventDispatcher()
+{
+  EnsureTextEventDispatcher();
+  return mTextEventDispatcher;
+}
+
+void*
+nsBaseWidget::GetPseudoIMEContext()
+{
+  TextEventDispatcher* dispatcher = GetTextEventDispatcher();
+  if (!dispatcher) {
+    return nullptr;
+  }
+  return dispatcher->GetPseudoIMEContext();
+}
+
+NS_IMETHODIMP_(TextEventDispatcherListener*)
+nsBaseWidget::GetNativeTextEventDispatcherListener()
+{
+  // TODO: If all platforms supported use of TextEventDispatcher for handling
+  //       native IME and keyboard events, this method should be removed since
+  //       in such case, this is overridden by all the subclasses.
+  return nullptr;
+}
+
+void
+nsBaseWidget::ZoomToRect(const uint32_t& aPresShellId,
+                         const FrameMetrics::ViewID& aViewId,
+                         const CSSRect& aRect,
+                         const uint32_t& aFlags)
+{
+  if (!mCompositorSession || !mAPZC) {
+    return;
+  }
+  uint64_t layerId = mCompositorSession->RootLayerTreeId();
+  mAPZC->ZoomToRect(ScrollableLayerGuid(layerId, aPresShellId, aViewId), aRect, aFlags);
+}
+
+#ifdef ACCESSIBILITY
+
+#if defined(XP_WIN) || defined(XP_MACOSX) || defined(MOZ_WIDGET_GTK)
+// defined in nsAppRunner.cpp
+extern const char* kAccessibilityLastRunDatePref;
+
+static inline uint32_t
+PRTimeToSeconds(PRTime t_usec)
+{
+  PRTime usec_per_sec = PR_USEC_PER_SEC;
+  return uint32_t(t_usec /= usec_per_sec);
+}
+#endif
+
+a11y::Accessible*
+nsBaseWidget::GetRootAccessible()
+{
+  NS_ENSURE_TRUE(mWidgetListener, nullptr);
+
+  nsIPresShell* presShell = mWidgetListener->GetPresShell();
+  NS_ENSURE_TRUE(presShell, nullptr);
+
+  // If container is null then the presshell is not active. This often happens
+  // when a preshell is being held onto for fastback.
+  nsPresContext* presContext = presShell->GetPresContext();
+  NS_ENSURE_TRUE(presContext->GetContainerWeak(), nullptr);
+
+  // Accessible creation might be not safe so use IsSafeToRunScript to
+  // make sure it's not created at unsafe times.
+  nsAccessibilityService* accService = GetOrCreateAccService();
+  if (accService) {
+#if defined(XP_WIN) || defined(XP_MACOSX) || defined(MOZ_WIDGET_GTK)
+    if (!mAccessibilityInUseFlag) {
+      mAccessibilityInUseFlag = true;
+      uint32_t now = PRTimeToSeconds(PR_Now());
+      Preferences::SetInt(kAccessibilityLastRunDatePref, now);
+    }
+#endif
+    return accService->GetRootDocumentAccessible(presShell, nsContentUtils::IsSafeToRunScript());
+  }
+
+  return nullptr;
+}
+
+#endif // ACCESSIBILITY
+
+void
+nsBaseWidget::StartAsyncScrollbarDrag(const AsyncDragMetrics& aDragMetrics)
+{
+  if (!AsyncPanZoomEnabled()) {
+    return;
+  }
+
+  MOZ_ASSERT(XRE_IsParentProcess() && mCompositorSession);
+
+  int layersId = mCompositorSession->RootLayerTreeId();;
+  ScrollableLayerGuid guid(layersId, aDragMetrics.mPresShellId, aDragMetrics.mViewId);
+
+  APZThreadUtils::RunOnControllerThread(NewRunnableMethod
+    <ScrollableLayerGuid, AsyncDragMetrics>(mAPZC,
+                                            &IAPZCTreeManager::StartScrollbarDrag,
+                                            guid, aDragMetrics));
+}
+
+already_AddRefed<nsIScreen>
+nsBaseWidget::GetWidgetScreen()
+{
+  nsCOMPtr<nsIScreenManager> screenManager;
+  screenManager = do_GetService("@mozilla.org/gfx/screenmanager;1");
+  if (!screenManager) {
+    return nullptr;
+  }
+
+  LayoutDeviceIntRect bounds = GetScreenBounds();
+  DesktopIntRect deskBounds = RoundedToInt(bounds / GetDesktopToDeviceScale());
+  nsCOMPtr<nsIScreen> screen;
+  screenManager->ScreenForRect(deskBounds.x, deskBounds.y,
+                               deskBounds.width, deskBounds.height,
+                               getter_AddRefs(screen));
+  return screen.forget();
+}
+
+nsresult
+nsIWidget::SynthesizeNativeTouchTap(LayoutDeviceIntPoint aPoint, bool aLongTap,
+                                    nsIObserver* aObserver)
+{
+  AutoObserverNotifier notifier(aObserver, "touchtap");
+
+  if (sPointerIdCounter > TOUCH_INJECT_MAX_POINTS) {
+    sPointerIdCounter = 0;
+  }
+  int pointerId = sPointerIdCounter;
+  sPointerIdCounter++;
+  nsresult rv = SynthesizeNativeTouchPoint(pointerId, TOUCH_CONTACT,
+                                           aPoint, 1.0, 90, nullptr);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  if (!aLongTap) {
+    return SynthesizeNativeTouchPoint(pointerId, TOUCH_REMOVE,
+                                      aPoint, 0, 0, nullptr);
+  }
+
+  // initiate a long tap
+  int elapse = Preferences::GetInt("ui.click_hold_context_menus.delay",
+                                   TOUCH_INJECT_LONG_TAP_DEFAULT_MSEC);
+  if (!mLongTapTimer) {
+    mLongTapTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &rv);
+    if (NS_FAILED(rv)) {
+      SynthesizeNativeTouchPoint(pointerId, TOUCH_CANCEL,
+                                 aPoint, 0, 0, nullptr);
+      return NS_ERROR_UNEXPECTED;
+    }
+    // Windows requires recuring events, so we set this to a smaller window
+    // than the pref value.
+    int timeout = elapse;
+    if (timeout > TOUCH_INJECT_PUMP_TIMER_MSEC) {
+      timeout = TOUCH_INJECT_PUMP_TIMER_MSEC;
+    }
+    mLongTapTimer->InitWithFuncCallback(OnLongTapTimerCallback, this,
+                                        timeout,
+                                        nsITimer::TYPE_REPEATING_SLACK);
+  }
+
+  // If we already have a long tap pending, cancel it. We only allow one long
+  // tap to be active at a time.
+  if (mLongTapTouchPoint) {
+    SynthesizeNativeTouchPoint(mLongTapTouchPoint->mPointerId, TOUCH_CANCEL,
+                               mLongTapTouchPoint->mPosition, 0, 0, nullptr);
+  }
+
+  mLongTapTouchPoint =
+    MakeUnique<LongTapInfo>(pointerId, aPoint,
+                            TimeDuration::FromMilliseconds(elapse),
+                            aObserver);
+  notifier.SkipNotification();  // we'll do it in the long-tap callback
+  return NS_OK;
+}
+
+// static
+void
+nsIWidget::OnLongTapTimerCallback(nsITimer* aTimer, void* aClosure)
+{
+  nsIWidget *self = static_cast<nsIWidget *>(aClosure);
+
+  if ((self->mLongTapTouchPoint->mStamp + self->mLongTapTouchPoint->mDuration) >
+      TimeStamp::Now()) {
+#ifdef XP_WIN
+    // Windows needs us to keep pumping feedback to the digitizer, so update
+    // the pointer id with the same position.
+    self->SynthesizeNativeTouchPoint(self->mLongTapTouchPoint->mPointerId,
+                                     TOUCH_CONTACT,
+                                     self->mLongTapTouchPoint->mPosition,
+                                     1.0, 90, nullptr);
+#endif
+    return;
+  }
+
+  AutoObserverNotifier notifier(self->mLongTapTouchPoint->mObserver, "touchtap");
+
+  // finished, remove the touch point
+  self->mLongTapTimer->Cancel();
+  self->mLongTapTimer = nullptr;
+  self->SynthesizeNativeTouchPoint(self->mLongTapTouchPoint->mPointerId,
+                                   TOUCH_REMOVE,
+                                   self->mLongTapTouchPoint->mPosition,
+                                   0, 0, nullptr);
+  self->mLongTapTouchPoint = nullptr;
+}
+
+nsresult
+nsIWidget::ClearNativeTouchSequence(nsIObserver* aObserver)
+{
+  AutoObserverNotifier notifier(aObserver, "cleartouch");
+
+  if (!mLongTapTimer) {
+    return NS_OK;
+  }
+  mLongTapTimer->Cancel();
+  mLongTapTimer = nullptr;
+  SynthesizeNativeTouchPoint(mLongTapTouchPoint->mPointerId, TOUCH_CANCEL,
+                             mLongTapTouchPoint->mPosition, 0, 0, nullptr);
+  mLongTapTouchPoint = nullptr;
+  return NS_OK;
+}
+
+MultiTouchInput
+nsBaseWidget::UpdateSynthesizedTouchState(MultiTouchInput* aState,
+                                          uint32_t aTime,
+                                          mozilla::TimeStamp aTimeStamp,
+                                          uint32_t aPointerId,
+                                          TouchPointerState aPointerState,
+                                          LayoutDeviceIntPoint aPoint,
+                                          double aPointerPressure,
+                                          uint32_t aPointerOrientation)
+{
+  ScreenIntPoint pointerScreenPoint = ViewAs<ScreenPixel>(aPoint,
+      PixelCastJustification::LayoutDeviceIsScreenForBounds);
+
+  // We can't dispatch *aState directly because (a) dispatching
+  // it might inadvertently modify it and (b) in the case of touchend or
+  // touchcancel events aState will hold the touches that are
+  // still down whereas the input dispatched needs to hold the removed
+  // touch(es). We use |inputToDispatch| for this purpose.
+  MultiTouchInput inputToDispatch;
+  inputToDispatch.mInputType = MULTITOUCH_INPUT;
+  inputToDispatch.mTime = aTime;
+  inputToDispatch.mTimeStamp = aTimeStamp;
+
+  int32_t index = aState->IndexOfTouch((int32_t)aPointerId);
+  if (aPointerState == TOUCH_CONTACT) {
+    if (index >= 0) {
+      // found an existing touch point, update it
+      SingleTouchData& point = aState->mTouches[index];
+      point.mScreenPoint = pointerScreenPoint;
+      point.mRotationAngle = (float)aPointerOrientation;
+      point.mForce = (float)aPointerPressure;
+      inputToDispatch.mType = MultiTouchInput::MULTITOUCH_MOVE;
+    } else {
+      // new touch point, add it
+      aState->mTouches.AppendElement(SingleTouchData(
+          (int32_t)aPointerId,
+          pointerScreenPoint,
+          ScreenSize(0, 0),
+          (float)aPointerOrientation,
+          (float)aPointerPressure));
+      inputToDispatch.mType = MultiTouchInput::MULTITOUCH_START;
+    }
+    inputToDispatch.mTouches = aState->mTouches;
+  } else {
+    MOZ_ASSERT(aPointerState == TOUCH_REMOVE || aPointerState == TOUCH_CANCEL);
+    // a touch point is being lifted, so remove it from the stored list
+    if (index >= 0) {
+      aState->mTouches.RemoveElementAt(index);
+    }
+    inputToDispatch.mType = (aPointerState == TOUCH_REMOVE
+        ? MultiTouchInput::MULTITOUCH_END
+        : MultiTouchInput::MULTITOUCH_CANCEL);
+    inputToDispatch.mTouches.AppendElement(SingleTouchData(
+        (int32_t)aPointerId,
+        pointerScreenPoint,
+        ScreenSize(0, 0),
+        (float)aPointerOrientation,
+        (float)aPointerPressure));
+  }
+
+  return inputToDispatch;
+}
+
+void
+nsBaseWidget::RegisterPluginWindowForRemoteUpdates()
+{
+#if !defined(XP_WIN) && !defined(MOZ_WIDGET_GTK)
+  NS_NOTREACHED("nsBaseWidget::RegisterPluginWindowForRemoteUpdates not implemented!");
+  return;
+#else
+  MOZ_ASSERT(NS_IsMainThread());
+  void* id = GetNativeData(NS_NATIVE_PLUGIN_ID);
+  if (!id) {
+    NS_WARNING("This is not a valid native widget!");
+    return;
+  }
+  MOZ_ASSERT(sPluginWidgetList);
+  sPluginWidgetList->Put(id, this);
+#endif
+}
+
+void
+nsBaseWidget::UnregisterPluginWindowForRemoteUpdates()
+{
+#if !defined(XP_WIN) && !defined(MOZ_WIDGET_GTK)
+  NS_NOTREACHED("nsBaseWidget::UnregisterPluginWindowForRemoteUpdates not implemented!");
+  return;
+#else
+  MOZ_ASSERT(NS_IsMainThread());
+  void* id = GetNativeData(NS_NATIVE_PLUGIN_ID);
+  if (!id) {
+    NS_WARNING("This is not a valid native widget!");
+    return;
+  }
+  MOZ_ASSERT(sPluginWidgetList);
+  sPluginWidgetList->Remove(id);
+#endif
+}
+
+// static
+nsIWidget*
+nsIWidget::LookupRegisteredPluginWindow(uintptr_t aWindowID)
+{
+#if !defined(XP_WIN) && !defined(MOZ_WIDGET_GTK)
+  NS_NOTREACHED("nsBaseWidget::LookupRegisteredPluginWindow not implemented!");
+  return nullptr;
+#else
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(sPluginWidgetList);
+  return sPluginWidgetList->GetWeak((void*)aWindowID);
+#endif
+}
+
+// static
+void
+nsIWidget::UpdateRegisteredPluginWindowVisibility(uintptr_t aOwnerWidget,
+                                                  nsTArray<uintptr_t>& aPluginIds)
+{
+#if !defined(XP_WIN) && !defined(MOZ_WIDGET_GTK)
+  NS_NOTREACHED("nsBaseWidget::UpdateRegisteredPluginWindowVisibility not implemented!");
+  return;
+#else
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(sPluginWidgetList);
+
+  // Our visible list is associated with a compositor which is associated with
+  // a specific top level window. We use the parent widget during iteration
+  // to skip the plugin widgets owned by other top level windows.
+  for (auto iter = sPluginWidgetList->Iter(); !iter.Done(); iter.Next()) {
+    const void* windowId = iter.Key();
+    nsIWidget* widget = iter.UserData();
+
+    MOZ_ASSERT(windowId);
+    MOZ_ASSERT(widget);
+
+    if (!widget->Destroyed()) {
+      if ((uintptr_t)widget->GetParent() == aOwnerWidget) {
+        widget->Show(aPluginIds.Contains((uintptr_t)windowId));
+      }
+    }
+  }
+#endif
+}
+
+#if defined(XP_WIN)
+// static
+void
+nsIWidget::CaptureRegisteredPlugins(uintptr_t aOwnerWidget)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(sPluginWidgetList);
+
+  // Our visible list is associated with a compositor which is associated with
+  // a specific top level window. We use the parent widget during iteration
+  // to skip the plugin widgets owned by other top level windows.
+  for (auto iter = sPluginWidgetList->Iter(); !iter.Done(); iter.Next()) {
+    const void* windowId = iter.Key();
+    nsIWidget* widget = iter.UserData();
+
+    MOZ_ASSERT(windowId);
+    MOZ_ASSERT(widget);
+
+    if (!widget->Destroyed() && widget->IsVisible()) {
+      if ((uintptr_t)widget->GetParent() == aOwnerWidget) {
+        widget->UpdateScrollCapture();
+      }
+    }
+  }
+}
+
+uint64_t
+nsBaseWidget::CreateScrollCaptureContainer()
+{
+  mScrollCaptureContainer =
+    LayerManager::CreateImageContainer(ImageContainer::ASYNCHRONOUS);
+  if (!mScrollCaptureContainer) {
+    NS_WARNING("Failed to create ImageContainer for widget image capture.");
+    return ImageContainer::sInvalidAsyncContainerId;
+  }
+
+  return mScrollCaptureContainer->GetAsyncContainerID();
+}
+
+void
+nsBaseWidget::UpdateScrollCapture()
+{
+  // Don't capture if no container or no size.
+  if (!mScrollCaptureContainer || mBounds.width <= 0 || mBounds.height <= 0) {
+    return;
+  }
+
+  // If the derived class cannot take a snapshot, for example due to clipping,
+  // then it is responsible for creating a fallback. If null is returned, this
+  // means that we want to keep the existing snapshot.
+  RefPtr<gfx::SourceSurface> snapshot = CreateScrollSnapshot();
+  if (!snapshot) {
+    return;
+  }
+
+  ImageContainer::NonOwningImage holder(new SourceSurfaceImage(snapshot));
+
+  AutoTArray<ImageContainer::NonOwningImage, 1> imageList;
+  imageList.AppendElement(holder);
+
+  mScrollCaptureContainer->SetCurrentImages(imageList);
+}
+
+void
+nsBaseWidget::DefaultFillScrollCapture(DrawTarget* aSnapshotDrawTarget)
+{
+  gfx::IntSize dtSize = aSnapshotDrawTarget->GetSize();
+  aSnapshotDrawTarget->FillRect(
+    gfx::Rect(0, 0, dtSize.width, dtSize.height),
+    gfx::ColorPattern(gfx::Color::FromABGR(kScrollCaptureFillColor)),
+    gfx::DrawOptions(1.f, gfx::CompositionOp::OP_SOURCE));
+  aSnapshotDrawTarget->Flush();
+}
+#endif
+
+NS_IMETHODIMP_(nsIWidget::NativeIMEContext)
+nsIWidget::GetNativeIMEContext()
+{
+  return NativeIMEContext(this);
+}
+
+nsresult
+nsIWidget::OnWindowedPluginKeyEvent(const NativeEventData& aKeyEventData,
+                                    nsIKeyEventInPluginCallback* aCallback)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+namespace mozilla {
+namespace widget {
+
+const char*
+ToChar(IMEMessage aIMEMessage)
+{
+  switch (aIMEMessage) {
+    case NOTIFY_IME_OF_NOTHING:
+      return "NOTIFY_IME_OF_NOTHING";
+    case NOTIFY_IME_OF_FOCUS:
+      return "NOTIFY_IME_OF_FOCUS";
+    case NOTIFY_IME_OF_BLUR:
+      return "NOTIFY_IME_OF_BLUR";
+    case NOTIFY_IME_OF_SELECTION_CHANGE:
+      return "NOTIFY_IME_OF_SELECTION_CHANGE";
+    case NOTIFY_IME_OF_TEXT_CHANGE:
+      return "NOTIFY_IME_OF_TEXT_CHANGE";
+    case NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED:
+      return "NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED";
+    case NOTIFY_IME_OF_POSITION_CHANGE:
+      return "NOTIFY_IME_OF_POSITION_CHANGE";
+    case NOTIFY_IME_OF_MOUSE_BUTTON_EVENT:
+      return "NOTIFY_IME_OF_MOUSE_BUTTON_EVENT";
+    case REQUEST_TO_COMMIT_COMPOSITION:
+      return "REQUEST_TO_COMMIT_COMPOSITION";
+    case REQUEST_TO_CANCEL_COMPOSITION:
+      return "REQUEST_TO_CANCEL_COMPOSITION";
+    default:
+      return "Unexpected value";
+  }
+}
+
+void
+NativeIMEContext::Init(nsIWidget* aWidget)
+{
+  if (!aWidget) {
+    mRawNativeIMEContext = reinterpret_cast<uintptr_t>(nullptr);
+    mOriginProcessID = static_cast<uint64_t>(-1);
+    return;
+  }
+  if (!XRE_IsContentProcess()) {
+    mRawNativeIMEContext = reinterpret_cast<uintptr_t>(
+      aWidget->GetNativeData(NS_RAW_NATIVE_IME_CONTEXT));
+    mOriginProcessID = 0;
+    return;
+  }
+  // If this is created in a child process, aWidget is an instance of
+  // PuppetWidget which doesn't support NS_RAW_NATIVE_IME_CONTEXT.
+  // Instead of that PuppetWidget::GetNativeIMEContext() returns cached
+  // native IME context of the parent process.
+  *this = aWidget->GetNativeIMEContext();
+}
+
+void
+NativeIMEContext::InitWithRawNativeIMEContext(void* aRawNativeIMEContext)
+{
+  if (NS_WARN_IF(!aRawNativeIMEContext)) {
+    mRawNativeIMEContext = reinterpret_cast<uintptr_t>(nullptr);
+    mOriginProcessID = static_cast<uint64_t>(-1);
+    return;
+  }
+  mRawNativeIMEContext = reinterpret_cast<uintptr_t>(aRawNativeIMEContext);
+  mOriginProcessID =
+    XRE_IsContentProcess() ? ContentChild::GetSingleton()->GetID() : 0;
+}
+
+void
+IMENotification::TextChangeDataBase::MergeWith(
+                   const IMENotification::TextChangeDataBase& aOther)
+{
+  MOZ_ASSERT(aOther.IsValid(),
+             "Merging data must store valid data");
+  MOZ_ASSERT(aOther.mStartOffset <= aOther.mRemovedEndOffset,
+             "end of removed text must be same or larger than start");
+  MOZ_ASSERT(aOther.mStartOffset <= aOther.mAddedEndOffset,
+             "end of added text must be same or larger than start");
+
+  if (!IsValid()) {
+    *this = aOther;
+    return;
+  }
+
+  // |mStartOffset| and |mRemovedEndOffset| represent all replaced or removed
+  // text ranges.  I.e., mStartOffset should be the smallest offset of all
+  // modified text ranges in old text.  |mRemovedEndOffset| should be the
+  // largest end offset in old text of all modified text ranges.
+  // |mAddedEndOffset| represents the end offset of all inserted text ranges.
+  // I.e., only this is an offset in new text.
+  // In other words, between mStartOffset and |mRemovedEndOffset| of the
+  // premodified text was already removed.  And some text whose length is
+  // |mAddedEndOffset - mStartOffset| is inserted to |mStartOffset|.  I.e.,
+  // this allows IME to mark dirty the modified text range with |mStartOffset|
+  // and |mRemovedEndOffset| if IME stores all text of the focused editor and
+  // to compute new text length with |mAddedEndOffset| and |mRemovedEndOffset|.
+  // Additionally, IME can retrieve only the text between |mStartOffset| and
+  // |mAddedEndOffset| for updating stored text.
+
+  // For comparing new and old |mStartOffset|/|mRemovedEndOffset| values, they
+  // should be adjusted to be in same text. The |newData.mStartOffset| and
+  // |newData.mRemovedEndOffset| should be computed as in old text because
+  // |mStartOffset| and |mRemovedEndOffset| represent the modified text range
+  // in the old text but even if some text before the values of the newData
+  // has already been modified, the values don't include the changes.
+
+  // For comparing new and old |mAddedEndOffset| values, they should be
+  // adjusted to be in same text.  The |oldData.mAddedEndOffset| should be
+  // computed as in the new text because |mAddedEndOffset| indicates the end
+  // offset of inserted text in the new text but |oldData.mAddedEndOffset|
+  // doesn't include any changes of the text before |newData.mAddedEndOffset|.
+
+  const TextChangeDataBase& newData = aOther;
+  const TextChangeDataBase oldData = *this;
+
+  // mCausedOnlyByComposition should be true only when all changes are caused
+  // by composition.
+  mCausedOnlyByComposition =
+    newData.mCausedOnlyByComposition && oldData.mCausedOnlyByComposition;
+
+  // mIncludingChangesWithoutComposition should be true if at least one of
+  // merged changes occurred without composition.
+  mIncludingChangesWithoutComposition =
+    newData.mIncludingChangesWithoutComposition ||
+      oldData.mIncludingChangesWithoutComposition;
+
+  // mIncludingChangesDuringComposition should be true when at least one of
+  // the merged non-composition changes occurred during the latest composition.
+  if (!newData.mCausedOnlyByComposition &&
+      !newData.mIncludingChangesDuringComposition) {
+    MOZ_ASSERT(newData.mIncludingChangesWithoutComposition);
+    MOZ_ASSERT(mIncludingChangesWithoutComposition);
+    // If new change is neither caused by composition nor occurred during
+    // composition, set mIncludingChangesDuringComposition to false because
+    // IME doesn't want outdated text changes as text change during current
+    // composition.
+    mIncludingChangesDuringComposition = false;
+  } else {
+    // Otherwise, set mIncludingChangesDuringComposition to true if either
+    // oldData or newData includes changes during composition.
+    mIncludingChangesDuringComposition =
+      newData.mIncludingChangesDuringComposition ||
+        oldData.mIncludingChangesDuringComposition;
+  }
+
+  if (newData.mStartOffset >= oldData.mAddedEndOffset) {
+    // Case 1:
+    // If new start is after old end offset of added text, it means that text
+    // after the modified range is modified.  Like:
+    // added range of old change:             +----------+
+    // removed range of new change:                           +----------+
+    // So, the old start offset is always the smaller offset.
+    mStartOffset = oldData.mStartOffset;
+    // The new end offset of removed text is moved by the old change and we
+    // need to cancel the move of the old change for comparing the offsets in
+    // same text because it doesn't make sensce to compare offsets in different
+    // text.
+    uint32_t newRemovedEndOffsetInOldText =
+      newData.mRemovedEndOffset - oldData.Difference();
+    mRemovedEndOffset =
+      std::max(newRemovedEndOffsetInOldText, oldData.mRemovedEndOffset);
+    // The new end offset of added text is always the larger offset.
+    mAddedEndOffset = newData.mAddedEndOffset;
+    return;
+  }
+
+  if (newData.mStartOffset >= oldData.mStartOffset) {
+    // If new start is in the modified range, it means that new data changes
+    // a part or all of the range.
+    mStartOffset = oldData.mStartOffset;
+    if (newData.mRemovedEndOffset >= oldData.mAddedEndOffset) {
+      // Case 2:
+      // If new end of removed text is greater than old end of added text, it
+      // means that all or a part of modified range modified again and text
+      // after the modified range is also modified.  Like:
+      // added range of old change:             +----------+
+      // removed range of new change:                   +----------+
+      // So, the new removed end offset is moved by the old change and we need
+      // to cancel the move of the old change for comparing the offsets in the
+      // same text because it doesn't make sense to compare the offsets in
+      // different text.
+      uint32_t newRemovedEndOffsetInOldText =
+        newData.mRemovedEndOffset - oldData.Difference();
+      mRemovedEndOffset =
+        std::max(newRemovedEndOffsetInOldText, oldData.mRemovedEndOffset);
+      // The old end of added text is replaced by new change. So, it should be
+      // same as the new start.  On the other hand, the new added end offset is
+      // always same or larger.  Therefore, the merged end offset of added
+      // text should be the new end offset of added text.
+      mAddedEndOffset = newData.mAddedEndOffset;
+      return;
+    }
+
+    // Case 3:
+    // If new end of removed text is less than old end of added text, it means
+    // that only a part of the modified range is modified again.  Like:
+    // added range of old change:             +------------+
+    // removed range of new change:               +-----+
+    // So, the new end offset of removed text should be same as the old end
+    // offset of removed text.  Therefore, the merged end offset of removed
+    // text should be the old text change's |mRemovedEndOffset|.
+    mRemovedEndOffset = oldData.mRemovedEndOffset;
+    // The old end of added text is moved by new change.  So, we need to cancel
+    // the move of the new change for comparing the offsets in same text.
+    uint32_t oldAddedEndOffsetInNewText =
+      oldData.mAddedEndOffset + newData.Difference();
+    mAddedEndOffset =
+      std::max(newData.mAddedEndOffset, oldAddedEndOffsetInNewText);
+    return;
+  }
+
+  if (newData.mRemovedEndOffset >= oldData.mStartOffset) {
+    // If new end of removed text is greater than old start (and new start is
+    // less than old start), it means that a part of modified range is modified
+    // again and some new text before the modified range is also modified.
+    MOZ_ASSERT(newData.mStartOffset < oldData.mStartOffset,
+      "new start offset should be less than old one here");
+    mStartOffset = newData.mStartOffset;
+    if (newData.mRemovedEndOffset >= oldData.mAddedEndOffset) {
+      // Case 4:
+      // If new end of removed text is greater than old end of added text, it
+      // means that all modified text and text after the modified range is
+      // modified.  Like:
+      // added range of old change:             +----------+
+      // removed range of new change:        +------------------+
+      // So, the new end of removed text is moved by the old change.  Therefore,
+      // we need to cancel the move of the old change for comparing the offsets
+      // in same text because it doesn't make sense to compare the offsets in
+      // different text.
+      uint32_t newRemovedEndOffsetInOldText =
+        newData.mRemovedEndOffset - oldData.Difference();
+      mRemovedEndOffset =
+        std::max(newRemovedEndOffsetInOldText, oldData.mRemovedEndOffset);
+      // The old end of added text is replaced by new change.  So, the old end
+      // offset of added text is same as new text change's start offset.  Then,
+      // new change's end offset of added text is always same or larger than
+      // it.  Therefore, merged end offset of added text is always the new end
+      // offset of added text.
+      mAddedEndOffset = newData.mAddedEndOffset;
+      return;
+    }
+
+    // Case 5:
+    // If new end of removed text is less than old end of added text, it
+    // means that only a part of the modified range is modified again.  Like:
+    // added range of old change:             +----------+
+    // removed range of new change:      +----------+
+    // So, the new end of removed text should be same as old end of removed
+    // text for preventing end of removed text to be modified.  Therefore,
+    // merged end offset of removed text is always the old end offset of removed
+    // text.
+    mRemovedEndOffset = oldData.mRemovedEndOffset;
+    // The old end of added text is moved by this change.  So, we need to
+    // cancel the move of the new change for comparing the offsets in same text
+    // because it doesn't make sense to compare the offsets in different text.
+    uint32_t oldAddedEndOffsetInNewText =
+      oldData.mAddedEndOffset + newData.Difference();
+    mAddedEndOffset =
+      std::max(newData.mAddedEndOffset, oldAddedEndOffsetInNewText);
+    return;
+  }
+
+  // Case 6:
+  // Otherwise, i.e., both new end of added text and new start are less than
+  // old start, text before the modified range is modified.  Like:
+  // added range of old change:                  +----------+
+  // removed range of new change: +----------+
+  MOZ_ASSERT(newData.mStartOffset < oldData.mStartOffset,
+    "new start offset should be less than old one here");
+  mStartOffset = newData.mStartOffset;
+  MOZ_ASSERT(newData.mRemovedEndOffset < oldData.mRemovedEndOffset,
+     "new removed end offset should be less than old one here");
+  mRemovedEndOffset = oldData.mRemovedEndOffset;
+  // The end of added text should be adjusted with the new difference.
+  uint32_t oldAddedEndOffsetInNewText =
+    oldData.mAddedEndOffset + newData.Difference();
+  mAddedEndOffset =
+    std::max(newData.mAddedEndOffset, oldAddedEndOffsetInNewText);
+}
+
+#ifdef DEBUG
+
+// Let's test the code of merging multiple text change data in debug build
+// and crash if one of them fails because this feature is very complex but
+// cannot be tested with mochitest.
+void
+IMENotification::TextChangeDataBase::Test()
+{
+  static bool gTestTextChangeEvent = true;
+  if (!gTestTextChangeEvent) {
+    return;
+  }
+  gTestTextChangeEvent = false;
+
+  /****************************************************************************
+   * Case 1
+   ****************************************************************************/
+
+  // Appending text
+  MergeWith(TextChangeData(10, 10, 20, false, false));
+  MergeWith(TextChangeData(20, 20, 35, false, false));
+  MOZ_ASSERT(mStartOffset == 10,
+    "Test 1-1-1: mStartOffset should be the first offset");
+  MOZ_ASSERT(mRemovedEndOffset == 10, // 20 - (20 - 10)
+    "Test 1-1-2: mRemovedEndOffset should be the first end of removed text");
+  MOZ_ASSERT(mAddedEndOffset == 35,
+    "Test 1-1-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Removing text (longer line -> shorter line)
+  MergeWith(TextChangeData(10, 20, 10, false, false));
+  MergeWith(TextChangeData(10, 30, 10, false, false));
+  MOZ_ASSERT(mStartOffset == 10,
+    "Test 1-2-1: mStartOffset should be the first offset");
+  MOZ_ASSERT(mRemovedEndOffset == 40, // 30 + (10 - 20)
+    "Test 1-2-2: mRemovedEndOffset should be the the last end of removed text "
+    "with already removed length");
+  MOZ_ASSERT(mAddedEndOffset == 10,
+    "Test 1-2-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Removing text (shorter line -> longer line)
+  MergeWith(TextChangeData(10, 20, 10, false, false));
+  MergeWith(TextChangeData(10, 15, 10, false, false));
+  MOZ_ASSERT(mStartOffset == 10,
+    "Test 1-3-1: mStartOffset should be the first offset");
+  MOZ_ASSERT(mRemovedEndOffset == 25, // 15 + (10 - 20)
+    "Test 1-3-2: mRemovedEndOffset should be the the last end of removed text "
+    "with already removed length");
+  MOZ_ASSERT(mAddedEndOffset == 10,
+    "Test 1-3-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Appending text at different point (not sure if actually occurs)
+  MergeWith(TextChangeData(10, 10, 20, false, false));
+  MergeWith(TextChangeData(55, 55, 60, false, false));
+  MOZ_ASSERT(mStartOffset == 10,
+    "Test 1-4-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 45, // 55 - (10 - 20)
+    "Test 1-4-2: mRemovedEndOffset should be the the largest end of removed "
+    "text without already added length");
+  MOZ_ASSERT(mAddedEndOffset == 60,
+    "Test 1-4-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Removing text at different point (not sure if actually occurs)
+  MergeWith(TextChangeData(10, 20, 10, false, false));
+  MergeWith(TextChangeData(55, 68, 55, false, false));
+  MOZ_ASSERT(mStartOffset == 10,
+    "Test 1-5-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 78, // 68 - (10 - 20)
+    "Test 1-5-2: mRemovedEndOffset should be the the largest end of removed "
+    "text with already removed length");
+  MOZ_ASSERT(mAddedEndOffset == 55,
+    "Test 1-5-3: mAddedEndOffset should be the largest end of added text");
+  Clear();
+
+  // Replacing text and append text (becomes longer)
+  MergeWith(TextChangeData(30, 35, 32, false, false));
+  MergeWith(TextChangeData(32, 32, 40, false, false));
+  MOZ_ASSERT(mStartOffset == 30,
+    "Test 1-6-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 35, // 32 - (32 - 35)
+    "Test 1-6-2: mRemovedEndOffset should be the the first end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 40,
+    "Test 1-6-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Replacing text and append text (becomes shorter)
+  MergeWith(TextChangeData(30, 35, 32, false, false));
+  MergeWith(TextChangeData(32, 32, 33, false, false));
+  MOZ_ASSERT(mStartOffset == 30,
+    "Test 1-7-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 35, // 32 - (32 - 35)
+    "Test 1-7-2: mRemovedEndOffset should be the the first end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 33,
+    "Test 1-7-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Removing text and replacing text after first range (not sure if actually
+  // occurs)
+  MergeWith(TextChangeData(30, 35, 30, false, false));
+  MergeWith(TextChangeData(32, 34, 48, false, false));
+  MOZ_ASSERT(mStartOffset == 30,
+    "Test 1-8-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 39, // 34 - (30 - 35)
+    "Test 1-8-2: mRemovedEndOffset should be the the first end of removed text "
+    "without already removed text");
+  MOZ_ASSERT(mAddedEndOffset == 48,
+    "Test 1-8-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Removing text and replacing text after first range (not sure if actually
+  // occurs)
+  MergeWith(TextChangeData(30, 35, 30, false, false));
+  MergeWith(TextChangeData(32, 38, 36, false, false));
+  MOZ_ASSERT(mStartOffset == 30,
+    "Test 1-9-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 43, // 38 - (30 - 35)
+    "Test 1-9-2: mRemovedEndOffset should be the the first end of removed text "
+    "without already removed text");
+  MOZ_ASSERT(mAddedEndOffset == 36,
+    "Test 1-9-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  /****************************************************************************
+   * Case 2
+   ****************************************************************************/
+
+  // Replacing text in around end of added text (becomes shorter) (not sure
+  // if actually occurs)
+  MergeWith(TextChangeData(50, 50, 55, false, false));
+  MergeWith(TextChangeData(53, 60, 54, false, false));
+  MOZ_ASSERT(mStartOffset == 50,
+    "Test 2-1-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 55, // 60 - (55 - 50)
+    "Test 2-1-2: mRemovedEndOffset should be the the last end of removed text "
+    "without already added text length");
+  MOZ_ASSERT(mAddedEndOffset == 54,
+    "Test 2-1-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Replacing text around end of added text (becomes longer) (not sure
+  // if actually occurs)
+  MergeWith(TextChangeData(50, 50, 55, false, false));
+  MergeWith(TextChangeData(54, 62, 68, false, false));
+  MOZ_ASSERT(mStartOffset == 50,
+    "Test 2-2-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 57, // 62 - (55 - 50)
+    "Test 2-2-2: mRemovedEndOffset should be the the last end of removed text "
+    "without already added text length");
+  MOZ_ASSERT(mAddedEndOffset == 68,
+    "Test 2-2-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Replacing text around end of replaced text (became shorter) (not sure if
+  // actually occurs)
+  MergeWith(TextChangeData(36, 48, 45, false, false));
+  MergeWith(TextChangeData(43, 50, 49, false, false));
+  MOZ_ASSERT(mStartOffset == 36,
+    "Test 2-3-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 53, // 50 - (45 - 48)
+    "Test 2-3-2: mRemovedEndOffset should be the the last end of removed text "
+    "without already removed text length");
+  MOZ_ASSERT(mAddedEndOffset == 49,
+    "Test 2-3-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Replacing text around end of replaced text (became longer) (not sure if
+  // actually occurs)
+  MergeWith(TextChangeData(36, 52, 53, false, false));
+  MergeWith(TextChangeData(43, 68, 61, false, false));
+  MOZ_ASSERT(mStartOffset == 36,
+    "Test 2-4-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 67, // 68 - (53 - 52)
+    "Test 2-4-2: mRemovedEndOffset should be the the last end of removed text "
+    "without already added text length");
+  MOZ_ASSERT(mAddedEndOffset == 61,
+    "Test 2-4-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  /****************************************************************************
+   * Case 3
+   ****************************************************************************/
+
+  // Appending text in already added text (not sure if actually occurs)
+  MergeWith(TextChangeData(10, 10, 20, false, false));
+  MergeWith(TextChangeData(15, 15, 30, false, false));
+  MOZ_ASSERT(mStartOffset == 10,
+    "Test 3-1-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 10,
+    "Test 3-1-2: mRemovedEndOffset should be the the first end of removed text");
+  MOZ_ASSERT(mAddedEndOffset == 35, // 20 + (30 - 15)
+    "Test 3-1-3: mAddedEndOffset should be the first end of added text with "
+    "added text length by the new change");
+  Clear();
+
+  // Replacing text in added text (not sure if actually occurs)
+  MergeWith(TextChangeData(50, 50, 55, false, false));
+  MergeWith(TextChangeData(52, 53, 56, false, false));
+  MOZ_ASSERT(mStartOffset == 50,
+    "Test 3-2-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 50,
+    "Test 3-2-2: mRemovedEndOffset should be the the first end of removed text");
+  MOZ_ASSERT(mAddedEndOffset == 58, // 55 + (56 - 53)
+    "Test 3-2-3: mAddedEndOffset should be the first end of added text with "
+    "added text length by the new change");
+  Clear();
+
+  // Replacing text in replaced text (became shorter) (not sure if actually
+  // occurs)
+  MergeWith(TextChangeData(36, 48, 45, false, false));
+  MergeWith(TextChangeData(37, 38, 50, false, false));
+  MOZ_ASSERT(mStartOffset == 36,
+    "Test 3-3-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 48,
+    "Test 3-3-2: mRemovedEndOffset should be the the first end of removed text");
+  MOZ_ASSERT(mAddedEndOffset == 57, // 45 + (50 - 38)
+    "Test 3-3-3: mAddedEndOffset should be the first end of added text with "
+    "added text length by the new change");
+  Clear();
+
+  // Replacing text in replaced text (became longer) (not sure if actually
+  // occurs)
+  MergeWith(TextChangeData(32, 48, 53, false, false));
+  MergeWith(TextChangeData(43, 50, 52, false, false));
+  MOZ_ASSERT(mStartOffset == 32,
+    "Test 3-4-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 48,
+    "Test 3-4-2: mRemovedEndOffset should be the the last end of removed text "
+    "without already added text length");
+  MOZ_ASSERT(mAddedEndOffset == 55, // 53 + (52 - 50)
+    "Test 3-4-3: mAddedEndOffset should be the first end of added text with "
+    "added text length by the new change");
+  Clear();
+
+  // Replacing text in replaced text (became shorter) (not sure if actually
+  // occurs)
+  MergeWith(TextChangeData(36, 48, 50, false, false));
+  MergeWith(TextChangeData(37, 49, 47, false, false));
+  MOZ_ASSERT(mStartOffset == 36,
+    "Test 3-5-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 48,
+    "Test 3-5-2: mRemovedEndOffset should be the the first end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 48, // 50 + (47 - 49)
+    "Test 3-5-3: mAddedEndOffset should be the first end of added text without "
+    "removed text length by the new change");
+  Clear();
+
+  // Replacing text in replaced text (became longer) (not sure if actually
+  // occurs)
+  MergeWith(TextChangeData(32, 48, 53, false, false));
+  MergeWith(TextChangeData(43, 50, 47, false, false));
+  MOZ_ASSERT(mStartOffset == 32,
+    "Test 3-6-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 48,
+    "Test 3-6-2: mRemovedEndOffset should be the the last end of removed text "
+    "without already added text length");
+  MOZ_ASSERT(mAddedEndOffset == 50, // 53 + (47 - 50)
+    "Test 3-6-3: mAddedEndOffset should be the first end of added text without "
+    "removed text length by the new change");
+  Clear();
+
+  /****************************************************************************
+   * Case 4
+   ****************************************************************************/
+
+  // Replacing text all of already append text (not sure if actually occurs)
+  MergeWith(TextChangeData(50, 50, 55, false, false));
+  MergeWith(TextChangeData(44, 66, 68, false, false));
+  MOZ_ASSERT(mStartOffset == 44,
+    "Test 4-1-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 61, // 66 - (55 - 50)
+    "Test 4-1-2: mRemovedEndOffset should be the the last end of removed text "
+    "without already added text length");
+  MOZ_ASSERT(mAddedEndOffset == 68,
+    "Test 4-1-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Replacing text around a point in which text was removed (not sure if
+  // actually occurs)
+  MergeWith(TextChangeData(50, 62, 50, false, false));
+  MergeWith(TextChangeData(44, 66, 68, false, false));
+  MOZ_ASSERT(mStartOffset == 44,
+    "Test 4-2-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 78, // 66 - (50 - 62)
+    "Test 4-2-2: mRemovedEndOffset should be the the last end of removed text "
+    "without already removed text length");
+  MOZ_ASSERT(mAddedEndOffset == 68,
+    "Test 4-2-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Replacing text all replaced text (became shorter) (not sure if actually
+  // occurs)
+  MergeWith(TextChangeData(50, 62, 60, false, false));
+  MergeWith(TextChangeData(49, 128, 130, false, false));
+  MOZ_ASSERT(mStartOffset == 49,
+    "Test 4-3-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 130, // 128 - (60 - 62)
+    "Test 4-3-2: mRemovedEndOffset should be the the last end of removed text "
+    "without already removed text length");
+  MOZ_ASSERT(mAddedEndOffset == 130,
+    "Test 4-3-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  // Replacing text all replaced text (became longer) (not sure if actually
+  // occurs)
+  MergeWith(TextChangeData(50, 61, 73, false, false));
+  MergeWith(TextChangeData(44, 100, 50, false, false));
+  MOZ_ASSERT(mStartOffset == 44,
+    "Test 4-4-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 88, // 100 - (73 - 61)
+    "Test 4-4-2: mRemovedEndOffset should be the the last end of removed text "
+    "with already added text length");
+  MOZ_ASSERT(mAddedEndOffset == 50,
+    "Test 4-4-3: mAddedEndOffset should be the last end of added text");
+  Clear();
+
+  /****************************************************************************
+   * Case 5
+   ****************************************************************************/
+
+  // Replacing text around start of added text (not sure if actually occurs)
+  MergeWith(TextChangeData(50, 50, 55, false, false));
+  MergeWith(TextChangeData(48, 52, 49, false, false));
+  MOZ_ASSERT(mStartOffset == 48,
+    "Test 5-1-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 50,
+    "Test 5-1-2: mRemovedEndOffset should be the the first end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 52, // 55 + (52 - 49)
+    "Test 5-1-3: mAddedEndOffset should be the first end of added text with "
+    "added text length by the new change");
+  Clear();
+
+  // Replacing text around start of replaced text (became shorter) (not sure if
+  // actually occurs)
+  MergeWith(TextChangeData(50, 60, 58, false, false));
+  MergeWith(TextChangeData(43, 50, 48, false, false));
+  MOZ_ASSERT(mStartOffset == 43,
+    "Test 5-2-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 60,
+    "Test 5-2-2: mRemovedEndOffset should be the the first end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 56, // 58 + (48 - 50)
+    "Test 5-2-3: mAddedEndOffset should be the first end of added text without "
+    "removed text length by the new change");
+  Clear();
+
+  // Replacing text around start of replaced text (became longer) (not sure if
+  // actually occurs)
+  MergeWith(TextChangeData(50, 60, 68, false, false));
+  MergeWith(TextChangeData(43, 55, 53, false, false));
+  MOZ_ASSERT(mStartOffset == 43,
+    "Test 5-3-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 60,
+    "Test 5-3-2: mRemovedEndOffset should be the the first end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 66, // 68 + (53 - 55)
+    "Test 5-3-3: mAddedEndOffset should be the first end of added text without "
+    "removed text length by the new change");
+  Clear();
+
+  // Replacing text around start of replaced text (became shorter) (not sure if
+  // actually occurs)
+  MergeWith(TextChangeData(50, 60, 58, false, false));
+  MergeWith(TextChangeData(43, 50, 128, false, false));
+  MOZ_ASSERT(mStartOffset == 43,
+    "Test 5-4-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 60,
+    "Test 5-4-2: mRemovedEndOffset should be the the first end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 136, // 58 + (128 - 50)
+    "Test 5-4-3: mAddedEndOffset should be the first end of added text with "
+    "added text length by the new change");
+  Clear();
+
+  // Replacing text around start of replaced text (became longer) (not sure if
+  // actually occurs)
+  MergeWith(TextChangeData(50, 60, 68, false, false));
+  MergeWith(TextChangeData(43, 55, 65, false, false));
+  MOZ_ASSERT(mStartOffset == 43,
+    "Test 5-5-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 60,
+    "Test 5-5-2: mRemovedEndOffset should be the the first end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 78, // 68 + (65 - 55)
+    "Test 5-5-3: mAddedEndOffset should be the first end of added text with "
+    "added text length by the new change");
+  Clear();
+
+  /****************************************************************************
+   * Case 6
+   ****************************************************************************/
+
+  // Appending text before already added text (not sure if actually occurs)
+  MergeWith(TextChangeData(30, 30, 45, false, false));
+  MergeWith(TextChangeData(10, 10, 20, false, false));
+  MOZ_ASSERT(mStartOffset == 10,
+    "Test 6-1-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 30,
+    "Test 6-1-2: mRemovedEndOffset should be the the largest end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 55, // 45 + (20 - 10)
+    "Test 6-1-3: mAddedEndOffset should be the first end of added text with "
+    "added text length by the new change");
+  Clear();
+
+  // Removing text before already removed text (not sure if actually occurs)
+  MergeWith(TextChangeData(30, 35, 30, false, false));
+  MergeWith(TextChangeData(10, 25, 10, false, false));
+  MOZ_ASSERT(mStartOffset == 10,
+    "Test 6-2-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 35,
+    "Test 6-2-2: mRemovedEndOffset should be the the largest end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 15, // 30 - (25 - 10)
+    "Test 6-2-3: mAddedEndOffset should be the first end of added text with "
+    "removed text length by the new change");
+  Clear();
+
+  // Replacing text before already replaced text (not sure if actually occurs)
+  MergeWith(TextChangeData(50, 65, 70, false, false));
+  MergeWith(TextChangeData(13, 24, 15, false, false));
+  MOZ_ASSERT(mStartOffset == 13,
+    "Test 6-3-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 65,
+    "Test 6-3-2: mRemovedEndOffset should be the the largest end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 61, // 70 + (15 - 24)
+    "Test 6-3-3: mAddedEndOffset should be the first end of added text without "
+    "removed text length by the new change");
+  Clear();
+
+  // Replacing text before already replaced text (not sure if actually occurs)
+  MergeWith(TextChangeData(50, 65, 70, false, false));
+  MergeWith(TextChangeData(13, 24, 36, false, false));
+  MOZ_ASSERT(mStartOffset == 13,
+    "Test 6-4-1: mStartOffset should be the smallest offset");
+  MOZ_ASSERT(mRemovedEndOffset == 65,
+    "Test 6-4-2: mRemovedEndOffset should be the the largest end of removed "
+    "text");
+  MOZ_ASSERT(mAddedEndOffset == 82, // 70 + (36 - 24)
+    "Test 6-4-3: mAddedEndOffset should be the first end of added text without "
+    "removed text length by the new change");
+  Clear();
+}
+
+#endif // #ifdef DEBUG
+
+} // namespace widget
+} // namespace mozilla
+
+#ifdef DEBUG
+//////////////////////////////////////////////////////////////
+//
+// Convert a GUI event message code to a string.
+// Makes it a lot easier to debug events.
+//
+// See gtk/nsWidget.cpp and windows/nsWindow.cpp
+// for a DebugPrintEvent() function that uses
+// this.
+//
+//////////////////////////////////////////////////////////////
+/* static */ nsAutoString
+nsBaseWidget::debug_GuiEventToString(WidgetGUIEvent* aGuiEvent)
+{
+  NS_ASSERTION(nullptr != aGuiEvent,"cmon, null gui event.");
+
+  nsAutoString eventName(NS_LITERAL_STRING("UNKNOWN"));
+
+#define _ASSIGN_eventName(_value,_name)\
+case _value: eventName.AssignLiteral(_name) ; break
+
+  switch(aGuiEvent->mMessage)
+  {
+    _ASSIGN_eventName(eBlur,"eBlur");
+    _ASSIGN_eventName(eDrop,"eDrop");
+    _ASSIGN_eventName(eDragEnter,"eDragEnter");
+    _ASSIGN_eventName(eDragExit,"eDragExit");
+    _ASSIGN_eventName(eDragOver,"eDragOver");
+    _ASSIGN_eventName(eEditorInput,"eEditorInput");
+    _ASSIGN_eventName(eFocus,"eFocus");
+    _ASSIGN_eventName(eFocusIn,"eFocusIn");
+    _ASSIGN_eventName(eFocusOut,"eFocusOut");
+    _ASSIGN_eventName(eFormSelect,"eFormSelect");
+    _ASSIGN_eventName(eFormChange,"eFormChange");
+    _ASSIGN_eventName(eFormReset,"eFormReset");
+    _ASSIGN_eventName(eFormSubmit,"eFormSubmit");
+    _ASSIGN_eventName(eImageAbort,"eImageAbort");
+    _ASSIGN_eventName(eLoadError,"eLoadError");
+    _ASSIGN_eventName(eKeyDown,"eKeyDown");
+    _ASSIGN_eventName(eKeyPress,"eKeyPress");
+    _ASSIGN_eventName(eKeyUp,"eKeyUp");
+    _ASSIGN_eventName(eMouseEnterIntoWidget,"eMouseEnterIntoWidget");
+    _ASSIGN_eventName(eMouseExitFromWidget,"eMouseExitFromWidget");
+    _ASSIGN_eventName(eMouseDown,"eMouseDown");
+    _ASSIGN_eventName(eMouseUp,"eMouseUp");
+    _ASSIGN_eventName(eMouseClick,"eMouseClick");
+    _ASSIGN_eventName(eMouseDoubleClick,"eMouseDoubleClick");
+    _ASSIGN_eventName(eMouseMove,"eMouseMove");
+    _ASSIGN_eventName(eLoad,"eLoad");
+    _ASSIGN_eventName(ePopState,"ePopState");
+    _ASSIGN_eventName(eBeforeScriptExecute,"eBeforeScriptExecute");
+    _ASSIGN_eventName(eAfterScriptExecute,"eAfterScriptExecute");
+    _ASSIGN_eventName(eUnload,"eUnload");
+    _ASSIGN_eventName(eHashChange,"eHashChange");
+    _ASSIGN_eventName(eReadyStateChange,"eReadyStateChange");
+    _ASSIGN_eventName(eXULBroadcast, "eXULBroadcast");
+    _ASSIGN_eventName(eXULCommandUpdate, "eXULCommandUpdate");
+
+#undef _ASSIGN_eventName
+
+  default:
+    {
+      char buf[32];
+
+      SprintfLiteral(buf,"UNKNOWN: %d",aGuiEvent->mMessage);
+
+      CopyASCIItoUTF16(buf, eventName);
+    }
+    break;
+  }
+
+  return nsAutoString(eventName);
+}
+//////////////////////////////////////////////////////////////
+//
+// Code to deal with paint and event debug prefs.
+//
+//////////////////////////////////////////////////////////////
+struct PrefPair
+{
+  const char * name;
+  bool value;
+};
+
+static PrefPair debug_PrefValues[] =
+{
+  { "nglayout.debug.crossing_event_dumping", false },
+  { "nglayout.debug.event_dumping", false },
+  { "nglayout.debug.invalidate_dumping", false },
+  { "nglayout.debug.motion_event_dumping", false },
+  { "nglayout.debug.paint_dumping", false },
+  { "nglayout.debug.paint_flashing", false }
+};
+
+//////////////////////////////////////////////////////////////
+bool
+nsBaseWidget::debug_GetCachedBoolPref(const char * aPrefName)
+{
+  NS_ASSERTION(nullptr != aPrefName,"cmon, pref name is null.");
+
+  for (uint32_t i = 0; i < ArrayLength(debug_PrefValues); i++)
+  {
+    if (strcmp(debug_PrefValues[i].name, aPrefName) == 0)
+    {
+      return debug_PrefValues[i].value;
+    }
+  }
+
+  return false;
+}
+//////////////////////////////////////////////////////////////
+static void debug_SetCachedBoolPref(const char * aPrefName,bool aValue)
+{
+  NS_ASSERTION(nullptr != aPrefName,"cmon, pref name is null.");
+
+  for (uint32_t i = 0; i < ArrayLength(debug_PrefValues); i++)
+  {
+    if (strcmp(debug_PrefValues[i].name, aPrefName) == 0)
+    {
+      debug_PrefValues[i].value = aValue;
+
+      return;
+    }
+  }
+
+  NS_ASSERTION(false, "cmon, this code is not reached dude.");
+}
+
+//////////////////////////////////////////////////////////////
+class Debug_PrefObserver final : public nsIObserver {
+    ~Debug_PrefObserver() {}
+
+  public:
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIOBSERVER
+};
+
+NS_IMPL_ISUPPORTS(Debug_PrefObserver, nsIObserver)
+
+NS_IMETHODIMP
+Debug_PrefObserver::Observe(nsISupports* subject, const char* topic,
+                            const char16_t* data)
+{
+  NS_ConvertUTF16toUTF8 prefName(data);
+
+  bool value = Preferences::GetBool(prefName.get(), false);
+  debug_SetCachedBoolPref(prefName.get(), value);
+  return NS_OK;
+}
+
+//////////////////////////////////////////////////////////////
+/* static */ void
+debug_RegisterPrefCallbacks()
+{
+  static bool once = true;
+
+  if (!once) {
+    return;
+  }
+
+  once = false;
+
+  nsCOMPtr<nsIObserver> obs(new Debug_PrefObserver());
+  for (uint32_t i = 0; i < ArrayLength(debug_PrefValues); i++) {
+    // Initialize the pref values
+    debug_PrefValues[i].value =
+      Preferences::GetBool(debug_PrefValues[i].name, false);
+
+    if (obs) {
+      // Register callbacks for when these change
+      Preferences::AddStrongObserver(obs, debug_PrefValues[i].name);
+    }
+  }
+}
+//////////////////////////////////////////////////////////////
+static int32_t
+_GetPrintCount()
+{
+  static int32_t sCount = 0;
+
+  return ++sCount;
+}
+//////////////////////////////////////////////////////////////
+/* static */ bool
+nsBaseWidget::debug_WantPaintFlashing()
+{
+  return debug_GetCachedBoolPref("nglayout.debug.paint_flashing");
+}
+//////////////////////////////////////////////////////////////
+/* static */ void
+nsBaseWidget::debug_DumpEvent(FILE *                aFileOut,
+                              nsIWidget *           aWidget,
+                              WidgetGUIEvent*       aGuiEvent,
+                              const char*           aWidgetName,
+                              int32_t               aWindowID)
+{
+  if (aGuiEvent->mMessage == eMouseMove) {
+    if (!debug_GetCachedBoolPref("nglayout.debug.motion_event_dumping"))
+      return;
+  }
+
+  if (aGuiEvent->mMessage == eMouseEnterIntoWidget ||
+      aGuiEvent->mMessage == eMouseExitFromWidget) {
+    if (!debug_GetCachedBoolPref("nglayout.debug.crossing_event_dumping"))
+      return;
+  }
+
+  if (!debug_GetCachedBoolPref("nglayout.debug.event_dumping"))
+    return;
+
+  NS_LossyConvertUTF16toASCII tempString(debug_GuiEventToString(aGuiEvent).get());
+
+  fprintf(aFileOut,
+          "%4d %-26s widget=%-8p name=%-12s id=0x%-6x refpt=%d,%d\n",
+          _GetPrintCount(),
+          tempString.get(),
+          (void *) aWidget,
+          aWidgetName,
+          aWindowID,
+          aGuiEvent->mRefPoint.x,
+          aGuiEvent->mRefPoint.y);
+}
+//////////////////////////////////////////////////////////////
+/* static */ void
+nsBaseWidget::debug_DumpPaintEvent(FILE *                aFileOut,
+                                   nsIWidget *           aWidget,
+                                   const nsIntRegion &   aRegion,
+                                   const char *          aWidgetName,
+                                   int32_t               aWindowID)
+{
+  NS_ASSERTION(nullptr != aFileOut,"cmon, null output FILE");
+  NS_ASSERTION(nullptr != aWidget,"cmon, the widget is null");
+
+  if (!debug_GetCachedBoolPref("nglayout.debug.paint_dumping"))
+    return;
+
+  nsIntRect rect = aRegion.GetBounds();
+  fprintf(aFileOut,
+          "%4d PAINT      widget=%p name=%-12s id=0x%-6x bounds-rect=%3d,%-3d %3d,%-3d",
+          _GetPrintCount(),
+          (void *) aWidget,
+          aWidgetName,
+          aWindowID,
+          rect.x, rect.y, rect.width, rect.height
+    );
+
+  fprintf(aFileOut,"\n");
+}
+//////////////////////////////////////////////////////////////
+/* static */ void
+nsBaseWidget::debug_DumpInvalidate(FILE* aFileOut,
+                                   nsIWidget* aWidget,
+                                   const LayoutDeviceIntRect* aRect,
+                                   const char* aWidgetName,
+                                   int32_t aWindowID)
+{
+  if (!debug_GetCachedBoolPref("nglayout.debug.invalidate_dumping"))
+    return;
+
+  NS_ASSERTION(nullptr != aFileOut,"cmon, null output FILE");
+  NS_ASSERTION(nullptr != aWidget,"cmon, the widget is null");
+
+  fprintf(aFileOut,
+          "%4d Invalidate widget=%p name=%-12s id=0x%-6x",
+          _GetPrintCount(),
+          (void *) aWidget,
+          aWidgetName,
+          aWindowID);
+
+  if (aRect) {
+    fprintf(aFileOut,
+            " rect=%3d,%-3d %3d,%-3d",
+            aRect->x, aRect->y, aRect->width, aRect->height);
+  } else {
+    fprintf(aFileOut,
+            " rect=%-15s",
+            "none");
+  }
+
+  fprintf(aFileOut, "\n");
+}
+//////////////////////////////////////////////////////////////
+
+#endif // DEBUG
diff -rupN a/widget/nsIWidget.h b/widget/nsIWidget.h
--- a/widget/nsIWidget.h	2017-01-23 11:13:56.000000000 -0500
+++ b/widget/nsIWidget.h	2017-03-07 23:40:34.293635643 -0500
@@ -132,6 +132,8 @@ typedef void* nsNativeWidget;
 #define NS_NATIVE_PLUGIN_OBJECT_PTR    104
 #ifdef MOZ_X11
 #define NS_NATIVE_COMPOSITOR_DISPLAY   105
+// Return true the compositor display is X11
+#define NS_NATIVE_COMPOSITOR_DISPLAY_X11 106
 #endif // MOZ_X11
 #endif
 #ifdef MOZ_WIDGET_ANDROID
